
## Dateien und Verzeichnisse

Ein grundlegendes Konzept, dass man verinnerlicht haben muss, um sich weitere
Eigenheiten von Linux und UNIX zu verstehen, ist die Datei.

Abstrakt betrachtet ist eine Datei ein Datenspeicher, man kann hinein
schreiben und daraus lesen.
Diese Aussage erscheint zunächst wie ein Allgemeinplatz, aber dieser Makel
haftet allen grundsätzlichen Ideen an.
Der wesentliche Punkt ist, dass fast alles in einem Linux-System als Datei
betrachtet wird, in die man Daten schreiben beziehungsweise aus denen man
Daten lesen kann.

Dementsprechend gibt es verschiedene Arten von Dateien, die für Lese- und
Schreiboperationen in den meisten Fällen austauschbar sind.

Da gibt es zunächst die regulären Dateien, die ich auf einer Festplatte als
Magnetisierungsmuster lokalisieren könnte, auf einer CD-ROM als optisches
Muster und in Flash-Speicher als Ladung in Halbleitern.
Diese kommen vielleicht noch am ehesten dem nahe, was man sich unter einer
Datei vorstellt.
Die Daten, die hinein geschrieben wurden, sind in codierter Form in dem
Bereich vorhanden, der die Datei ausmacht und können unverändert wieder
ausgelesen werden, solange nichts kaputt geht.
Um eine reguläre Datei anzulegen kann ich den Befehl `touch` verwenden, in der
Shell die Standardausgabe umleiten oder mit einem der unzähligen Programme,
welche mit Dateien arbeiten, eine neue Datei anlegen.

Neben den regulären Dateien gibt es Gerätedateien.
Diese können genau wie reguläre Dateien verwendet werden, die Daten gehen
jedoch an das mit der Datei verknüpfte Gerät.
Gerätedateien findet man üblicherweise unterhalb von */dev/*, sie belegen
außer dem Inode keinen weiteren Speicherplatz.
Auf modernen Systemen gibt es spezielle Dateisysteme, wie *devfs*, in den die
Gerätedateien dynamisch vom Kernel zur Verfügung gestellt werden, wenn die
entsprechende Hardware verfügbar ist.
Gerätedateien werden unterteilt in Blockdateien, die zum Beispiel für die
rohen, unstrukturierten Festplatten verwendet werden, und zeichenorientierte
Dateien, die zum Beispiel für serielle Leitungen verwendet werden.
Der wesentliche Unterschied zwischen beiden ist, dass ich bei Blockgeräten
wahlfrei an beliebigen Stellen lesen und schreiben kann, während ich bei
zeichenorientierten Geräten ich immer nur ein Zeichen nach dem anderen lesen
oder schreiben kann.
Für den Kernel werden die Gerätedateien mit Hauptnummern (major number)
unterteilt, die den Typ des Gerätes bestimmen und Nebennummern (minor number),
die gleichartige Geräte untereinander differenzieren.
Gerätedateien kann ich mit dem Befehl `mknod` anlegen.

Die dritte Art von Dateien sind FIFOs oder Named Pipes.
Diese sind Endpunkte für die Interprozesskommunikation (IPC).
Wenn ein Prozess etwas in eine FIFO schreibt, kann ein anderer das lesen.
Der Kernel speichert die geschriebenen Daten zwischen und blockiert den
schreibenden Prozess bis ein anderer Prozess die Daten gelesen hat.
Genauso wird ein lesender Prozess blockiert, bis ein anderer Prozess Daten in
die FIFO geschrieben hat.
Dieser Umstand wird unter anderem von dem Init-Programm `systemd` verwendet um
verschiedene parallel gestartete Dienste zu synchronisieren.

Alle genannten Dateitypen finden sich im Dateibaum, einer hierarchischen
Datenbank aller in einem System verfügbaren Dateien.
Der Dateibaum setzt sich aus mindestens einem, in der Regel aber mehreren
oft unteschiedlichen Dateisystemen zusammen.
Neben den Dateisystemen, die auf Blockgeräten, wie Festplatten, angelegt
werden, gibt es verschiedene Spezial-Dateisysteme, wie *proc*, *sysfs*,
*tmpfs*, und so weiter.
In den Dateisystemen gibt es eine weitere spezielle Art von Dateien, die
Verzeichnisse.
Diese werden zwar genauso wie reguläre Dateien im Dateisystem gespeichert,
jedoch kann ich nicht beliebige Datein hineinschreiben.
Verzeichnisse enthalten strukturierte Einträge, die jeweils den Namen einer
Datei und einen Verweis auf die Verwaltungseinheit, den Inode.

Der Inode beschreibt den Typ und die Eigenschaften der Datei und notiert den
Platz, den die Datei auf dem Medium einnimmt.
Inodes sind fest mit einer Datei verknüpft, Verzeichniseinträge hingegen
nicht.
Ich kann mehrere Namen für dieselbe Datei, denselben Inode vergeben.
Diese Namen werden Links genannt.
Durch das Anlegen eines Links, also eines neuen Namens für eine Datei ändern
sich die Dateieigenschaften nicht.
Dieser Satz stimmt für den Inode leider nicht, da in diesem die Anzahl der
Links, die auf eine Datei verweisen, mit gezählt wird.
Sobald diese Anzahl 0 wird, wird der Inode und der von der Datei belegte
Speicher freigegeben.
Außer den Einträgen in Verzeichnissen des Dateisystems geht auch die Anzahl
der Prozesse, die eine Datei geöffnet halten in diese Linkzahl mit ein.
Dadurch ist es möglich, dass eine Datei, alle Verzeichniseinträge einer Datei
zu entfernen, ohne dass der Inode und der Speicherplatz freigegebn wird.
In diesem Fall spricht man von versteckten Dateien.
Erst wenn der letzte Prozess, der die Datei geöffnet hatte, endet, wird auch
der Inode und Speicherplatz frei gegeben.
Bis dahin kann ich die Datei mit `lsof` wieder finden.

Schließlich gibt es neben den schon erwähnten Links, die immer nur innerhalb
eines Dateisystems gelten und auch Hardlinks genannt werden, noch symbolische
Links.
Das sind Verzeichniseinträge, die lediglich auf einen anderen Pfad verweisen
und nichts mit der Datei, auf die der Pfad verweist zu tun haben.
Da symbolische Links nicht auf Inodes verweisen, zählen sie auch nicht bei der
Linkzahl letzterer.
Dafür können sie über Dateisystemgrenzen verlinken und auch auf Verzeichnisse,
was wiederum mit Hardlinks nicht funktioniert.


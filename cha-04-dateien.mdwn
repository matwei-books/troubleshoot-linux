
## Dateien und Verzeichnisse {#sec-linux-grundlagen-dateien}

Ein grundlegendes Konzept, dass man verinnerlicht haben muss, um weitere
Eigenheiten von Linux und UNIX zu verstehen, ist die Datei.

Abstrakt betrachtet ist eine Datei ein Datenspeicher, man kann hinein
schreiben und daraus lesen.
Diese Aussage erscheint zunächst wie ein Allgemeinplatz, aber dieser Makel
haftet allen grundsätzlichen Ideen an.
Der wesentliche Punkt ist, dass fast alles in einem Linux-System als Datei
betrachtet wird, in die man Daten schreiben beziehungsweise aus denen man
Daten lesen kann.

Dementsprechend gibt es verschiedene Arten von Dateien, die für Lese- und
Schreiboperationen in den meisten Fällen austauschbar sind.

Da gibt es zunächst die regulären Dateien, die ich auf einer Festplatte als
Magnetisierungsmuster lokalisieren könnte, auf einer CD-ROM als optisches
Muster und in Flash-Speicher als Ladung in Halbleitern.
Diese kommen vielleicht noch am ehesten dem nahe, was man sich unter einer
Datei vorstellt.
Die Daten, die hinein geschrieben wurden, sind in codierter Form in dem
Bereich vorhanden, der die Datei ausmacht und können unverändert wieder
ausgelesen werden, solange nichts kaputt geht.
Um eine reguläre Datei anzulegen, kann ich den Befehl `touch` verwenden, in der
Shell die Standardausgabe umleiten oder mit einem der unzähligen Programme,
welche mit Dateien arbeiten, eine neue Datei anlegen.

Neben den regulären Dateien gibt es Gerätedateien.
Diese können genau wie reguläre Dateien verwendet werden, die Daten gehen
jedoch an das mit der Datei verknüpfte Gerät.
Gerätedateien findet man üblicherweise unterhalb von */dev/*, sie belegen
außer dem Inode keinen weiteren Speicherplatz.
Auf modernen Systemen gibt es spezielle Dateisysteme, wie *devfs*, in denen
der Kernel die Gerätedateien dynamisch zur Verfügung stellt, wenn die
entsprechende Hardware verfügbar ist.
Gerätedateien unterteilt man in blockorientierte Dateien, die zum Beispiel für
rohe, unstrukturierte Festplatten verwendet werden, und zeichenorientierte
Dateien, die zum Beispiel für serielle Leitungen verwendet werden.
Der wesentliche Unterschied zwischen beiden ist, dass ich bei Blockgeräten
wahlfrei an beliebigen Stellen lesen und schreiben kann, während ich bei
zeichenorientierten Geräten immer nur ein Zeichen nach dem anderen lesen
oder schreiben kann.
Für den Kernel werden die Gerätedateien mit Hauptnummern (major number)
unterteilt, die den Typ des Gerätes bestimmen, und Nebennummern (minor number),
die gleichartige Geräte untereinander differenzieren.
Gerätedateien kann ich mit dem Befehl `mknod` anlegen.

Die nächste Art von Dateien sind FIFOs oder Named Pipes.
Diese sind Endpunkte für die Interprozesskommunikation (IPC).
Wenn ein Prozess etwas in eine FIFO schreibt, kann ein anderer das lesen.
Der Kernel speichert die geschriebenen Daten zwischen und blockiert den
schreibenden Prozess bis ein anderer Prozess die Daten gelesen hat.
Genauso blockiert er einen lesenden Prozess, bis ein anderer Prozess Daten in
die FIFO geschrieben hat.
Dieser Umstand wird unter anderem vom Init-Programm `systemd` verwendet, um
verschiedene parallel gestartete Dienste zu synchronisieren.
UNIX-Sockets sind in gewisser Weise den FIFOs ähnlich, der Hauptunterschied
ist, dass ein Prozess bei einem Socket sowohl lesen als auch schreiben kann.
Damit ist bidirektionale Kommunikation möglich, für die man sonst zwei FIFOs
benötigen würde.

Alle genannten Dateitypen befinden sich im Dateibaum, einer hierarchischen
Datenbank aller in einem System verfügbaren Dateien.
Der Dateibaum setzt sich aus mindestens einem, in der Regel aber mehreren,
oft unterschiedlichen Dateisystemen zusammen.
Neben den Dateisystemen, die auf Blockgeräten, wie Festplatten, angelegt
werden, gibt es verschiedene Spezial-Dateisysteme, wie *proc*, *sysfs*,
*tmpfs*.
In den Dateisystemen finde ich eine weitere spezielle Art von Dateien, die
Verzeichnisse.
Diese werden zwar genauso wie reguläre Dateien im Dateisystem gespeichert,
jedoch kann ich nicht beliebige Daten hineinschreiben.
Verzeichnisse enthalten strukturierte Einträge, die jeweils den Namen einer
Datei und einen Verweis auf die Verwaltungseinheit, den Inode, umfassen.

Der Inode beschreibt den Typ und die Eigenschaften der Datei und notiert den
Platz, den die Datei auf dem Medium einnimmt.
Inodes sind fest mit einer Datei verknüpft, Verzeichniseinträge hingegen
nicht.
Ich kann mehrere Namen für dieselbe Datei, denselben Inode vergeben.
Diese Namen werden Links genannt.
Durch das Anlegen eines Links, also eines neuen Namens für eine Datei ändern
sich die Dateieigenschaften nicht.
Dieser Satz stimmt nicht für den Inode, da in diesem die Anzahl der
Links, die auf eine Datei verweisen, mitgezählt wird.
Sobald diese Anzahl 0 wird, wird der Inode und der von der Datei belegte
Speicher freigegeben.
Außer den Einträgen in Verzeichnissen des Dateisystems geht noch die Anzahl
der Prozesse, die eine Datei geöffnet halten in diese Linkzahl mit ein.
Dadurch ist es möglich, alle Verzeichniseinträge einer Datei
zu entfernen, ohne dass der Inode und der Speicherplatz freigegeben werden.
In diesem Fall spricht man von versteckten Dateien.
Erst wenn der letzte Prozess, der die Datei geöffnet hatte, seinen
Dateideskriptor dafür schließt, wird auch
der Inode und Speicherplatz freigegeben.
Bis dahin kann ich die Datei zum Beispiel mit `lsof` wieder finden.

Schließlich gibt es neben den schon erwähnten Links, die immer nur innerhalb
eines Dateisystems gelten und auch Hardlinks genannt werden, noch symbolische
Links.
Das sind Verzeichniseinträge, die lediglich auf einen anderen Pfad verweisen
und sonst nichts mit der Datei, auf die der Pfad verweist, zu tun haben.
Da sie nicht auf Inodes verweisen, zählen sie auch nicht bei der
Linkzahl letzterer.
Es ist möglich, dass ein symbolischer Link auf einen nicht vorhandenen
Verzeichniseintrag verweist.
Dafür können symbolische Links über Dateisystemgrenzen und auch auf
Verzeichnisse verlinken, was wiederum mit Hardlinks nicht funktioniert.


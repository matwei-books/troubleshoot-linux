%% tl-netz-werkzeuge.tex
\chapter{Werkzeuge zur Netzwerkfehlersuche}
\label{cha:netz-werkzeuge}

\begin{abstractsec}
  Verschiedene Werkzeuge eignen sich zur Fehlersuche im Netz. Hier stelle ich
  diejenigen vor, die ich in den nächsten Kapiteln einsetzen will.
\end{abstractsec}

\begin{notes}
\item[nmap] zur ersten Diagnose von Verbindungsproblemen
\item[tcpdump, wireshark, libtrace-tools] zur Diagnose von hartnäckigen
  Verbindungsproblemen
\item[quagga] zur Diagnose und Manipulation von Routingprotokollen und
  -tabellen
\item[telnet, nc, openssl, smbclient] zum Testen von Anwendungsprotokollen
\item[iperf, ttcp, nuttcp] zur Diagnose von Performanceproblemen
\end{notes}

\section{arp}
\label{sec:netz-werkzeuge-arp}
\begin{abstractsec}
  Das Programm arp dient der Anzeige und Manipulation des ARP-Caches des
  Kernels und wird bei Problemen in direkt angeschlossenen Netzwerksegmenten
  eingesetzt.
\end{abstractsec}
\begin{normaltext}
  Das Programm arp dient der Anzeige und Manipulation des ARP-Caches des
  Kernels und wird bei Problemen in direkt angeschlossenen Netzwerksegmenten
  eingesetzt.

  ARP, das (Ethernet) Address Resolution Protocol, dient der Zuordnung von
  Internetadressen zu Ethernet-Adressen. Es wurde in RFC826 beschrieben und in
  RFC5227 und RFC5494 aktualisiert.

  Der prinzipielle Aufruf ist:
  \begin{verbatim}
# arp [Optionen] [Rechnername]
  \end{verbatim}

  Bei Aufruf ohne Optionen zeigt arp die MAC-Adressen an, die Rechnername
  zugeordnet sind. Fehlt Rechnername, werden alle bekannten Adresszuordnungen
  angezeigt. Rechnername kann dabei ein Hostname sein, ein FQDN oder eine
  IP-Adresse.

  Die für die Fehlersuche wichtigsten Optionen sind:
  \begin{description}
    \item[-n] damit unterlässt das Programm die Namensauflösung bei der
      Anzeige
    \item[-d Rechnername] entfernt alle Einträge für Rechnername
    \item[-s Rechnername Hardwareadresse] setzt den Eintrag für Rechnername
      auf Hardwareadresse
  \end{description}
  Für weitergehende Informationen verweise ich wieder auf die Handbuchseite.
\end{normaltext}

\section{bridge-utils}
\label{sec:netz-werkzeuge-bridge-utils}
\begin{abstractsec}
  Ein Rechner mit Linux kann nicht nur als Router IP-Pakete in Layer 3
  weiterleiten, sondern auch als Bridge in Layer 2. Letzteres wird mit den
  bridge-utils konfiguriert.
\end{abstractsec}
\begin{normaltext}
  Ein Rechner mit Linux kann nicht nur als Router IP-Pakete in Layer 3
  weiterleiten, sondern auch als Bridge in Layer 2. Letzteres wird mit den
  bridge-utils konfiguriert.

  Es gibt mehrere Szenarien, in denen man sich bei der Fehlersuche mit der
  Linux-Layer2-Bridge beschäftigen muß. Zum einen, wenn ich einen verdächtigen
  Rechner habe und zur Kontrolle jeglichen Netzverkehrs eine Bridge vor seinen
  Netzanschluß schalten will. Oder, wenn ich den Verkehr auf einer
  Punkt-zu-Punkt-Verbindung kontrollieren will. In diesen Fällen möchte ich
  das restliche Netzwerk möglichst unverändert lassen und keinen anderen
  Rechner umkonfigurieren um das Problem beobachten zu können. Mit einer
  Bridge bekomme ich allen Datenverkehr an der betreffenden Stelle frei Haus
  geleifert. Bis 100 MBit/s eignen sich beispielsweise kleine
  Einplatinenrechner, wie in \cite{weidner12:linuxkopflos} beschrieben, sehr
  gut dafür. Ein anderes Szenario ist eine regulär betriebene Bridge (zum
  Beispiel für virtuelle Maschinen), die scheinbar nicht funktioniert und die
  ich mit den bridge-utils untersuchen kann.

  Prinzipiell kann ich mit einer Linux-Bridge den Verkehr filtern und
  begrenzen. Dafür verwende ich auf Layer2-Ebene \verb?ebtables? und auf
  Layer3-Ebene \verb?iptables?, bei letzteren benötige ich für eine Bridge
  mindestens einen Kernel ab Version 2.4.

  Linux-Bridges können das Spanning Tree Protocol (STP) verwenden und ich kann
  sie auch zur Diagnose von STP-Problemen heranziehen (obwohl mir hier sicher
  tcpdump, wireshark, etc genausogut weiterhelfen.

  Generell wird eine Bridge mit den Programmen \verb?ifconfig?
  (beziehungsweise \verb?ip? von iproute2) und \verb?brctl? konfiguriert.

  Falls eine Bridge keinen Traffic durchlässt, kann ich in
  \verb?/proc/sys/net/bridge/? nach Dateien mit Namen wie \verb?bridge-nf-*?
  suchen. Diese legen fest, ob die betreffende Bridge Verkehr filtert. Das
  kann ich abschalten, indem ich eine '0' in die betreffende Datei schreibe:
  \begin{verbatim}
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-arptables
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-ip6tables
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-iptables
  \end{verbatim}

  Ein Problem mit Bridges könnte das Bridge-Forwarding-Delay von circa 30
  Sekunden sein, das bei DHCP-Clients Probleme bereiten kann.

  Mit dem Program \verb?brctl? bearbeite beziehungsweise inspiziere ich
  die Bridge-Konfiguration im Linux-Kernel.

  Dabei verwende ich die folgenden Befehle um eine oder mehrere
  Bridge-Instanzen zu bearbeiten:
  \begin{description}
    \item[brctl addbr name] fügt eine neue Bridge-Instanz namens 'name' hinzu.
    \item[brctl delbr name] entfernt die Bridge 'name'.
    \item[brctl show] zeigt alle momentan bekannten Bridges und die ihnen
      zugeordneten Interfaces an.
  \end{description}

  Jede Bridge benötigt Ports, zwischen denen sie Ethernet-Pakete vermittelt.
  Diese bearbeite ich mit den folgenden Befehlen:
  \begin{description}
    \item[brctl addif brname if] fügt die Schnittstelle 'if' zur Bridge
      mit Namen 'brname' hinzu. Das Interface muss ich mit \verb?ifconfig?
      oder \verb?ip? aktivieren.
    \item[brctl delif brname if] entfernt Schnittstelle 'if' von Bridge
      'brname'.
    \item[brctl show brname] zeigt Informationen zur Bridge 'brname'.
    \item[brctl showmacs brname] zeigt die der Bridge 'brname' momentan
      bekannten MAC-Adressen an. Um herauszufinden, an welcher Schnittstelle
      die betreffende MAC-Adresse zuletzt gesichtet wurde, bestimme ich die
      die Adresse und den Port in den Zeilen, in denen bei Spalte
      \verb!is local?! auf 'yes' steht und ermittle mit \verb?ifconfig? oder
      \verb?ip? die betreffende Ethernetschnittstelle.
  \end{description}

  Die Timer der Bridge kann ich mit den folgenden Befehlen bearbeiten:
  \begin{description}
    \item[brctl setageing brname time] setzt den Ageing-Timer für die Bridge
      'brname'. Nach dem eine MAC-Adresse so viele Sekunden nicht gesehen
      wurde, wird die Bridge sie aus der Forwarding-Tabelle austragen.
    \item[brctl setgcint brname time] setzt das Intervall für die Garbage
      Collection auf 'time' Sekunden. Aller 'time' Sekunden kontrolliert die
      Bridge die Forwarding-Tabelle nach veralteten MAC-Adressen.
  \end{description}

  Das Spanning Tree Protocol kann ich mit den folgenden Befehlen bearbeiten:
  \begin{description}
    \item[brctl stp brname status] schaltet STP an Bridge 'brname' ein, wenn
      ich für 'status' \verb?on? oder \verb?yes? angebe.
    \item[brctl showstp brname] zeigt detaillierte Angaben zu STP an Bridge
      'brname'.
  \end{description}
  Für weitere Befehle zur Manipulation von STP verweise ich auf die
  Handbuchseite. Vor deren Einsatz empfiehlt es sich, sich mit dem Spanning
  Tree Protocol vertraut zu machen.
\end{normaltext}
\begin{notes}
\item Skript, um Interface zu MAC-Adressen auszugeben
\item Referenzen zum Spanning Tree Protocol
\end{notes}

\section{ifconfig}
\label{sec:netz-werkzeuge-ifconfig}
\begin{abstractsec}
  Das Programm ifconfig dient traditionell der Konfiguration der
  Netzwerkschnittstellen. Außerdem liefert es Informationen über den aktuellen
  Zustand und die Konfiguration der Netzwerkschnittstelle.
\end{abstractsec}
\begin{normaltext}
  Das Programm ifconfig dient traditionell der Konfiguration der
  Netzwerkschnittstellen. Außerdem liefert es Informationen über den aktuellen
  Zustand und die Konfiguration der Netzwerkschnittstelle.

  Es gibt drei prinzipielle Aufrufmöglichkeiten für ifconfig. Mit
  \begin{verbatim}
# ifconfig [-a]
  \end{verbatim}
  zeigt das Programm den Status der aktiven Schnittstellen (ohne \verb?-a?)
  beziehungsweise aller (aktiven und nichtaktiven) Schnittstellen (mit
  \verb?-a?) an.

  Durch Aufruf von
  \begin{verbatim}
# ifconfig $schnittstellenname
  \end{verbatim}
  zeigt das Programm den Zustand genau der angegebenen Schnittstelle an.

  In der dritten Form,
  \begin{verbatim}
# ifconfig $schnittstellenname $optionen
  \end{verbatim}
  wird die Schnittstelle konfiguriert.

  Die wichtigsten Optionen beim Troubleshooting sind
  \begin{description}
    \item[up] zum Aktivieren von Schnittstellen
    \item[down] zum Deaktivieren
    \item[mtn N] zum Setzen der Maximum Transfer Unit
    \item[netmask M] zum Setzen der Netzmaske
    \item[hw A] zum Setzen der Hardware-Adresse
  \end{description}

  Weitere Informationen liefert die Handbuchseite.

  Es ist möglich, an eine Netzwerkschnittstelle mehrere IP-Adressen zu binden.
  Das Programm ifconfig arbeitet jedoch mit einer Adresse pro Schnittstelle.
  Um weitere Adressen an diese Schnittstelle zu binden, fügt man an den
  Schnittstellennamen einen Doppelpunkt und eine Zahl an.

  In letzter Zeit werden die Netzwerkschnittstellen auch mit dem Programm ip
  vom Paket iproute2 konfiguriert, welches in Sektion
  \ref{sec:netz-werkzeuge-iproute} beschrieben ist.
  Für den schnellen Überblick über die aktuelle Schnittstellenkonfiguration
  gefällt mir die Ausgabe von \verb?ip addr show? besser, da sie kompakter
  ist, was sich insbesondere dann auszahlt, wenn ein Rechner mehrere
  Netzwerkschnittstellen hat, oder mehrere Adressen auf einer Schnittstelle.

  Hier habe ich die Ausgabe für einen Rechner:
  \begin{verbatim}
$ /sbin/ifconfig -a
eth0      Link encap:Ethernet  HWaddr 00:01:6c:6f:c5:d6  
          inet addr:192.0.2.5  Bcast:192.0.2.255  Mask:255.255.255.0
          inet6 addr: 2001:db8::201:6cff:fe6f:c5d6/64 Scope:Global
          inet6 addr: fe80::201:6cff:fe6f:c5d6/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12259377 errors:0 dropped:0 overruns:0 frame:0
          TX packets:13256939 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:1000 
          RX bytes:3104599402 (2.8 GiB)  TX bytes:1370040423 (1.2 GiB)
          Interrupt:30 

eth0:0    Link encap:Ethernet  HWaddr 00:01:6c:6f:c5:d6  
          inet addr:192.0.2.246  Bcast:192.0.2.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          Interrupt:30 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:5386162 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5386162 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:668745964 (637.7 MiB)  TX bytes:668745964 (637.7 MiB)

wlan0     Link encap:Ethernet  HWaddr 0c:60:76:7c:3e:25  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
  \end{verbatim}
  Die Ausgabe von \verb?ip? ist demgegenüber wesentlich kompakter.
  \begin{verbatim}
$ ip addr show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:01:6c:6f:c5:d6 brd ff:ff:ff:ff:ff:ff
    inet 192.0.2.246/24 brd 192.0.2.255 scope global eth0:0
    inet 192.0.2.5/24 brd 192.0.2.255 scope global secondary eth0
    inet6 2001:db8:201:6cff:fe6f:c5d6/64 scope global dynamic 
       valid_lft 86345sec preferred_lft 14345sec
    inet6 fe80::201:6cff:fe6f:c5d6/64 scope link 
       valid_lft forever preferred_lft forever
3: wlan0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 0c:60:76:7c:3e:25 brd ff:ff:ff:ff:ff:ff
  \end{verbatim}

\end{normaltext}

\section{iproute}
\label{sec:netz-werkzeuge-iproute}
\begin{abstractsec}
  Die Programme der iproute-Suite sind moderne Werkzeuge zur Anzeige und
  Konfiguration von Netzwerkschnittstellen, -routen und -verkehrskontrolle.

  Sie bieten gegenüber den Programmen der net-tools-Suite erweiterte
  Möglichkeiten.
\end{abstractsec}
\begin{normaltext}
  Die Programme der iproute-Suite sind moderne Werkzeuge zur Anzeige und
  Konfiguration von Netzwerkschnittstellen, -routen und -verkehrskontrolle.

  Sie bieten gegenüber den Programmen der net-tools-Suite erweiterte
  Möglichkeiten.

  Mit dem Kernel kommunizieren sie über die (rt)netlink-Schnittstelle.

  Die iproute-Suite umfasst unter anderem die folgenden Programme:
  \begin{description}
    \item[ip] zum Anzeigen und Konfigurieren von Netzwerkschnittstellen,
      -adressen, -routen, Policy-Regeln, ARP- und NDISC-Einträgen, IP-Tunneln
      und Multicast
    \item[ss] zur Anzeige von Socketstatistiken
    \item[tc] zur Anzeige und Konfiguration von Netzwerkverkehrskontrolle
      (traffic control)
    \item[arpd] einen Userspace-ARP-Daemon
    \item[*stat, rtacct] verschiedene Statistikwerkzeuge
  \end{description}

  Weitere und genauere Informationen stehen in den betreffenden Handbuchseiten
  und der zugehörigen Dokumentation.

  \subsection*{ip}

  Das Program ip dient zum Anzeigen / Manipulieren von Routen, Schnittstellen,
  Policy-Routing und Tunneln. Es ist das Programm aus der Suite, das ich am
  häufigsten interaktiv aufrufe.

  Allgemein sieht der Aufruf des Programms wie folgt aus:
  \begin{verbatim}
  ip [ Optionen ] Objekt [ Befehl [ Argumente ] ]
  \end{verbatim}

  Die Optionen sind allgemeine Modifikatoren, die das Verhalten des Programms
  ändern, wie zum Beispiel \verb?-4? und \verb?-6?, die die Adressfamilie auf
  IPv4 oder IPv6 einschränken.

  Das Objekt gibt an, worüber ich Informationen wünsche, beziehungsweise, was
  ich manipulieren will. Mögliche Objekte sind unter anderem:
  \begin{description}
    \item[link] Netzwerkschnittstellen
    \item[address] Protokoll-Adressen an einer Schnittstelle
    \item[neighbour] ARP- oder NDISC-Einträge
    \item[route] Einträge in der Kernel-Routingtabelle
    \item[rule] Regeln in der Policydatenbank
    \item[maddress] Multicast-Adressen
    \item[mroute] Multicast-Routingeinträge
    \item[tunnel] IP-Tunnel
    \item[monitor] Nachrichten auf der netlink-Schnittstelle des Kernels
  \end{description}

  Der Befehl schließlich gibt die Aktion an, die wir ausführen wollen und wird
  gegebenenfalls von passenden Argumenten gefolgt. Befehl und Argumente sind
  spezifisch für die entsprechenden Objekte.
\end{normaltext}

  \subsection*{ss}

  Das Programm ss (socket statistics) liefert Informationen und Statistiken zu
  Sockets. Ähnliche Informationen kann ich zum Beispiel auch mit netstat
  bekommen, jedoch habe ich bei ss mehr Möglichkeiten zur Filterung, was mir
  insbesondere bei Servern mit vielen Verbindungen zugute kommt.

  Der Aufruf ist wie folgt:
  \begin{verbatim}
  ss [ Optionen ] [ Filter ]
  \end{verbatim}

  Debei zeigt ss ohne Optionen die verbundenen TCP-Sockets an.

  Die wichtigsten Optionen sind unter anderen:
  \begin{description}
    \item[-a] um alle Sockets anzuzeigen
    \item[-l] um nur die Listening Sockets anzuzeigen (diese werden per
      Default ausgelassen)
    \item[-p] um die zugehörigen Prozesse anzuzeigen (dafür benötige ich
      Rootrechte)
    \item[-t | -u | -w | -x] um TCP-, UDP-, Raw- oder Unix-Sockets auszuwählen
  \end{description}

  Der Filter beim Aufruf von ss hat die allgemeine Form:
  \begin{verbatim}
  [ TCP-Status ] [ Ausdruck ]
  \end{verbatim}

  Um nach TCP-Status zu filtern, gebe ich das Schlüsselwort \verb?state? oder
  \verb?exclude? gefolgt von einem der Standard-TCP-Zustandsnamen oder einem
  der folgenden an:
  \begin{description}
    \item[all] für alle Zustände
    \item[bucket] für TCP-Minisockets (TIME-WAIT|SYN-RECV)
    \item[big] für alle außer den Minisockets
    \item[connected] für alle nicht geschlossenen und nicht lauschenden
      Sockets
    \item[synchronized] für alle verbundenen Sockets, die nicht im Zustand
      SYN-SENT sind
  \end{description}

  Falls weder ein \verb?state? noch ein \verb?exclude? Statement vorhanden
  ist, ist die Voreinstellung \verb?all? bei Option \verb?-a? und ansonsten
  alle außer \verb?listening?, \verb?syn-recv?, \verb?time-wait? und
  \verb?closed?.

  Mit dem (booleschen) Ausdruck kann ich nach Adressen und Ports filtern.

  Weitere Optionen und ausführlichere Informationen zur Filterung gibt es in
  der Handbuchseite und im Artikel ``SS Utility: Quick Intro'', der sich bei
  der Dokumentation des iproute-Pakets befindet.

  \subsection*{tc}

  Mit dem Programm tc (traffic control) kann ich die Einstellungen zur
  Verkehrssteuerung des Kernels ansehen und manipulieren.

  Dabei gilt es drei Arten von Objekten zu unterscheiden:
  \begin{description}
    \item[QDISC] (queueing discipline) beschreiben das
      Warteschlangenverhalten, das heißt, wie und in welcher Reihenfolge
      Datenpakete, die in eine QDISC eingereiht wurden, an den Treiber der
      Netzwerkkarte zum Senden übergeben werden. Wenn ein Datenpaket gesendet
      werden soll, wird es in die für das Interface konfigurierte QDISC
      eingereiht. Unmittelbar danach versucht der Kernel, so viele Pakete wie
      möglich an den Netzwerkadapter zu übergeben.
    \item[CLASS] (Klassen) können in QDISC enthalten sein und wiederum weitere
      QDISC enthalten. Datenpakete werden in den inneren QDISC eingereiht.
      Datenpakete, die an den Netzwerkadapter übergeben werden, können
      von jeder inneren QDISC kommen. Dadurch, dass bestimmte Klassen vor
      anderen drankommen, kann der Datenverkehr priorisiert werden.
    \item[FILTER] entscheiden, welcher Klasse ein Datenpaket bei einem
      klassenbasierten QDISC zugeordnet wird. Alle Filter einer Klasse werden
      aufgerufen, bis einer eine Entscheidung trifft.
  \end{description}

  \subsubsection*{Klassenlose QDISC}
  Die folgenden Klassenlosen QDISC stehen zur Verfügung:
  \begin{description}
    \item[fifo] ist die einfachste Form (First In, First Out). Die QDISC
      kann auf Paketebene (pfifo) oder Byteebene (bfifo) begrenzt werden.
    \item[pfifo\_fast] ist die Standard-QDISC für Advanced Router Kernel. Diese
      enthält eine dreireihige Warteschlange, die das TOS-Feld und die
      Priorität des Datenpakets beachten.
    \item[red] (Random Early Detection) simuliert eine überlastete Leitung,
      indem zufällig Datenpakete verworfen werden, wenn sich der Durchsatz der
      konfigurierten Bandbreite nähert.
    \item[sfq] (Stochastic Fairness Queueing) sortiert die wartenden
      Datenpakete um, so dass jede Sitzung reihum dran ist.
    \item[tbf] (Token Bucket Filter) ist geeignet, um den Traffic zu eineer
      präzise konfigurierten Bandbreite zu verlangsamen.
  \end{description}

  Klassenlose QDISC müssen an der Wurzel installiert werden:
  \begin{verbatim}
tc qdisc add dev $device root $disc $params
  \end{verbatim}

  \subsubsection*{Klassenbasierte QDISC}
  Die folgenden klassenbasierten QDISC stehen zur Verfügung:
  \begin{description}
    \item[cbq] (Class Based Queueing) bildet eine Hierarchie von Klassen, die
      sich einen Link teilen und kann sowohl priorisieren als auch den
      Durchsatz begrenzen.
    \item[htb] (Hierarchy Token Buffer) ermöglicht garantierte Bandbreiten für
      Klassen und erlaubt die Ausgabe von oberen Grenzen für das Teilen von
      Bandbreite zwischen Klassen. Es enthält begrenzende Elemente auf Basis
      von TBF und kann Klassen priorisieren.
    \item[prio] wird für Priorisierung ohne Begrenzung der Bandbreite
      verwendet.
  \end{description}

  \subsubsection*{Theorie}
  Die Klassen formen einen Baum, bei dem jede Klasse genau einen Vorfahren hat
  und mehrere Kinder haben kann.

  Manche QDISC erlauben zur Laufzeit Klassen hinzuzufügen (CBQ, HTB), andere
  nicht (PRIO). Erstere können beliebig viele (auch keine) Subklassen haben,
  in denen die Datenpakete einsortiert werden.

  Jede Klasse enthält genau ein Blatt-QDISC (per Default pfifo), welcher durch
  ein anderes ersetzt werden kann. Diese QDISC kann wiederum andere Klasse
  enthalten, die zunächst auch nur ein QDISC haben.

  Wenn ein Datenpaket in einer klassenbasierten QDISC ankommt, wird es genau
  einer der enthaltenen Klassen zugeordnet. Sind Filter für eine Klasse
  definiert, werden diese zuerst für die Klassifizierung herangezogen. Einige
  QDISC werten auch das TOS-Feld des IP-Headers aus.

  Jeder Knoten im Klassenbaum kann seine eigenen Filter haben. Filter in
  höheren Ebenen können direkt auf niedrigere Klassen verweisen.

  Wenn ein Paket nicht klassifiziert werden konnte, geht es in die
  Blatt-QDISC der Klasse.

  \subsubsection*{Namen}
  Alle QDISC, Klassen und Filter haben Ids, die automatisch bestimmt oder
  explizit spezifiziert werden. Diese Ids bestehen aus einer Haupt- und einer
  Nebennummer, getrennt durch Doppelpunkt.

  Ein QDISC, welche potentiell Kinder haben kann, bekommt eine Hauptnummer,
  die 'Handle' genannt wird und lässt die Nebennummer als Namensraum für die
  Klassen. Üblicherweise benennt man QDISC, die Kinder haben, explizit.

  Alle Klassen, die zur selben QDISC gehören, teilen sich die gleiche
  Hauptnummeer. Jede hat eine separate Nebennummer, die Class-Id genann wird
  un sich auf die QDISC (nicht die Elternklasse bezieht).

  Filter haben eine dreiteilige Filter-Id, die nur bei einer Filter-Hierarchie
  benötigt werden.

  \subsubsection*{tc Befehle}
  \begin{description}
    \item[add] Fügt eine QDISC, Klasse oder einen Filter an. Der Vorfahre
      (root oder Class-Id) muss angegeben werden. QDISC oder Filter können mit
      dem \verb?handle? Parameter benannt werden, Klassen mit \verb?classid?.
    \item[remove] entfernt eine QDISK
    \item[change] modifiziert eine Einheit am Orte
    \item[replace] gleichzeitiges \verb?remove? / \verb?add?, der neue Knoten
      wird gegebenenfalls neu erzeugt
    \item[link] gleichzeitiges \verb?remove? / \verb?add?, der neue Knoten
      muss bereits existieren.
  \end{description}

  Weitere Informationen finden sich in der Handbuchseite von \verb?tc?.
  \subsection*{lnstat / nstat / rtacct}
  Diese Programme liefern Netzwerkstatistiken. Nähere Informationen siehe
  Handbuchseiten.

  \subsection*{rtmon}
  Mit dem Programm rtmon kann ich Änderungen an der Routingtabelle des Kernels
  über den \verb?netlink? Socket beobachten. Das Programm kann vor der ersten
  Netzwerkkonfiguration, zum Beispiel in einem Init-Script, gestartet werden.

  Rtmon schreibt in eine Datei und stellt der Historie der Routingtabelle
  einen Schnappschuss des Zustandes beim Start des Programms voran. Die Datei
  kann ich mit dem bereits besprochenen Programm ip auswerten.

  Der typische Aufruf sieht in etwa so aus:
  \begin{verbatim}
  # rtmon file /var/log/rtmon.log
  \end{verbatim}
  Anschließend kann ich die protokollierten Änderungen wie folgt ausgeben
  lassen:
  \begin{verbatim}
  # ip monitor file /var/log/rtmon.log
  \end{verbatim}

  Sowohl beim Aufruf von rtmon, als auch bei dem von ip kann ich angeben, an
  welchen Objekten ich interessiert bin:
  \begin{description}
    \item[link], den Netzwerkgeräten
    \item[address], den Protokolladressen (IPv4, IPv6) an einem Gerät
    \item[route], den Einträgen der Routingtabelle
    \item[all], an allem
  \end{description}

  Weitere Informationen finden sich auch hier in der Handbuchseite.
\section{netstat}
\label{sec:netz-werkzeuge-netstat}
\begin{abstractsec}
  Mit netstat ist es möglich essentielle Informationen zur
  Netzwerkkonfiguration und zum aktuellen Zustand der Netzwerksockets und
  Verbindungen eines Rechners zu erfahren.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, dass ich auch bei der Analyse von lokalen Rechnerproblemen
  einsetze und dort bereits vorgestellt habe, ist netstat. Im Bereich
  Netzwerkprobleme kann es viele Informationen liefern, die mir, je nach
  Problemfall weiterhelfen können.

  \subsection*{Sockets}
  \label{sec:netz-werkzeuge-netstat-sockets}

  Rufe ich \verb?netstat? ohne Argumente auf, liefert es mir eine Liste der
  offenen und aktiven Sockets aller konfigurierten Adressfamilien, das
  heisst, der bestehenden Verbindungen.

  Meist interessieren mich nicht alle Adressfamilien, sondern nur ganz
  bestimmte. Dann kann ich diese zum Beispiel mit der Option
  \verb?--protocol=$familie? einschränken. Für \verb?$familie? kan ich in
  einer kommaseparierten Liste die folgenden angeben: \verb?unix?,
  \verb?inet?, \verb?ipx?, \verb?ax25?, \verb?netrom?, \verb?ddp?. Alternativ
  kann ich jeden gewünschten Familiennamen einzeln als Option übergeben:
  \verb?--unix?, \verb?--inet?, \ldots

  In diesem Teil der Buches interessiert mich vor allem die Familie
  \verb?--inet?. Diese kann ich weiter eingrenzen. Mit der Option \verb?-4?
  beziehungsweise \verb?-6? beschränke ich die Ausgabe auf die entsprechende
  Version des Internet Protokolls.

  Außerdem verwende ich
  \begin{description}
    \item[--raw oder -w] wenn ich an Raw-Sockets interessiert bin,
    \item[--tcp oder -t] für TCP-Sockets, und
    \item[--udp oder -u] für UDP-Sockets.
  \end{description}

  Bin ich nur daran interessiert, ob überhaupt ein Prozess an einem bestimmten
  Socket wartet, verwende ich die Option \verb?--listening? beziehungsweise
  \verb?-l?. Diese werden bei der normalen Ausgabe weggelassen. Will ich
  hingegen sowohl die aktiven als auch die lauschenden Sockets erfassen,
  verwende ich die Option \verb?--all? beziehungsweise \verb?-a?.

  \subsection*{Routen}
  \label{sec:netz-werkzeuge-netstat-routen}

  Wenn ich statt an den Sockets eher an den Routen interessiert bin, verwende
  ich die Option \verb?--routes? beziehungsweise \verb?-r?. Damit bekomme ich
  die gleiche Ausgabe, wei mit dem Befehl \verb?route -e?. Auch hier kann ich
  mit \verb?-4? oder \verb?-6? die Protokollversion einschränken.

  Füge ich die Option \verb?-C? hinzu, bekomme ich Informationen aus dem
  Routencache, mit der Option \verb?-F? stattdessen aus der Forwarding
  Information Base (der Routentabelle), aber das ist sowieso die
  Voreinstellung.

  \subsection*{Interfaces}
  \label{sec:netz-werkzeuge-netstat-interfaces}

  Mit der Option \verb?--interfaces? oder \verb?-i? kann ich Informationen
  über die Netzwerk-Interfaces bekommen.

  Ein einfaches \verb?netstat -i? liefert mir in einer übersichtlichen Tabelle
  zu jedem aktiven Interface unter anderem die MTU, die Anzahl der gesendeten
  und empfangenen Datenpakete sowie die Anzahl der Sende- beziehungweise
  Empfangsfehler.

  Kombiniere ich das mit \verb?-e?, bekomme ich die gleiche Ausgabe wie vom
  Program \verb?ifconfig?. Kombiniert mit \verb?-a? werden auch Interfaces
  angezeigt, die nicht im Zustand \verb?UP? sind.

  \subsection*{Multicast-Gruppen}
  \label{sec:netz-werkzeuge-netstat-groups}
  Die Option \verb?--groups? beziehungsweise \verb?-g? liefert mir
  Informationen zur Mitgliedschaft des Rechners in Multicast-Gruppen.

  Auch diese kann ich mit \verb?-4? oder \verb?-6? einschränken.

  \subsection*{Statistiken}
  \label{sec:netz-werkzeuge-netstat-statistics}

  Mit der Option \verb?--statistics? beziehungsweise \verb?-s? zeigt netstat
  zusammengefasste Statistiken für alle Protokolle.

  \subsection*{allgemeine Optionen}
  \label{sec:netz-werkzeuge-netstat-allgemein}

  Abschließen möchte ich diese kleine Vorstellung von netstat mit ein paar
  allgemeinen Optionen, mit denen ich die Ausgabe modifizieren kann.

  Die von mir wohl am meisten eingesetzte Option ist \verb?--numeric?, kurz
  \verb?-n?. Mit dieser Option zeigt netstat numerische statt symbolischer
  Informationen an und das ist insbesondere bei Netzwerkadressen ein immenser
  Geschwindigkeitsvorteil, da sonst unter Umständen etliche DNS-Anfragen mit
  den entsprechenden Verzögerungen gestellt werden, bevor die Ausgabe
  angezeigt werden kann. Natürlich kann man das auch selektiv einstellen mit
  \verb?--numeric-hosts?, \verb?--numeric-ports? und \verb?--numeric-users?.

  Mit der Option \verb?--verbose? oder \verb?-v? kann ich mehr Informationen
  bekommen, insbesondere zu nicht konfigurierten Adressfamilien.

  Ähnliches bietet die Option \verb?--extend? oder \verb?-e?, die zusätzliche
  Informationen zum Beispiel bei Interfaces liefert.

  Gebe ich die Option \verb?--continuos? oder \verb?-c? an, bekomme ich die
  Informationen aller Sekunde ausgegeben.
\end{normaltext}


\section{route}
\label{sec:netz-werkzeuge-route}
\begin{abstractsec}
  Das Programm route ist für die Anzeige und Manipulation von Routingeinträgen
  zuständig.
\end{abstractsec}
\begin{normaltext}
  Das Programm \verb?route? ist für die Anzeige und Manipulation von
  Routingeinträgen zuständig.
  
  Da die gleiche Funktionialität mit dem Befehl \verb?ip route? und
  entsprechenden Optionen erreicht werden kann, gehe ich hier nicht näher auf
  das \verb?route? ein. Falls das Paket iproute2 auf einen Rechner nicht
  installiert ist, verweise ich auf die Handbuchseite.
\end{normaltext}
\section{ethtool, mii-diag, mii-tools}
\label{sec:netz-werkzeuge-ethtool}
\begin{abstractsec}
  Mit den Programmen ethtool, mii-diag beziehungsweise mii-tool kann ich die
  Konfiguration der Ethernetschnittstellen anzeigen und manipulieren,
  zumindest bei modernen Schnittstellen.
\end{abstractsec}
\begin{normaltext}
  Mit den Programmen ethtool, mii-diag beziehungsweise mii-tool kann ich die
  Konfiguration der Ethernetschnittstellen anzeigen und manipulieren,
  zumindest bei modernen Schnittstellen.

  Dazu verwenden diese Programme meist das Media Independend Interface (MII),
  von dem sich auch der Name ableitet.

  Welches Programm installiert ist, hängt von der verwendeten
  Linux-Distribution ab. Ob man es überhaupt verenden kann, hängt auch von der
  verwendeten Ethernetkarte ab. Moderne Ethernetkarten und die
  Onboardschnittstellen neuerer Rechner funktionieren üblicherweise gut mit
  diesen Programmen.

  Unter anderem kann man mit diesen Programmen
  \begin{itemize}
    \item die Ethernet-Geschwindigkeit, das Duplexverhalten und das Aushandeln
      der Parameter mit dem Switch beziehungsweise der angeschlossenen
      Gegenstelle einstellen oder abfragen
    \item die Wake-On-Lan-Konfiguration bearbeiten
    \item Selbsttests anstoßen
  \end{itemize}

  Gerade die Möglichkeit, Fehlanpassungen in der Geschwindigkeit oder beim
  Duplexverhalten zu erkennen, kann sich als sehr wertvoll bei der Diagnose
  von Performanceproblemen erweisen.

  Bei einer LWL-Verbindung über mehrere Kilometer hatten wir ernste
  Performanceprobleme, bei denen die Transferrate in ener Richtung auf wenige
  KB/s beim beidseitigen Lasttest herunterging. Der erste Gedanke war eine
  schlechte Faser, da das Problem nur in einer Richtung auftrat. Mit den
  mii-tools konnten wir eine Fehlanpassung der Ethernetkarte mit dem
  Medienwandler diagnostizieren. Nachdem wir die Schnittstelle auf Full-Duplex
  eingestellt hatten, blieb die verfügbare Bandbreite auch bei Volllast in
  beiden Richtungen im erwarteten Rahmen.
\end{normaltext}

\section{ping}
\label{sec:netz-werkzeuge-ping}
\begin{abstractsec}
  Eines der grundlegenden und vielseitigsten Werkzeuge für das
  Netzwerk-Troubleshooting ist ping. Mit diesem Programm kann ich die
  Erreichbarkeit einer Maschine testen, die Paketlaufzeit sehen, die
  Bandbreite einer Verbindung ermitteln, die Performance meines Rechners und
  des Netzwerkes abschätzen, Netzlast für bestimmte Tests erzeugen.
\end{abstractsec}
\begin{normaltext}
  Eines der grundlegenden und vielseitigsten Werkzeuge für das
  Netzwerk-Troubleshooting ist Ping. Mit diesem Programm kann ich:
  \begin{itemize}
    \item testen, ob eine Maschine überhaupt erreichbar ist,
    \item sehen, wie lange ein Paketaustausch dauert,
    \item analysieren, welche Bandbreite die Verbindung zu einem Rechner hat,
    \item die Performance meines Rechners und Netzwerkes einschätzen,
    \item eine hohe Netzlast für andere Tests erzeugen.
  \end{itemize}

  Natürlich sind alle mit Ping gewonnen Erkenntnisse mit einer Prise Salz zu
  nehmen, aber das trifft schließlich auf jedes Werkzeug zu.

  In \cite{sloan2001} sind die Anwendungen von Ping beim
  Netzwerk-Troubleshooting sehr gut und ausführlich beschrieben, so dass ich
  sie hier nur kurz zusammenfassen brauch.

  \subsection{Verbindungstest}
  Das ist der einfachste Test, den ich mit Ping ausführen kann. Ich gebe
  \begin{verbatim}
$ ping rechnername
  \end{verbatim}
  ein und bekomme heraus, ob die betreffende Maschine erreichbar ist. Das
  heißt, ob Antwortpakete von dort zurück kommen. Ältere Versionen des
  Programms begnügten sich auch schon mit der Ausgabe:\
  \begin{verbatim}
rechnername is alive
  \end{verbatim}
  Moderne Versionen zeigen nach Beendigung des Programms (nötigenfalls durch
  Abbruch mit \verb?<CTRL>-C?) die Paketlaufzeiten und einige Statistiken an.

  Ein Problem, das das Testen der Verbindung mit Ping verhindern kan, sind zu
  restriktive Firewalleinstellungen. Bei etlichen Rechnern habe ich erlebt,
  dass diese nach der Installation zwar am Netzverkehr teilnehmen konnten,
  aber selbst nicht auf ICMP-Hello-Pakete (Ping) antworteten. Das ist, aus
  meiner Sicht, eine Überreaktion auf die Tatsache, das einige DoS-Angriffe
  das ICMP-Protokoll und insbesondere ICMP-Hello (Ping) verwendet haben. Man
  kann schlecht jedem vorschreiben, was er in seinem Netzwerk erlaubt und was
  nicht. Auf jeden Fall möchte ich jeden bitten, sachlich einen möglichen oder
  eingebildeten Gewinn an Sicherheit gegenüber der Erschwernis der
  Netzwerkdiagnose abzuwägen.

  \subsection{Netzwerkperformancemessungen}
  Ein weiteres Anwendungsgebiet sind Performancemessungen im Netzwerk. Am
  einfachsten geht die Bestimmung der Paketlaufzeit zu einem entfernten
  Rechner und zurück, denn diese gibt Ping selbst aus. Bin ich an der reinen
  Laufzeit interessiert, muss ich mir einen Zeitpunkt suchen, zu dem sehr
  wenig im Netz los ist. Aber auch die Bandbreite kann ich mit Ping bestimmen
  sowie Netzwerklast für Lastmessungen erzeugen.

  \subsection{Probleme mit Ping}
  Ein paar Sachen gibt es zu beachten, wenn ich Ping beim Troubleshooting
  verwende.

  Zunächst arbeitet Ping nicht im luftleeren Raum, snondern hängt vom
  Funktionieren anderer Netzwerkelemente ab. Arbeite ich mit Hostnamen statt
  IP-Adressen, dann muss DNS fuktionieren, oder die Namen via /etc/hosts
  auflösbar sein.

  Dann muss die Ethernet-Adresse des Zielrechners oder Routers aufgelöst
  werden können. Dazu muss ich sicherstellen, dass das ARP-Protokoll
  funktioniert oder statische ARP-Einträge verwenden (und zwar auf beiden
  Seiten). Üblicherweise wird die erste RTT bei einer Messung mit Ping durch
  das ARP-Protokoll verfälscht. Diesem Problem kann ich begegnen, indem ich
  grundsätzlich mehrere Ping-Pakete sende und die erste Zeit ignoriere.

  Bei der Bestimmung der Bandbreite eines Links verwende ich ohnehin die
  niedrigste Zeit, da ist dieses Problem bereits berücksichtigt. Ich muss
  lediglich daran denken, immer mehrere gleichartige Ping-Pakete zu senden.

  Ein weiteres mögliches Problem ist, das das korrekte Funktionieren des
  Netzwerkes von Faktoren abhängen kann, die Ping nicht beeinflussen. So kann
  zum Beispiel ein kleines Ping-Paket problemlos hindurch gelangen, während
  größere Datenpakete der Anwendungsprotokolle verworfen werden.

  Andererseits kann ICMP administrativ geblockt sein, während
  Anwendungsprotokolle von der Firewall durchgelassen werden, was zu einem
  False Negative führen kann. Gerade diese Konstellation trifft man häufig in
  Netzen, die von paranoiden Administratoren konfiguriert werden oder in
  solchen, deren Administration die Auswirkungen der betreffenden Sperren
  nicht in vollem Maße abschätzen können. Trotzdem halte ich es für sinnvoll,
  die Argumente für und wieder diese Sperren im Einzelfall zu klären und zu
  dokumentieren, damit es an dieser Stelle nicht immer wieder zu Diskussionen
  kommt, weil die Sicherheitseinstellungen das Troubleshooting erschweren. Für
  eine entsprechende Argumentation ist es notwendig, die möglichen
  Sicherheitsprobleme und gegebenenfalls alternative Gegenmaßnahmen genau zu
  kennen.

  Mögliche Argumente für ein Sperren von ICMP sind:
  \begin{description}
    \item[Smurf Attacks] Ein ICMP-Paket mit gefälschter Absenderadresse wird
      an die Broadcast-Adresse eines Netzes gesendet. Der Rechner, dem die
      gefälschte Absenderadresse gehört, bekommt von allen Rechnern des
      Netzsegments eine Antwort.
      Zur Abhilfe kann man Pakete an Netz-Broadcast-Adressen am Router
      ausfiltern. Damit schränkt man diesen Angriff auf das lokale Netz ein.
      In diesem sollte es relativ einfach möglich sein, den Verursacher zu
      ermitteln.
    \item[Ping of Death] Es gibt (ältere) Betriebssysteme, die mit übergroßen
      ICMP-Paketen nicht umgehen können und damit außer Betrieb genommen
      werden können. Dieses Problem sollte mit allen aktuellen
      Betriebssystemen behoben sein.
    \item[Auskundschaften des Netzes] Mit ICMP ist es möglich, die Adressen
      der Rechner in einem IPv4-Netz zu ermitteln. Hier ist zu bedenken, ob
      das wirklich ein Problem darstellt.
    \item[Unerwünschter Traffic] Durch ICMP (insbesondere Floodping) kann
      unnötiger unerwünschter Traffic erzeugt werden, der legitimen
      Datenverkehr behindert. Hier kann man das Problem, soweit es geht mit
      Rate-Limiting am Router eindämmen.
  \end{description}

  Wenn Ping nicht komplett blockiert wird, ist immerhin noch möglich, dass das
  Protokoll eine sehr niedrige Priorität am Router bekommt und allein dadurch,
  insbesondere bei gut ausgelateten Routern unter den Tisch fällt oder
  zumindest die RTT stark verfälscht wird.

  Bei manchen Routern kann es vorkommen, dass im Fall von NAT die
  ICMP-Echo-Antwort nicht zum anfragenden Host zurückgeschickt wird.

  Interessanterweise kann man trotz unterdrücktem ICMP zumindest im lokalen
  Netzsegment herausbekommen, ob eine bestimmte IP-Adresse verwendet wird.
  Dazu löscht man den ARP-Cache und schickt dann ein Ping-Paket zur
  entsprechenden Adresse. Ist danach ein korrekter ARP-Eintrag vorhanden, ist
  der Host angeschlossen und unterdrückt das ICMP-Echo.

  Eines muss man bei Ping-Tests immer im Hinterkopf behalten: Ping testet nur
  die Erreichbarkeit einer bestimmten IP-Adresse. Ob die angebotenen Dienste
  funktionieren und ob überhaupt der richtige Rechner diese Adresse verwendet,
  muss ich auf anderem Wege herausbekommen.
  \begin{notes}
  \item Kann Ping ohne funktionierendes Routing funktionieren?
  \end{notes}
\end{normaltext}

\section{traceroute}
\label{sec:netz-werkzeuge-traceroute}
\begin{abstractsec}
  Traceroute ist ein Werkzeug zur Untersuchung des Netzwerkpfades zu einer
  IP-Adresse.
\end{abstractsec}
\begin{normaltext}
  Traceroute ist ein Werkzeug zur Untersuchung des Netzwerkpfades zu einer
  IP-Adresse.

  Bei Problemen mit der Erreichbarkeit eines Rechners oder Netzwerkes kann ich
  es unter Umständen dazu verwenden, das letzte erreichbare Netzsegment zu
  bestimmen und dann meine nächsten Schritte auf dieses zu fokussieren. Bei
  manchen Problemen kann es auch bereits einen Hinweis auf die Art des
  Problems geben. Zum Beispiel können in der Ausgabe mehrfach auftretende
  IP-Adressen auf eine Routingschleife hin deuten.

  Die grundlegende Arbeitsweise von traceroute ist, Datenpakete zum
  Zielrechner zu senden, deren IP-time-to-live-Feld mit 0 beginnt und
  sukzessive erhöht wird, bis der Zielhost erreicht ist. Wenn ein Host oder
  Router ein Datenpaket mit einer TTL von 0 erhält, verwirft er das Datenpaket
  und schickt an den Absender eine ICMP-Nachricht, dass die TTL abgelaufen
  war. Diese ICMP-Nachricht enthält die ersten Bytes des verworfenen
  Datenpaketes, damit der Empfänger die ICMP-Nachricht dem gesendeten
  Datenpaket zuordnen kann.

  In der ursprünglichen Variante sendet traceroute UDP-Pakete ab einer
  bestimmten Portnummer und erhöht beim Senden nicht nur die TTL, sondern
  gleichzeitig auch die Portnummer. Dadurch ist es einfach, die zuückkehrenden
  ICMP-Nachrichten über den Port den richtigen TTL zuzuordnen. Damit ist es
  möglich mehrere Datenpakete mit verschiedenen TTL und Port quasi-parallel zu
  versenden und die Messzeit zu verkürzen.

  Wenn eine UDP-Nachricht am Zielhost angekommen ist, sendet dieser keine
  ICMP-ttl-exceeded-Nachricht, sondern stattdessen ICMP-port-unreachable, wenn
  an dem betreffenden Port kein Prozess lauscht. Darum ist es wichtig für
  traceroute via UDP einen Bereich zu verwenden, in dem auf dem Zielhost kein
  UDP-Port in Verwendung ist. Zwar kann der Zielhost auch an der IP-Adresse
  erkannt werden, aber gerade bei multihomed Hosts oder Routern kann das
  Datenpaket an einem anderen Interface ankommen und damit die ICMP-Antwort
  eine andere IP-Adresse.

  Da Firewalleinstellungen in Netzwerken immer restriktiver werden, gibt es
  einige Varianten von traceroute, die auch andere Protokolle verwenden und
  mit einem Port auf dem Zielrechner auskommen. So ist es möglich, traceroute
  mit ICMP-echo-Paketen (Ping), TCP-Paketen (zum Beispiel Port 25 oder 80)
  oder mit nur einem UDP-Port (zum Beispiel 53 oder 123) zu verwenden, wenn
  die Firewall für eines dieser Protokolle freigegeben ist.

  Zusätzlich zur IP-Adresse der Hops auf dem Weg zum Zielrechner zeigt
  traceroute of noch die RTT zwischen gesendetm Datenpaket und ICMP-Antwort
  an, aus der ich Rückschlüsse auf Art und Zustand des betreffenden
  Netzsegmentes ziehen kann.

  Auch bei traceroute, wie bei allen Werkzeugen, muss ich bei der
  Interpretation der Ergebnisse einige Sachen berücksichtigen.

  So zeigt zum Beispiel die Reihenfolge der Hops nur, wie die Daten in einer
  Richtung zum Zeitpunkt der Messung gelaufen sind. Bei Änderungen im Routing
  kann sich der Weg bereits während der Messung ändern. Und der Rückweg kann
  ganz anders aussehen, wenn das Routing asymmetrisch ist.

  Einige IP-Stacks senden ICMP-unreachable-Nachrichten mit einer TTL, die
  gleich der ist, mit der das Datenpaket ankam. Diese Host erscheinen dann
  (bei symmetrischem Routing) erst bei der doppelten TTL, also viel weiter weg
  als sie in Wirklichkeit sind.

  Wenn auf dem Weg der Daten zum Zielhost eine Adressumsetzung (NAT) erfolgt,
  dann gehen die ICMP-Nachrichten nach der NAT an die umgesetzte Adresse und
  erreichen möglicherweise nicht den Rechner, auf dem ich traceroute gestartet
  habe.

  Schließlich ist es möglich, dass eine sehr restriktive Firewall die
  Traceroute-Pakete einfach stillschweigend verwirft. In diesem Fall kann es
  sinnvoll sein, traceroute mit anderen Protokollen zu wiederholen und die
  Ergebnisse zu vergleichen.

  Abgesehen von diesen Problemen ist es möglich, mit traceroute eine
  hinreichend genaue Karte der erreichbaren Netze zu erstellen.

  Da es etliche Implementierungen von traceroute gibt, deren
  Kommandozeilenoptionen zum Teil erheblich voneinander abweichen, verweise
  ich auf die Dokumentation des auf dem Rechner installierten Programmes.
\end{normaltext}

\section{perl}
\label{sec:netz-werkzeuge-perl}
\begin{abstractsec}
  Für knifflige Probleme, die ich mit den spezialisierten Werkzeugen nicht zu
  fassen kriege und denen mit einfacher Shell-Programmierung auch nicht
  beizukommen ist, benötige ich eine Programmiersprache, die mächtiger als die
  Shell ist, mit der ich aber trotzdem mit wenig Aufwand ein passendes
  Programm schreiben kann. Insbesondere durch die vielen verfügbaren Module
  auf CPAN kann ich damit relativ schnell eine Speziallösung für vertrackte
  Probleme zusammenbauen.
\end{abstractsec}
\begin{normaltext}
  Perl hatte ich als Werkzeug bereits im Abschnitt über die Werkzeuge zur
  lokalen Fehlersuche beschrieben. Durch die vielen einfach verfügbaren und
  meist sehr gut getesteten und dokumentierten Module auf CPAN ist Perl auch
  ein unentbehrliches Werkzeug für die Fehlersuche bei Netzwerkproblemen.

  Das Perl Kochbuch \cite{ChristiansenTorkington04de} hatte ich bereits
  erwähnt. Mit dessen Hilfe und den darin beschriebenen Modulen von CPAN war
  es mir zum Beispiel möglich ein Testprogramm für ein Timing-Problem bei
  einem Webservice zu schreiben.

  \subsection*{HTTP Injector}

  Vor einiger Zeit hatte ich ein Problem, bei dem 502-Fehler von
  einem Webservice abhängig waren von der Zeit für die
  Anfrage. Der Betreiber des Webservices stritt das ab und um das
  Problem zu verifizieren benötigte ich die Möglichkeit HTTP-Anfragen gezielt
  zu verzögern.
  
  Ich kam mit Hilfe des Kochbuches zu folgendem Programm:
  \begin{verbatim}
01:#!/usr/bin/perl
02:use Getopt::Long;
03:use IO::Socket;
04:use Time::HiRes qw(sleep);
05:
06:my %opt = ( delay => 0 );
07:
08:GetOptions( \%opt, 'delay=i');
09:
10:my $server = shift;
11:my $port   = shift || 80;
12:
13:my $socket = IO::Socket::INET->new(PeerAddr => $server,
14:                                   PeerPort => $port,
15:                                   Proto    => 'tcp',
16:                                   Type     => SOCK_STREAM);
17:
18:my @in = <>;
19:my $del = $opt{delay} / ( 1.0 + scalar @in );
20:foreach (@in) {
21:    s/[\r\n]+$//;
22:    sleep $del;
23:    print $socket $_, "\r\n";
24:}
25:sleep $del;
26:print $socket "\r\n";
27:
28:while (my $line = <$socket>) {
29:    print $line;
30:}
  \end{verbatim}
  In den Zeilen 2-4 lade ich die benötigten Module. \verb?Getopt::Long? ist
  für die Verarbeitung der Kommandozeilenoptionen und sichert ab, dass ich mit
  \verb?--delay? einen Integerwert angebe. \verb?IO::Socket? stellt die
  Socketfunktionalität bereit, so dass ich diesen Socket wie eine Datei
  verwenden kann. \verb?Time::HiRes? stellt mir eine verbesserte
  \verb?sleep()? Funktion bereit, die mit Gleitkommazahlen zurechtkommt.

  In Zeile 6 stelle ich die Option \verb?--delay? auf den Wert 0 ein, falls
  sie nicht explizit angegeben wird. In Zeile 8 werden die Optionen
  eingelesen.

  Zeile 10 und 11 entnehmen den Server und gegebenenfalls den Port der
  Kommandozeile und in Zeile 13 öffne ich mit diesen Angaben den Socket.

  In Zeile 18 lese ich die gesamte Eingabe in ein Array ein. Dies benötige
  ich, da ich die Anzahl der Zeilen wissen muss, denn ich verzögere das Senden
  zeilenweise um jeweils einen Bruchteil der Gesamtverzögerung. Die Zeilen
  20-25 schließlich bereiten die Zeilenenden auf und senden die modifizierten
  Zeilen verzögert über den Socket. Zeile 26 schickt die Leerzeile, nach der
  der Server antwortet.

  In Zeile 28-30 liest das Skript die Antwort des Servers vom Socket und
  schreibt sie zur Standardausgabe.

  Dieses Skript kann ich nun wie folgt aufrufen:
  \begin{verbatim}
time ./http-injector.pl --delay 5 localhost 80 < request > reply

real  0m5.072s
user  0m0.056s
sys   0m0.012s
  \end{verbatim}
  Dabei steht in der Datei request die HTTP-Anfrage, die ich an den Server
  sende.
  Nach fünf Sekunden ist die Anfrage beim Server, und die Antwort landet in
  der Datei reply.

  Damit konnte ich nachweisen, dass dieselbe Anfrage einen Fehler
  lieferte, wenn sie mehr als drei Sekunden zur Übertragung brauchte und
  fehlerfrei beantwortet wurde, wenn sie weniger als drei Sekunden brauchte.
\end{normaltext}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "troubleshoot-linux"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:

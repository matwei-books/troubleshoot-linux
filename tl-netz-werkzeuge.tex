%% tl-netz-werkzeuge.tex
\chapter{Werkzeuge zur Netzwerkfehlersuche}
\label{cha:netz-werkzeuge}

\begin{abstractsec}
  Verschiedene Werkzeuge eignen sich zur Fehlersuche im Netz. Hier stelle ich
  diejenigen vor, die ich in den nächsten Kapiteln einsetzen will.
\end{abstractsec}

\begin{notes}
\item[ping, traceroute, nmap] zur ersten Diagnose von Verbindungsproblemen
\item[tcpdump, wireshark, libtrace-tools] zur Diagnose von hartnäckigen
  Verbindungsproblemen
\item[quagga] zur Diagnose und Manipulation von Routingprotokollen und
  -tabellen
\item[telnet, nc, openssl, smbclient] zum Testen von Anwendungsprotokollen
\item[iperf, ttcp, nuttcp] zur Diagnose von Performanceproblemen
\end{notes}

\section{arp}
\label{sec:netz-werkzeuge-arp}
\begin{abstractsec}
  Das Programm arp dient der Anzeige und Manipulation des ARP-Caches des
  Kernels und wird bei Problemen in direkt angeschlossenen Netzwerksegmenten
  eingesetzt.
\end{abstractsec}
\begin{normaltext}
  Das Programm arp dient der Anzeige und Manipulation des ARP-Caches des
  Kernels und wird bei Problemen in direkt angeschlossenen Netzwerksegmenten
  eingesetzt.

  ARP, das (Ethernet) Address Resolution Protocol, dient der Zuordnung von
  Internetadressen zu Ethernet-Adressen. Es wurde in RFC826 beschrieben und in
  RFC5227 und RFC5494 aktualisiert.

  Der prinzipielle Aufruf ist:
  \begin{verbatim}
# arp [Optionen] [Rechnername]
  \end{verbatim}

  Bei Aufruf ohne Optionen zeigt arp die MAC-Adressen an, die Rechnername
  zugeordnet sind. Fehlt Rechnername, werden alle bekannten Adresszuordnungen
  angezeigt. Rechnername kann dabei ein Hostname sein, ein FQDN oder eine
  IP-Adresse.

  Die für die Fehlersuche wichtigsten Optionen sind:
  \begin{description}
    \item[-n] damit unterlässt das Programm die Namensauflösung bei der
      Anzeige
    \item[-d Rechnername] entfernt alle Einträge für Rechnername
    \item[-s Rechnername Hardwareadresse] setzt den Eintrag für Rechnername
      auf Hardwareadresse
  \end{description}
  Für weitergehende Informationen verweise ich wieder auf die Handbuchseite.
\end{normaltext}

\section{bridge-utils}
\label{sec:netz-werkzeuge-bridge-utils}
\begin{abstractsec}
  Ein Rechner mit Linux kann nicht nur als Router IP-Pakete in Layer 3
  weiterleiten, sondern auch als Bridge in Layer 2. Letzteres wird mit den
  bridge-utils konfiguriert.
\end{abstractsec}
\begin{normaltext}
  Ein Rechner mit Linux kann nicht nur als Router IP-Pakete in Layer 3
  weiterleiten, sondern auch als Bridge in Layer 2. Letzteres wird mit den
  bridge-utils konfiguriert.

  Es gibt mehrere Szenarien, in denen man sich bei der Fehlersuche mit der
  Linux-Layer2-Bridge beschäftigen muß. Zum einen, wenn ich einen verdächtigen
  Rechner habe und zur Kontrolle jeglichen Netzverkehrs eine Bridge vor seinen
  Netzanschluß schalten will. Oder, wenn ich den Verkehr auf einer
  Punkt-zu-Punkt-Verbindung kontrollieren will. In diesen Fällen möchte ich
  das restliche Netzwerk möglichst unverändert lassen und keinen anderen
  Rechner umkonfigurieren um das Problem beobachten zu können. Mit einer
  Bridge bekomme ich allen Datenverkehr an der betreffenden Stelle frei Haus
  geleifert. Bis 100 MBit/s eignen sich beispielsweise kleine
  Einplatinenrechner, wie in \cite{weidner12:linuxkopflos} beschrieben, sehr
  gut dafür. Ein anderes Szenario ist eine regulär betriebene Bridge (zum
  Beispiel für virtuelle Maschinen), die scheinbar nicht funktioniert und die
  ich mit den bridge-utils untersuchen kann.

  Prinzipiell kann ich mit einer Linux-Bridge den Verkehr filtern und
  begrenzen. Dafür verwende ich auf Layer2-Ebene \verb?ebtables? und auf
  Layer3-Ebene \verb?iptables?, bei letzteren benötige ich für eine Bridge
  mindestens einen Kernel ab Version 2.4.

  Linux-Bridges können das Spanning Tree Protocol (STP) verwenden und ich kann
  sie auch zur Diagnose von STP-Problemen heranziehen (obwohl mir hier sicher
  tcpdump, wireshark, etc genausogut weiterhelfen.

  Generell wird eine Bridge mit den Programmen \verb?ifconfig?
  (beziehungsweise \verb?ip? von iproute2) und \verb?brctl? konfiguriert.

  Falls eine Bridge keinen Traffic durchlässt, kann ich in
  \verb?/proc/sys/net/bridge/? nach Dateien mit Namen wie \verb?bridge-nf-*?
  suchen. Diese legen fest, ob die betreffende Bridge Verkehr filtert. Das
  kann ich abschalten, indem ich eine '0' in die betreffende Datei schreibe:
  \begin{verbatim}
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-arptables
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-ip6tables
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-iptables
  \end{verbatim}

  Ein Problem mit Bridges könnte das Bridge-Forwarding-Delay von circa 30
  Sekunden sein, das bei DHCP-Clients Probleme bereiten kann.

  Mit dem Program \verb?brctl? bearbeite beziehungsweise inspiziere ich
  die Bridge-Konfiguration im Linux-Kernel.

  Dabei verwende ich die folgenden Befehle um eine oder mehrere
  Bridge-Instanzen zu bearbeiten:
  \begin{description}
    \item[brctl addbr name] fügt eine neue Bridge-Instanz namens 'name' hinzu.
    \item[brctl delbr name] entfernt die Bridge 'name'.
    \item[brctl show] zeigt alle momentan bekannten Bridges und die ihnen
      zugeordneten Interfaces an.
  \end{description}

  Jede Bridge benötigt Ports, zwischen denen sie Ethernet-Pakete vermittelt.
  Diese bearbeite ich mit den folgenden Befehlen:
  \begin{description}
    \item[brctl addif brname if] fügt die Schnittstelle 'if' zur Bridge
      mit Namen 'brname' hinzu. Das Interface muss ich mit \verb?ifconfig?
      oder \verb?ip? aktivieren.
    \item[brctl delif brname if] entfernt Schnittstelle 'if' von Bridge
      'brname'.
    \item[brctl show brname] zeigt Informationen zur Bridge 'brname'.
    \item[brctl showmacs brname] zeigt die der Bridge 'brname' momentan
      bekannten MAC-Adressen an. Um herauszufinden, an welcher Schnittstelle
      die betreffende MAC-Adresse zuletzt gesichtet wurde, bestimme ich die
      die Adresse und den Port in den Zeilen, in denen bei Spalte
      \verb!is local?! auf 'yes' steht und ermittle mit \verb?ifconfig? oder
      \verb?ip? die betreffende Ethernetschnittstelle.
  \end{description}

  Die Timer der Bridge kann ich mit den folgenden Befehlen bearbeiten:
  \begin{description}
    \item[brctl setageing brname time] setzt den Ageing-Timer für die Bridge
      'brname'. Nach dem eine MAC-Adresse so viele Sekunden nicht gesehen
      wurde, wird die Bridge sie aus der Forwarding-Tabelle austragen.
    \item[brctl setgcint brname time] setzt das Intervall für die Garbage
      Collection auf 'time' Sekunden. Aller 'time' Sekunden kontrolliert die
      Bridge die Forwarding-Tabelle nach veralteten MAC-Adressen.
  \end{description}

  Das Spanning Tree Protocol kann ich mit den folgenden Befehlen bearbeiten:
  \begin{description}
    \item[brctl stp brname status] schaltet STP an Bridge 'brname' ein, wenn
      ich für 'status' \verb?on? oder \verb?yes? angebe.
    \item[brctl showstp brname] zeigt detaillierte Angaben zu STP an Bridge
      'brname'.
  \end{description}
  Für weitere Befehle zur Manipulation von STP verweise ich auf die
  Handbuchseite. Vor deren Einsatz empfiehlt es sich, sich mit dem Spanning
  Tree Protocol vertraut zu machen.
\end{normaltext}
\begin{notes}
\item Skript, um Interface zu MAC-Adressen auszugeben
\item Referenzen zum Spanning Tree Protocol
\end{notes}

\section{ifconfig}
\label{sec:netz-werkzeuge-ifconfig}
\begin{abstractsec}
  Das Programm ifconfig dient traditionell der Konfiguration der
  Netzwerkschnittstellen. Außerdem liefert es Informationen über den aktuellen
  Zustand und die Konfiguration der Netzwerkschnittstelle.
\end{abstractsec}
\begin{normaltext}
  Das Programm ifconfig dient traditionell der Konfiguration der
  Netzwerkschnittstellen. Außerdem liefert es Informationen über den aktuellen
  Zustand und die Konfiguration der Netzwerkschnittstelle.

  Es gibt drei prinzipielle Aufrufmöglichkeiten für ifconfig. Mit
  \begin{verbatim}
# ifconfig [-a]
  \end{verbatim}
  zeigt das Programm den Status der aktiven Schnittstellen (ohne \verb?-a?)
  beziehungsweise aller (aktiven und nichtaktiven) Schnittstellen (mit
  \verb?-a?) an.

  Durch Aufruf von
  \begin{verbatim}
# ifconfig $schnittstellenname
  \end{verbatim}
  zeigt das Programm den Zustand genau der angegebenen Schnittstelle an.

  In der dritten Form,
  \begin{verbatim}
# ifconfig $schnittstellenname $optionen
  \end{verbatim}
  wird die Schnittstelle konfiguriert.

  Die wichtigsten Optionen beim Troubleshooting sind
  \begin{description}
    \item[up] zum Aktivieren von Schnittstellen
    \item[down] zum Deaktivieren
    \item[mtn N] zum Setzen der Maximum Transfer Unit
    \item[netmask M] zum Setzen der Netzmaske
    \item[hw A] zum Setzen der Hardware-Adresse
  \end{description}

  Weitere Informationen liefert die Handbuchseite.

  Es ist möglich, an eine Netzwerkschnittstelle mehrere IP-Adressen zu binden.
  Das Programm ifconfig arbeitet jedoch mit einer Adresse pro Schnittstelle.
  Um weitere Adressen an diese Schnittstelle zu binden, fügt man an den
  Schnittstellennamen einen Doppelpunkt und eine Zahl an.

  In letzter Zeit werden die Netzwerkschnittstellen auch mit dem Programm ip
  vom Paket iproute2 konfiguriert, welches in Sektion
  \ref{sec:netz-werkzeuge-iproute} beschrieben ist.
  Für den schnellen Überblick über die aktuelle Schnittstellenkonfiguration
  gefällt mir die Ausgabe von \verb?ip addr show? besser, da sie kompakter
  ist, was sich insbesondere dann auszahlt, wenn ein Rechner mehrere
  Netzwerkschnittstellen hat, oder mehrere Adressen auf einer Schnittstelle.

  Hier habe ich die Ausgabe für einen Rechner:
  \begin{verbatim}
$ /sbin/ifconfig -a
eth0      Link encap:Ethernet  HWaddr 00:01:6c:6f:c5:d6  
          inet addr:192.0.2.5  Bcast:192.0.2.255  Mask:255.255.255.0
          inet6 addr: 2001:db8::201:6cff:fe6f:c5d6/64 Scope:Global
          inet6 addr: fe80::201:6cff:fe6f:c5d6/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12259377 errors:0 dropped:0 overruns:0 frame:0
          TX packets:13256939 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:1000 
          RX bytes:3104599402 (2.8 GiB)  TX bytes:1370040423 (1.2 GiB)
          Interrupt:30 

eth0:0    Link encap:Ethernet  HWaddr 00:01:6c:6f:c5:d6  
          inet addr:192.0.2.246  Bcast:192.0.2.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          Interrupt:30 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:5386162 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5386162 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:668745964 (637.7 MiB)  TX bytes:668745964 (637.7 MiB)

wlan0     Link encap:Ethernet  HWaddr 0c:60:76:7c:3e:25  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
  \end{verbatim}
  Die Ausgabe von \verb?ip? ist demgegenüber wesentlich kompakter.
  \begin{verbatim}
$ ip addr show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:01:6c:6f:c5:d6 brd ff:ff:ff:ff:ff:ff
    inet 192.0.2.246/24 brd 192.0.2.255 scope global eth0:0
    inet 192.0.2.5/24 brd 192.0.2.255 scope global secondary eth0
    inet6 2001:db8:201:6cff:fe6f:c5d6/64 scope global dynamic 
       valid_lft 86345sec preferred_lft 14345sec
    inet6 fe80::201:6cff:fe6f:c5d6/64 scope link 
       valid_lft forever preferred_lft forever
3: wlan0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 0c:60:76:7c:3e:25 brd ff:ff:ff:ff:ff:ff
  \end{verbatim}

\end{normaltext}

\section{iproute}
\label{sec:netz-werkzeuge-iproute}
\begin{abstractsec}
  Die Programme der iproute-Suite sind moderne Werkzeuge zur Anzeige und
  Konfiguration von Netzwerkschnittstellen, -routen und -verkehrskontrolle.

  Sie bieten gegenüber den Programmen der net-tools-Suite erweiterte
  Möglichkeiten.
\end{abstractsec}
\begin{normaltext}
  Die Programme der iproute-Suite sind moderne Werkzeuge zur Anzeige und
  Konfiguration von Netzwerkschnittstellen, -routen und -verkehrskontrolle.

  Sie bieten gegenüber den Programmen der net-tools-Suite erweiterte
  Möglichkeiten.

  Mit dem Kernel kommunizieren sie über die (rt)netlink-Schnittstelle.

  Die iproute-Suite umfasst unter anderem die folgenden Programme:
  \begin{description}
    \item[ip] zum Anzeigen und Konfigurieren von Netzwerkschnittstellen,
      -adressen, -routen, Policy-Regeln, ARP- und NDISC-Einträgen, IP-Tunneln
      und Multicast
    \item[ss] zur Anzeige von Socketstatistiken
    \item[tc] zur Anzeige und Konfiguration von Netzwerkverkehrskontrolle
      (traffic control)
    \item[arpd] einen Userspace-ARP-Daemon
    \item[*stat, rtacct] verschiedene Statistikwerkzeuge
  \end{description}

  Weitere und genauere Informationen stehen in den betreffenden Handbuchseiten
  und der zugehörigen Dokumentation.

  \subsection*{ip}

  Das Program ip dient zum Anzeigen / Manipulieren von Routen, Schnittstellen,
  Policy-Routing und Tunneln. Es ist das Programm aus der Suite, das ich am
  häufigsten interaktiv aufrufe.

  Allgemein sieht der Aufruf des Programms wie folgt aus:
  \begin{verbatim}
  ip [ Optionen ] Objekt [ Befehl [ Argumente ] ]
  \end{verbatim}

  Die Optionen sind allgemeine Modifikatoren, die das Verhalten des Programms
  ändern, wie zum Beispiel \verb?-4? und \verb?-6?, die die Adressfamilie auf
  IPv4 oder IPv6 einschränken.

  Das Objekt gibt an, worüber ich Informationen wünsche, beziehungsweise, was
  ich manipulieren will. Mögliche Objekte sind unter anderem:
  \begin{description}
    \item[link] Netzwerkschnittstellen
    \item[address] Protokoll-Adressen an einer Schnittstelle
    \item[neighbour] ARP- oder NDISC-Einträge
    \item[route] Einträge in der Kernel-Routingtabelle
    \item[rule] Regeln in der Policydatenbank
    \item[maddress] Multicast-Adressen
    \item[mroute] Multicast-Routingeinträge
    \item[tunnel] IP-Tunnel
    \item[monitor] Nachrichten auf der netlink-Schnittstelle des Kernels
  \end{description}

  Der Befehl schließlich gibt die Aktion an, die wir ausführen wollen und wird
  gegebenenfalls von passenden Argumenten gefolgt. Befehl und Argumente sind
  spezifisch für die entsprechenden Objekte.
\end{normaltext}

  \subsection*{ss}

  Das Programm ss (socket statistics) liefert Informationen und Statistiken zu
  Sockets. Ähnliche Informationen kann ich zum Beispiel auch mit netstat
  bekommen, jedoch habe ich bei ss mehr Möglichkeiten zur Filterung, was mir
  insbesondere bei Servern mit vielen Verbindungen zugute kommt.

  Der Aufruf ist wie folgt:
  \begin{verbatim}
  ss [ Optionen ] [ Filter ]
  \end{verbatim}

  Debei zeigt ss ohne Optionen die verbundenen TCP-Sockets an.

  Die wichtigsten Optionen sind unter anderen:
  \begin{description}
    \item[-a] um alle Sockets anzuzeigen
    \item[-l] um nur die Listening Sockets anzuzeigen (diese werden per
      Default ausgelassen)
    \item[-p] um die zugehörigen Prozesse anzuzeigen (dafür benötige ich
      Rootrechte)
    \item[-t | -u | -w | -x] um TCP-, UDP-, Raw- oder Unix-Sockets auszuwählen
  \end{description}

  Der Filter beim Aufruf von ss hat die allgemeine Form:
  \begin{verbatim}
  [ TCP-Status ] [ Ausdruck ]
  \end{verbatim}

  Um nach TCP-Status zu filtern, gebe ich das Schlüsselwort \verb?state? oder
  \verb?exclude? gefolgt von einem der Standard-TCP-Zustandsnamen oder einem
  der folgenden an:
  \begin{description}
    \item[all] für alle Zustände
    \item[bucket] für TCP-Minisockets (TIME-WAIT|SYN-RECV)
    \item[big] für alle außer den Minisockets
    \item[connected] für alle nicht geschlossenen und nicht lauschenden
      Sockets
    \item[synchronized] für alle verbundenen Sockets, die nicht im Zustand
      SYN-SENT sind
  \end{description}

  Falls weder ein \verb?state? noch ein \verb?exclude? Statement vorhanden
  ist, ist die Voreinstellung \verb?all? bei Option \verb?-a? und ansonsten
  alle außer \verb?listening?, \verb?syn-recv?, \verb?time-wait? und
  \verb?closed?.

  Mit dem (booleschen) Ausdruck kann ich nach Adressen und Ports filtern.

  Weitere Optionen und ausführlichere Informationen zur Filterung gibt es in
  der Handbuchseite und im Artikel ``SS Utility: Quick Intro'', der sich bei
  der Dokumentation des iproute-Pakets befindet.

  \subsection*{tc}

  Mit dem Programm tc (traffic control) kann ich die Einstellungen zur
  Verkehrssteuerung des Kernels ansehen und manipulieren.

  Dabei gilt es drei Arten von Objekten zu unterscheiden:
  \begin{description}
    \item[QDISC] (queueing discipline) beschreiben das
      Warteschlangenverhalten, das heißt, wie und in welcher Reihenfolge
      Datenpakete, die in eine QDISC eingereiht wurden, an den Treiber der
      Netzwerkkarte zum Senden übergeben werden. Wenn ein Datenpaket gesendet
      werden soll, wird es in die für das Interface konfigurierte QDISC
      eingereiht. Unmittelbar danach versucht der Kernel, so viele Pakete wie
      möglich an den Netzwerkadapter zu übergeben.
    \item[CLASS] (Klassen) können in QDISC enthalten sein und wiederum weitere
      QDISC enthalten. Datenpakete werden in den inneren QDISC eingereiht.
      Datenpakete, die an den Netzwerkadapter übergeben werden, können
      von jeder inneren QDISC kommen. Dadurch, dass bestimmte Klassen vor
      anderen drankommen, kann der Datenverkehr priorisiert werden.
    \item[FILTER] entscheiden, welcher Klasse ein Datenpaket bei einem
      klassenbasierten QDISC zugeordnet wird. Alle Filter einer Klasse werden
      aufgerufen, bis einer eine Entscheidung trifft.
  \end{description}

  \subsubsection*{Klassenlose QDISC}
  Die folgenden Klassenlosen QDISC stehen zur Verfügung:
  \begin{description}
    \item[fifo] ist die einfachste Form (First In, First Out). Die QDISC
      kann auf Paketebene (pfifo) oder Byteebene (bfifo) begrenzt werden.
    \item[pfifo\_fast] ist die Standard-QDISC für Advanced Router Kernel. Diese
      enthält eine dreireihige Warteschlange, die das TOS-Feld und die
      Priorität des Datenpakets beachten.
    \item[red] (Random Early Detection) simuliert eine überlastete Leitung,
      indem zufällig Datenpakete verworfen werden, wenn sich der Durchsatz der
      konfigurierten Bandbreite nähert.
    \item[sfq] (Stochastic Fairness Queueing) sortiert die wartenden
      Datenpakete um, so dass jede Sitzung reihum dran ist.
    \item[tbf] (Token Bucket Filter) ist geeignet, um den Traffic zu eineer
      präzise konfigurierten Bandbreite zu verlangsamen.
  \end{description}

  Klassenlose QDISC müssen an der Wurzel installiert werden:
  \begin{verbatim}
tc qdisc add dev $device root $disc $params
  \end{verbatim}

  \subsubsection*{Klassenbasierte QDISC}
  Die folgenden klassenbasierten QDISC stehen zur Verfügung:
  \begin{description}
    \item[cbq] (Class Based Queueing) bildet eine Hierarchie von Klassen, die
      sich einen Link teilen und kann sowohl priorisieren als auch den
      Durchsatz begrenzen.
    \item[htb] (Hierarchy Token Buffer) ermöglicht garantierte Bandbreiten für
      Klassen und erlaubt die Ausgabe von oberen Grenzen für das Teilen von
      Bandbreite zwischen Klassen. Es enthält begrenzende Elemente auf Basis
      von TBF und kann Klassen priorisieren.
    \item[prio] wird für Priorisierung ohne Begrenzung der Bandbreite
      verwendet.
  \end{description}

  \subsubsection*{Theorie}
  Die Klassen formen einen Baum, bei dem jede Klasse genau einen Vorfahren hat
  und mehrere Kinder haben kann.

  Manche QDISC erlauben zur Laufzeit Klassen hinzuzufügen (CBQ, HTB), andere
  nicht (PRIO). Erstere können beliebig viele (auch keine) Subklassen haben,
  in denen die Datenpakete einsortiert werden.

  Jede Klasse enthält genau ein Blatt-QDISC (per Default pfifo), welcher durch
  ein anderes ersetzt werden kann. Diese QDISC kann wiederum andere Klasse
  enthalten, die zunächst auch nur ein QDISC haben.

  Wenn ein Datenpaket in einer klassenbasierten QDISC ankommt, wird es genau
  einer der enthaltenen Klassen zugeordnet. Sind Filter für eine Klasse
  definiert, werden diese zuerst für die Klassifizierung herangezogen. Einige
  QDISC werten auch das TOS-Feld des IP-Headers aus.

  Jeder Knoten im Klassenbaum kann seine eigenen Filter haben. Filter in
  höheren Ebenen können direkt auf niedrigere Klassen verweisen.

  Wenn ein Paket nicht klassifiziert werden konnte, geht es in die
  Blatt-QDISC der Klasse.

  \subsubsection*{Namen}
  Alle QDISC, Klassen und Filter haben Ids, die automatisch bestimmt oder
  explizit spezifiziert werden. Diese Ids bestehen aus einer Haupt- und einer
  Nebennummer, getrennt durch Doppelpunkt.

  Ein QDISC, welche potentiell Kinder haben kann, bekommt eine Hauptnummer,
  die 'Handle' genannt wird und lässt die Nebennummer als Namensraum für die
  Klassen. Üblicherweise benennt man QDISC, die Kinder haben, explizit.

  Alle Klassen, die zur selben QDISC gehören, teilen sich die gleiche
  Hauptnummeer. Jede hat eine separate Nebennummer, die Class-Id genann wird
  un sich auf die QDISC (nicht die Elternklasse bezieht).

  Filter haben eine dreiteilige Filter-Id, die nur bei einer Filter-Hierarchie
  benötigt werden.

  \subsubsection*{tc Befehle}
  \begin{description}
    \item[add] Fügt eine QDISC, Klasse oder einen Filter an. Der Vorfahre
      (root oder Class-Id) muss angegeben werden. QDISC oder Filter können mit
      dem \verb?handle? Parameter benannt werden, Klassen mit \verb?classid?.
    \item[remove] entfernt eine QDISK
    \item[change] modifiziert eine Einheit am Orte
    \item[replace] gleichzeitiges \verb?remove? / \verb?add?, der neue Knoten
      wird gegebenenfalls neu erzeugt
    \item[link] gleichzeitiges \verb?remove? / \verb?add?, der neue Knoten
      muss bereits existieren.
  \end{description}

  Weitere Informationen finden sich in der Handbuchseite von \verb?tc?.
  \subsection*{lnstat / nstat / rtacct}
  Diese Programme liefern Netzwerkstatistiken. Nähere Informationen siehe
  Handbuchseiten.

  \subsection*{rtmon}
  Mit dem Programm rtmon kann ich Änderungen an der Routingtabelle des Kernels
  über den \verb?netlink? Socket beobachten. Das Programm kann vor der ersten
  Netzwerkkonfiguration, zum Beispiel in einem Init-Script, gestartet werden.

  Rtmon schreibt in eine Datei und stellt der Historie der Routingtabelle
  einen Schnappschuss des Zustandes beim Start des Programms voran. Die Datei
  kann ich mit dem bereits besprochenen Programm ip auswerten.

  Der typische Aufruf sieht in etwa so aus:
  \begin{verbatim}
  # rtmon file /var/log/rtmon.log
  \end{verbatim}
  Anschließend kann ich die protokollierten Änderungen wie folgt ausgeben
  lassen:
  \begin{verbatim}
  # ip monitor file /var/log/rtmon.log
  \end{verbatim}

  Sowohl beim Aufruf von rtmon, als auch bei dem von ip kann ich angeben, an
  welchen Objekten ich interessiert bin:
  \begin{description}
    \item[link], den Netzwerkgeräten
    \item[address], den Protokolladressen (IPv4, IPv6) an einem Gerät
    \item[route], den Einträgen der Routingtabelle
    \item[all], an allem
  \end{description}

  Weitere Informationen finden sich auch hier in der Handbuchseite.
\section{netstat}
\label{sec:netz-werkzeuge-netstat}
\begin{abstractsec}
  Mit netstat ist es möglich essentielle Informationen zur
  Netzwerkkonfiguration und zum aktuellen Zustand der Netzwerksockets und
  Verbindungen eines Rechners zu erfahren.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, dass ich auch bei der Analyse von lokalen Rechnerproblemen
  einsetze und dort bereits vorgestellt habe, ist netstat. Im Bereich
  Netzwerkprobleme kann es viele Informationen liefern, die mir, je nach
  Problemfall weiterhelfen können.

  \subsection*{Sockets}
  \label{sec:netz-werkzeuge-netstat-sockets}

  Rufe ich \verb?netstat? ohne Argumente auf, liefert es mir eine Liste der
  offenen und aktiven Sockets aller konfigurierten Adressfamilien, das
  heisst, der bestehenden Verbindungen.

  Meist interessieren mich nicht alle Adressfamilien, sondern nur ganz
  bestimmte. Dann kann ich diese zum Beispiel mit der Option
  \verb?--protocol=$familie? einschränken. Für \verb?$familie? kan ich in
  einer kommaseparierten Liste die folgenden angeben: \verb?unix?,
  \verb?inet?, \verb?ipx?, \verb?ax25?, \verb?netrom?, \verb?ddp?. Alternativ
  kann ich jeden gewünschten Familiennamen einzeln als Option übergeben:
  \verb?--unix?, \verb?--inet?, \ldots

  In diesem Teil der Buches interessiert mich vor allem die Familie
  \verb?--inet?. Diese kann ich weiter eingrenzen. Mit der Option \verb?-4?
  beziehungsweise \verb?-6? beschränke ich die Ausgabe auf die entsprechende
  Version des Internet Protokolls.

  Außerdem verwende ich
  \begin{description}
    \item[--raw oder -w] wenn ich an Raw-Sockets interessiert bin,
    \item[--tcp oder -t] für TCP-Sockets, und
    \item[--udp oder -u] für UDP-Sockets.
  \end{description}

  Bin ich nur daran interessiert, ob überhaupt ein Prozess an einem bestimmten
  Socket wartet, verwende ich die Option \verb?--listening? beziehungsweise
  \verb?-l?. Diese werden bei der normalen Ausgabe weggelassen. Will ich
  hingegen sowohl die aktiven als auch die lauschenden Sockets erfassen,
  verwende ich die Option \verb?--all? beziehungsweise \verb?-a?.

  \subsection*{Routen}
  \label{sec:netz-werkzeuge-netstat-routen}

  Wenn ich statt an den Sockets eher an den Routen interessiert bin, verwende
  ich die Option \verb?--routes? beziehungsweise \verb?-r?. Damit bekomme ich
  die gleiche Ausgabe, wei mit dem Befehl \verb?route -e?. Auch hier kann ich
  mit \verb?-4? oder \verb?-6? die Protokollversion einschränken.

  Füge ich die Option \verb?-C? hinzu, bekomme ich Informationen aus dem
  Routencache, mit der Option \verb?-F? stattdessen aus der Forwarding
  Information Base (der Routentabelle), aber das ist sowieso die
  Voreinstellung.

  \subsection*{Interfaces}
  \label{sec:netz-werkzeuge-netstat-interfaces}

  Mit der Option \verb?--interfaces? oder \verb?-i? kann ich Informationen
  über die Netzwerk-Interfaces bekommen.

  Ein einfaches \verb?netstat -i? liefert mir in einer übersichtlichen Tabelle
  zu jedem aktiven Interface unter anderem die MTU, die Anzahl der gesendeten
  und empfangenen Datenpakete sowie die Anzahl der Sende- beziehungweise
  Empfangsfehler.

  Kombiniere ich das mit \verb?-e?, bekomme ich die gleiche Ausgabe wie vom
  Program \verb?ifconfig?. Kombiniert mit \verb?-a? werden auch Interfaces
  angezeigt, die nicht im Zustand \verb?UP? sind.

  \subsection*{Multicast-Gruppen}
  \label{sec:netz-werkzeuge-netstat-groups}
  Die Option \verb?--groups? beziehungsweise \verb?-g? liefert mir
  Informationen zur Mitgliedschaft des Rechners in Multicast-Gruppen.

  Auch diese kann ich mit \verb?-4? oder \verb?-6? einschränken.

  \subsection*{Statistiken}
  \label{sec:netz-werkzeuge-netstat-statistics}

  Mit der Option \verb?--statistics? beziehungsweise \verb?-s? zeigt netstat
  zusammengefasste Statistiken für alle Protokolle.

  \subsection*{allgemeine Optionen}
  \label{sec:netz-werkzeuge-netstat-allgemein}

  Abschließen möchte ich diese kleine Vorstellung von netstat mit ein paar
  allgemeinen Optionen, mit denen ich die Ausgabe modifizieren kann.

  Die von mir wohl am meisten eingesetzte Option ist \verb?--numeric?, kurz
  \verb?-n?. Mit dieser Option zeigt netstat numerische statt symbolischer
  Informationen an und das ist insbesondere bei Netzwerkadressen ein immenser
  Geschwindigkeitsvorteil, da sonst unter Umständen etliche DNS-Anfragen mit
  den entsprechenden Verzögerungen gestellt werden, bevor die Ausgabe
  angezeigt werden kann. Natürlich kann man das auch selektiv einstellen mit
  \verb?--numeric-hosts?, \verb?--numeric-ports? und \verb?--numeric-users?.

  Mit der Option \verb?--verbose? oder \verb?-v? kann ich mehr Informationen
  bekommen, insbesondere zu nicht konfigurierten Adressfamilien.

  Ähnliches bietet die Option \verb?--extend? oder \verb?-e?, die zusätzliche
  Informationen zum Beispiel bei Interfaces liefert.

  Gebe ich die Option \verb?--continuos? oder \verb?-c? an, bekomme ich die
  Informationen aller Sekunde ausgegeben.
\end{normaltext}


\section{route}
\label{sec:netz-werkzeuge-route}
\begin{abstractsec}
  Das Programm route ist für die Anzeige und Manipulation von Routingeinträgen
  zuständig.
\end{abstractsec}
\begin{normaltext}
  Das Programm \verb?route? ist für die Anzeige und Manipulation von
  Routingeinträgen zuständig.
  
  Da die gleiche Funktionialität mit dem Befehl \verb?ip route? und
  entsprechenden Optionen erreicht werden kann, gehe ich hier nicht näher auf
  das \verb?route? ein. Falls das Paket iproute2 auf einen Rechner nicht
  installiert ist, verweise ich auf die Handbuchseite.
\end{normaltext}
\section{ethtool, mii-diag, mii-tools}
\label{sec:netz-werkzeuge-ethtool}
\begin{abstractsec}
  Mit den Programmen ethtool, mii-diag beziehungsweise mii-tool kann ich die
  Konfiguration der Ethernetschnittstellen anzeigen und manipulieren,
  zumindest bei modernen Schnittstellen.
\end{abstractsec}
\begin{normaltext}
  Mit den Programmen ethtool, mii-diag beziehungsweise mii-tool kann ich die
  Konfiguration der Ethernetschnittstellen anzeigen und manipulieren,
  zumindest bei modernen Schnittstellen.

  Dazu verwenden diese Programme meist das Media Independend Interface (MII),
  von dem sich auch der Name ableitet.

  Welches Programm installiert ist, hängt von der verwendeten
  Linux-Distribution ab. Ob man es überhaupt verenden kann, hängt auch von der
  verwendeten Ethernetkarte ab. Moderne Ethernetkarten und die
  Onboardschnittstellen neuerer Rechner funktionieren üblicherweise gut mit
  diesen Programmen.

  Unter anderem kann man mit diesen Programmen
  \begin{itemize}
    \item die Ethernet-Geschwindigkeit, das Duplexverhalten und das Aushandeln
      der Parameter mit dem Switch beziehungsweise der angeschlossenen
      Gegenstelle einstellen oder abfragen
    \item die Wake-On-Lan-Konfiguration bearbeiten
    \item Selbsttests anstoßen
  \end{itemize}

  Gerade die Möglichkeit, Fehlanpassungen in der Geschwindigkeit oder beim
  Duplexverhalten zu erkennen, kann sich als sehr wertvoll bei der Diagnose
  von Performanceproblemen erweisen.

  Bei einer LWL-Verbindung über mehrere Kilometer hatten wir ernste
  Performanceprobleme, bei denen die Transferrate in ener Richtung auf wenige
  KB/s beim beidseitigen Lasttest herunterging. Der erste Gedanke war eine
  schlechte Faser, da das Problem nur in einer Richtung auftrat. Mit den
  mii-tools konnten wir eine Fehlanpassung der Ethernetkarte mit dem
  Medienwandler diagnostizieren. Nachdem wir die Schnittstelle auf Full-Duplex
  eingestellt hatten, blieb die verfügbare Bandbreite auch bei Volllast in
  beiden Richtungen im erwarteten Rahmen.
\end{normaltext}
\section{perl}
\label{sec:lokal-werkzeuge-perl}
\begin{abstractsec}
  Für knifflige Probleme, die ich mit den spezialisierten Werkzeugen nicht zu
  fassen kriege und denen mit einfacher Shell-Programmierung auch nicht
  beizukommen ist, benötige ich eine Programmiersprache, die mächtiger als die
  Shell ist, mit der ich aber trotzdem mit wenig Aufwand ein passendes
  Programm schreiben kann. Insbesondere durch die vielen verfügbaren Module
  auf CPAN kann ich damit relativ schnell eine Speziallösung für vertrackte
  Probleme zusammenbauen.
\end{abstractsec}
\begin{normaltext}
  Perl hatte ich als Werkzeug bereits im Abschnitt über die Werkzeuge zur
  lokalen Fehlersuche beschrieben. Durch die vielen einfach verfügbaren und
  meist sehr gut getesteten und dokumentierten Module auf CPAN ist Perl auch
  ein unentbehrliches Werkzeug für die Fehlersuche bei Netzwerkproblemen.

  Das Perl Kochbuch \cite{ChristiansenTorkington04de} hatte ich bereits
  erwähnt. Mit dessen Hilfe und den darin beschriebenen Modulen von CPAN war
  es mir zum Beispiel möglich ein Testprogramm für ein Timing-Problem bei
  einem Webservice zu schreiben.

  \subsection*{HTTP Injector}

  Vor einiger Zeit hatte ich ein Problem, bei dem 502-Fehler von
  einem Webservice abhängig waren von der Zeit für die
  Anfrage. Der Betreiber des Webservices stritt das ab und um das
  Problem zu verifizieren benötigte ich die Möglichkeit HTTP-Anfragen gezielt
  zu verzögern.
  
  Ich kam mit Hilfe des Kochbuches zu folgendem Programm:
  \begin{verbatim}
01:#!/usr/bin/perl
02:use Getopt::Long;
03:use IO::Socket;
04:use Time::HiRes qw(sleep);
05:
06:my %opt = ( delay => 0 );
07:
08:GetOptions( \%opt, 'delay=i');
09:
10:my $server = shift;
11:my $port   = shift || 80;
12:
13:my $socket = IO::Socket::INET->new(PeerAddr => $server,
14:                                   PeerPort => $port,
15:                                   Proto    => 'tcp',
16:                                   Type     => SOCK_STREAM);
17:
18:my @in = <>;
19:my $del = $opt{delay} / ( 1.0 + scalar @in );
20:foreach (@in) {
21:    s/[\r\n]+$//;
22:    sleep $del;
23:    print $socket $_, "\r\n";
24:}
25:sleep $del;
26:print $socket "\r\n";
27:
28:while (my $line = <$socket>) {
29:    print $line;
30:}
  \end{verbatim}
  In den Zeilen 2-4 lade ich die benötigten Module. \verb?Getopt::Long? ist
  für die Verarbeitung der Kommandozeilenoptionen und sichert ab, dass ich mit
  \verb?--delay? einen Integerwert angebe. \verb?IO::Socket? stellt die
  Socketfunktionalität bereit, so dass ich diesen Socket wie eine Datei
  verwenden kann. \verb?Time::HiRes? stellt mir eine verbesserte
  \verb?sleep()? Funktion bereit, die mit Gleitkommazahlen zurechtkommt.

  In Zeile 6 stelle ich die Option \verb?--delay? auf den Wert 0 ein, falls
  sie nicht explizit angegeben wird. In Zeile 8 werden die Optionen
  eingelesen.

  Zeile 10 und 11 entnehmen den Server und gegebenenfalls den Port der
  Kommandozeile und in Zeile 13 öffne ich mit diesen Angaben den Socket.

  In Zeile 18 lese ich die gesamte Eingabe in ein Array ein. Dies benötige
  ich, da ich die Anzahl der Zeilen wissen muss, denn ich verzögere das Senden
  zeilenweise um jeweils einen Bruchteil der Gesamtverzögerung. Die Zeilen
  20-25 schließlich bereiten die Zeilenenden auf und senden die modifizierten
  Zeilen verzögert über den Socket. Zeile 26 schickt die Leerzeile, nach der
  der Server antwortet.

  In Zeile 28-30 liest das Skript die Antwort des Servers vom Socket und
  schreibt sie zur Standardausgabe.

  Dieses Skript kann ich nun wie folgt aufrufen:
  \begin{verbatim}
time ./http-injector.pl --delay 5 localhost 80 < request > reply

real  0m5.072s
user  0m0.056s
sys   0m0.012s
  \end{verbatim}
  Dabei steht in der Datei request die HTTP-Anfrage, die ich an den Server
  sende.
  Nach fünf Sekunden ist die Anfrage beim Server, und die Antwort landet in
  der Datei reply.

  Damit konnte ich nachweisen, dass dieselbe Anfrage einen Fehler
  lieferte, wenn sie mehr als drei Sekunden zur Übertragung brauchte und
  fehlerfrei beantwortet wurde, wenn sie weniger als drei Sekunden brauchte.
\end{normaltext}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "troubleshoot-linux"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:

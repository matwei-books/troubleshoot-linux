%% tl-netz-werkzeuge.tex
\chapter{Werkzeuge zur Netzwerkfehlersuche}
\label{cha:netz-werkzeuge}

\begin{abstractsec}
  Verschiedene Werkzeuge eignen sich zur Fehlersuche im Netz. Hier stelle ich
  diejenigen vor, die ich in den nächsten Kapiteln einsetzen will.
\end{abstractsec}

\begin{notes}
\item[ifconfig, iproute, bridge-utils, netstat, route] zur Abfrage,
  Manipulation der (Kernel-)Netzwerkschnittstellen und Kernelrouten
\item[mii-tools, eth-tools] für Hardware-Ethernet-Schnittstellen
\item[ping, traceroute, nmap] zur ersten Diagnose von Verbindungsproblemen
\item[tcpdump, wireshark, libtrace-tools] zur Diagnose von hartnäckigen
  Verbindungsproblemen
\item[quagga] zur Diagnose und Manipulation von Routingprotokollen und
  -tabellen
\item[telnet, nc, openssl, smbclient] zum Testen von Anwendungsprotokollen
\end{notes}

\section{netstat}
\label{sec:netz-werkzeuge-netstat}

\begin{abstractsec}
  Mit netstat ist es möglich essentielle Informationen zur
  Netzwerkkonfiguration und zum aktuellen Zustand der Netzwerksockets und
  Verbindungen eines Rechners zu erfahren.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, dass ich auch bei der Analyse von lokalen Rechnerproblemen
  einsetze und dort bereits vorgestellt habe, ist netstat. Im Bereich
  Netzwerkprobleme kann es viele Informationen liefern, die mir, je nach
  Problemfall weiterhelfen können.

  \subsection*{Sockets}
  \label{sec:netz-werkzeuge-netstat-sockets}

  Rufe ich \verb?netstat? ohne Argumente auf, liefert es mir eine Liste der
  offenen und aktiven Sockets aller konfigurierten Adressfamilien, das
  heisst, der bestehenden Verbindungen.

  Meist interessieren mich nicht alle Adressfamilien, sondern nur ganz
  bestimmte. Dann kann ich diese zum Beispiel mit der Option
  \verb?--protocol=$familie? einschränken. Für \verb?$familie? kan ich in
  einer kommaseparierten Liste die folgenden angeben: \verb?unix?,
  \verb?inet?, \verb?ipx?, \verb?ax25?, \verb?netrom?, \verb?ddp?. Alternativ
  kann ich jeden gewünschten Familiennamen einzeln als Option übergeben:
  \verb?--unix?, \verb?--inet?, \ldots

  In diesem Teil der Buches interessiert mich vor allem die Familie
  \verb?--inet?. Diese kann ich weiter eingrenzen. Mit der Option \verb?-4?
  beziehungsweise \verb?-6? beschränke ich die Ausgabe auf die entsprechende
  Version des Internet Protokolls.

  Außerdem verwende ich
  \begin{description}
    \item[--raw oder -w] wenn ich an Raw-Sockets interessiert bin,
    \item[--tcp oder -t] für TCP-Sockets, und
    \item[--udp oder -u] für UDP-Sockets.
  \end{description}

  Bin ich nur daran interessiert, ob überhaupt ein Prozess an einem bestimmten
  Socket wartet, verwende ich die Option \verb?--listening? beziehungsweise
  \verb?-l?. Diese werden bei der normalen Ausgabe weggelassen. Will ich
  hingegen sowohl die aktiven als auch die lauschenden Sockets erfassen,
  verwende ich die Option \verb?--all? beziehungsweise \verb?-a?.

  \subsection*{Routen}
  \label{sec:netz-werkzeuge-netstat-routen}

  Wenn ich statt an den Sockets eher an den Routen interessiert bin, verwende
  ich die Option \verb?--routes? beziehungsweise \verb?-r?. Damit bekomme ich
  die gleiche Ausgabe, wei mit dem Befehl \verb?route -e?. Auch hier kann ich
  mit \verb?-4? oder \verb?-6? die Protokollversion einschränken.

  Füge ich die Option \verb?-C? hinzu, bekomme ich Informationen aus dem
  Routencache, mit der Option \verb?-F? stattdessen aus der Forwarding
  Information Base (der Routentabelle), aber das ist sowieso die
  Voreinstellung.

  \subsection*{Interfaces}
  \label{sec:netz-werkzeuge-netstat-interfaces}

  Mit der Option \verb?--interfaces? oder \verb?-i? kann ich Informationen
  über die Netzwerk-Interfaces bekommen.

  Ein einfaches \verb?netstat -i? liefert mir in einer übersichtlichen Tabelle
  zu jedem aktiven Interface unter anderem die MTU, die Anzahl der gesendeten
  und empfangenen Datenpakete sowie die Anzahl der Sende- beziehungweise
  Empfangsfehler.

  Kombiniere ich das mit \verb?-e?, bekomme ich die gleiche Ausgabe wie vom
  Program \verb?ifconfig?. Kombiniert mit \verb?-a? werden auch Interfaces
  angezeigt, die nicht im Zustand \verb?UP? sind.

  \subsection*{Multicast-Gruppen}
  \label{sec:netz-werkzeuge-netstat-groups}
  Die Option \verb?--groups? beziehungsweise \verb?-g? liefert mir
  Informationen zur Mitgliedschaft des Rechners in Multicast-Gruppen.

  Auch diese kann ich mit \verb?-4? oder \verb?-6? einschränken.

  \subsection*{Statistiken}
  \label{sec:netz-werkzeuge-netstat-statistics}

  Mit der Option \verb?--statistics? beziehungsweise \verb?-s? zeigt netstat
  zusammengefasste Statistiken für alle Protokolle.

  \subsection*{allgemeine Optionen}
  \label{sec:netz-werkzeuge-netstat-allgemein}

  Abschließen möchte ich diese kleine Vorstellung von netstat mit ein paar
  allgemeinen Optionen, mit denen ich die Ausgabe modifizieren kann.

  Die von mir wohl am meisten eingesetzte Option ist \verb?--numeric?, kurz
  \verb?-n?. Mit dieser Option zeigt netstat numerische statt symbolischer
  Informationen an und das ist insbesondere bei Netzwerkadressen ein immenser
  Geschwindigkeitsvorteil, da sonst unter Umständen etliche DNS-Anfragen mit
  den entsprechenden Verzögerungen gestellt werden, bevor die Ausgabe
  angezeigt werden kann. Natürlich kann man das auch selektiv einstellen mit
  \verb?--numeric-hosts?, \verb?--numeric-ports? und \verb?--numeric-users?.

  Mit der Option \verb?--verbose? oder \verb?-v? kann ich mehr Informationen
  bekommen, insbesondere zu nicht konfigurierten Adressfamilien.

  Ähnliches bietet die Option \verb?--extend? oder \verb?-e?, die zusätzliche
  Informationen zum Beispiel bei Interfaces liefert.

  Gebe ich die Option \verb?--continuos? oder \verb?-c? an, bekomme ich die
  Informationen aller Sekunde ausgegeben.
\end{normaltext}

\section{perl}
\label{sec:lokal-werkzeuge-perl}
\begin{abstractsec}
  Für knifflige Probleme, die ich mit den spezialisierten Werkzeugen nicht zu
  fassen kriege und denen mit einfacher Shell-Programmierung auch nicht
  beizukommen ist, benötige ich eine Programmiersprache, die mächtiger als die
  Shell ist, mit der ich aber trotzdem mit wenig Aufwand ein passendes
  Programm schreiben kann. Insbesondere durch die vielen verfügbaren Module
  auf CPAN kann ich damit relativ schnell eine Speziallösung für vertrackte
  Probleme zusammenbauen.
\end{abstractsec}
\begin{normaltext}
  Perl hatte ich als Werkzeug bereits im Abschnitt über die Werkzeuge zur
  lokalen Fehlersuche beschrieben. Durch die vielen einfach verfügbaren und
  meist sehr gut getesteten und dokumentierten Module auf CPAN ist Perl auch
  ein unentbehrliches Werkzeug für die Fehlersuche bei Netzwerkproblemen.

  Das Perl Kochbuch \cite{ChristiansenTorkington04de} hatte ich bereits
  erwähnt. Mit dessen Hilfe und den darin beschriebenen Modulen von CPAN war
  es mir zum Beispiel möglich ein Testprogramm für ein Timing-Problem bei
  einem Webservice zu schreiben.

  \subsection*{HTTP Injector}

  Vor einiger Zeit hatte ich ein Problem, bei dem 502-Fehler von
  einem Webservice abhängig waren von der Zeit für die
  Anfrage. Der Betreiber des Webservices stritt das ab und um das
  Problem zu verifizieren benötigte ich die Möglichkeit HTTP-Anfragen gezielt
  zu verzögern.
  
  Ich kam mit Hilfe des Kochbuches zu folgendem Programm:
  \begin{verbatim}
01:#!/usr/bin/perl
02:use Getopt::Long;
03:use IO::Socket;
04:use Time::HiRes qw(sleep);
05:
06:my %opt = ( delay => 0 );
07:
08:GetOptions( \%opt, 'delay=i');
09:
10:my $server = shift;
11:my $port   = shift || 80;
12:
13:my $socket = IO::Socket::INET->new(PeerAddr => $server,
14:                                   PeerPort => $port,
15:                                   Proto    => 'tcp',
16:                                   Type     => SOCK_STREAM);
17:
18:my @in = <>;
19:my $del = $opt{delay} / ( 1.0 + scalar @in );
20:foreach (@in) {
21:    s/[\r\n]+$//;
22:    sleep $del;
23:    print $socket $_, "\r\n";
24:}
25:sleep $del;
26:print $socket "\r\n";
27:
28:while (my $line = <$socket>) {
29:    print $line;
30:}
  \end{verbatim}
  In den Zeilen 2-4 lade ich die benötigten Module. \verb?Getopt::Long? ist
  für die Verarbeitung der Kommandozeilenoptionen und sichert ab, dass ich mit
  \verb?--delay? einen Integerwert angebe. \verb?IO::Socket? stellt die
  Socketfunktionalität bereit, so dass ich diesen Socket wie eine Datei
  verwenden kann. \verb?Time::HiRes? stellt mir eine verbesserte
  \verb?sleep()? Funktion bereit, die mit Gleitkommazahlen zurechtkommt.

  In Zeile 6 stelle ich die Option \verb?--delay? auf den Wert 0 ein, falls
  sie nicht explizit angegeben wird. In Zeile 8 werden die Optionen
  eingelesen.

  Zeile 10 und 11 entnehmen den Server und gegebenenfalls den Port der
  Kommandozeile und in Zeile 13 öffne ich mit diesen Angaben den Socket.

  In Zeile 18 lese ich die gesamte Eingabe in ein Array ein. Dies benötige
  ich, da ich die Anzahl der Zeilen wissen muss, denn ich verzögere das Senden
  zeilenweise um jeweils einen Bruchteil der Gesamtverzögerung. Die Zeilen
  20-25 schließlich bereiten die Zeilenenden auf und senden die modifizierten
  Zeilen verzögert über den Socket. Zeile 26 schickt die Leerzeile, nach der
  der Server antwortet.

  In Zeile 28-30 liest das Skript die Antwort des Servers vom Socket und
  schreibt sie zur Standardausgabe.

  Dieses Skript kann ich nun wie folgt aufrufen:
  \begin{verbatim}
time ./http-injector.pl --delay 5 localhost 80 < request > reply

real  0m5.072s
user  0m0.056s
sys   0m0.012s
  \end{verbatim}
  Dabei steht in der Datei request die HTTP-Anfrage, die ich an den Server
  sende.
  Nach fünf Sekunden ist die Anfrage beim Server, und die Antwort landet in
  der Datei reply.

  Damit konnte ich nachweisen, dass dieselbe Anfrage einen Fehler
  lieferte, wenn sie mehr als drei Sekunden zur Übertragung brauchte und
  fehlerfrei beantwortet wurde, wenn sie weniger als drei Sekunden brauchte.
\end{normaltext}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "troubleshoot-linux"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:

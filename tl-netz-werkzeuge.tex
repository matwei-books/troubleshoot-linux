%% tl-netz-werkzeuge.tex
\chapter{Werkzeuge zur Netzwerkfehlersuche}
\label{cha:netz-werkzeuge}

\begin{abstractsec}
  Verschiedene Werkzeuge eignen sich zur Fehlersuche im Netz. Hier stelle ich
  diejenigen vor, die ich in den nächsten Kapiteln einsetzen will.
\end{abstractsec}

\begin{notes}
\item[nmap, smbclient] zum Testen von Anwendungsprotokollen
\item[iperf, ttcp, nuttcp] zur Diagnose von Performanceproblemen
\end{notes}

\section{arp}
\label{sec:netz-werkzeuge-arp}
\begin{abstractsec}
  Das Programm arp dient der Anzeige und Manipulation des ARP-Caches des
  Kernels und wird bei Problemen in direkt angeschlossenen Netzwerksegmenten
  eingesetzt.
\end{abstractsec}
\begin{normaltext}
  Das Programm arp dient der Anzeige und Manipulation des ARP-Caches des
  Kernels und wird bei Problemen in direkt angeschlossenen Netzwerksegmenten
  eingesetzt.

  ARP, das (Ethernet) Address Resolution Protocol, dient der Zuordnung von
  Internetadressen zu Ethernet-Adressen. Es wurde in RFC826 beschrieben und in
  RFC5227 und RFC5494 aktualisiert.

  Der prinzipielle Aufruf ist:
  \begin{verbatim}
# arp [Optionen] [Rechnername]
  \end{verbatim}

  Bei Aufruf ohne Optionen zeigt arp die MAC-Adressen an, die Rechnername
  zugeordnet sind. Fehlt Rechnername, werden alle bekannten Adresszuordnungen
  angezeigt. Rechnername kann dabei ein Hostname sein, ein FQDN oder eine
  IP-Adresse.

  Die für die Fehlersuche wichtigsten Optionen sind:
  \begin{description}
    \item[-n] damit unterlässt das Programm die Namensauflösung bei der
      Anzeige
    \item[-d Rechnername] entfernt alle Einträge für Rechnername
    \item[-s Rechnername Hardwareadresse] setzt den Eintrag für Rechnername
      auf Hardwareadresse
  \end{description}
  Für weitergehende Informationen verweise ich wieder auf die Handbuchseite.
\end{normaltext}

\section{bridge-utils}
\label{sec:netz-werkzeuge-bridge-utils}
\begin{abstractsec}
  Ein Rechner mit Linux kann nicht nur als Router IP-Pakete in Layer 3
  weiterleiten, sondern auch als Bridge in Layer 2. Letzteres wird mit den
  bridge-utils konfiguriert.
\end{abstractsec}
\begin{normaltext}
  Ein Rechner mit Linux kann nicht nur als Router IP-Pakete in Layer 3
  weiterleiten, sondern auch als Bridge in Layer 2. Letzteres wird mit den
  bridge-utils konfiguriert.

  Es gibt mehrere Szenarien, in denen man sich bei der Fehlersuche mit der
  Linux-Layer2-Bridge beschäftigen muß. Zum einen, wenn ich einen verdächtigen
  Rechner habe und zur Kontrolle jeglichen Netzverkehrs eine Bridge vor seinen
  Netzanschluß schalten will. Oder, wenn ich den Verkehr auf einer
  Punkt-zu-Punkt-Verbindung kontrollieren will. In diesen Fällen möchte ich
  das restliche Netzwerk möglichst unverändert lassen und keinen anderen
  Rechner umkonfigurieren um das Problem beobachten zu können. Mit einer
  Bridge bekomme ich allen Datenverkehr an der betreffenden Stelle frei Haus
  geleifert. Bis 100 MBit/s eignen sich beispielsweise kleine
  Einplatinenrechner, wie in \cite{weidner12:linuxkopflos} beschrieben, sehr
  gut dafür. Ein anderes Szenario ist eine regulär betriebene Bridge (zum
  Beispiel für virtuelle Maschinen), die scheinbar nicht funktioniert und die
  ich mit den bridge-utils untersuchen kann.

  Prinzipiell kann ich mit einer Linux-Bridge den Verkehr filtern und
  begrenzen. Dafür verwende ich auf Layer2-Ebene \verb?ebtables? und auf
  Layer3-Ebene \verb?iptables?, bei letzteren benötige ich für eine Bridge
  mindestens einen Kernel ab Version 2.4.

  Linux-Bridges können das Spanning Tree Protocol (STP) verwenden und ich kann
  sie auch zur Diagnose von STP-Problemen heranziehen (obwohl mir hier sicher
  tcpdump, wireshark, etc genausogut weiterhelfen.

  Generell wird eine Bridge mit den Programmen \verb?ifconfig?
  (beziehungsweise \verb?ip? von iproute2) und \verb?brctl? konfiguriert.

  Falls eine Bridge keinen Traffic durchlässt, kann ich in
  \verb?/proc/sys/net/bridge/? nach Dateien mit Namen wie \verb?bridge-nf-*?
  suchen. Diese legen fest, ob die betreffende Bridge Verkehr filtert. Das
  kann ich abschalten, indem ich eine '0' in die betreffende Datei schreibe:
  \begin{verbatim}
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-arptables
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-ip6tables
# echo 0 > /proc/sys/net/bridge/bridge-nf-call-iptables
  \end{verbatim}

  Ein Problem mit Bridges könnte das Bridge-Forwarding-Delay von circa 30
  Sekunden sein, das bei DHCP-Clients Probleme bereiten kann.

  Mit dem Program \verb?brctl? bearbeite beziehungsweise inspiziere ich
  die Bridge-Konfiguration im Linux-Kernel.

  Dabei verwende ich die folgenden Befehle um eine oder mehrere
  Bridge-Instanzen zu bearbeiten:
  \begin{description}
    \item[brctl addbr name] fügt eine neue Bridge-Instanz namens 'name' hinzu.
    \item[brctl delbr name] entfernt die Bridge 'name'.
    \item[brctl show] zeigt alle momentan bekannten Bridges und die ihnen
      zugeordneten Interfaces an.
  \end{description}

  Jede Bridge benötigt Ports, zwischen denen sie Ethernet-Pakete vermittelt.
  Diese bearbeite ich mit den folgenden Befehlen:
  \begin{description}
    \item[brctl addif brname if] fügt die Schnittstelle 'if' zur Bridge
      mit Namen 'brname' hinzu. Das Interface muss ich mit \verb?ifconfig?
      oder \verb?ip? aktivieren.
    \item[brctl delif brname if] entfernt Schnittstelle 'if' von Bridge
      'brname'.
    \item[brctl show brname] zeigt Informationen zur Bridge 'brname'.
    \item[brctl showmacs brname] zeigt die der Bridge 'brname' momentan
      bekannten MAC-Adressen an. Um herauszufinden, an welcher Schnittstelle
      die betreffende MAC-Adresse zuletzt gesichtet wurde, bestimme ich die
      die Adresse und den Port in den Zeilen, in denen bei Spalte
      \verb!is local?! auf 'yes' steht und ermittle mit \verb?ifconfig? oder
      \verb?ip? die betreffende Ethernetschnittstelle.
  \end{description}

  Die Timer der Bridge kann ich mit den folgenden Befehlen bearbeiten:
  \begin{description}
    \item[brctl setageing brname time] setzt den Ageing-Timer für die Bridge
      'brname'. Nach dem eine MAC-Adresse so viele Sekunden nicht gesehen
      wurde, wird die Bridge sie aus der Forwarding-Tabelle austragen.
    \item[brctl setgcint brname time] setzt das Intervall für die Garbage
      Collection auf 'time' Sekunden. Aller 'time' Sekunden kontrolliert die
      Bridge die Forwarding-Tabelle nach veralteten MAC-Adressen.
  \end{description}

  Das Spanning Tree Protocol kann ich mit den folgenden Befehlen bearbeiten:
  \begin{description}
    \item[brctl stp brname status] schaltet STP an Bridge 'brname' ein, wenn
      ich für 'status' \verb?on? oder \verb?yes? angebe.
    \item[brctl showstp brname] zeigt detaillierte Angaben zu STP an Bridge
      'brname'.
  \end{description}
  Für weitere Befehle zur Manipulation von STP verweise ich auf die
  Handbuchseite. Vor deren Einsatz empfiehlt es sich, sich mit dem Spanning
  Tree Protocol vertraut zu machen.
\end{normaltext}
\begin{notes}
\item Skript, um Interface zu MAC-Adressen auszugeben
\item Referenzen zum Spanning Tree Protocol
\end{notes}

\section{ifconfig}
\label{sec:netz-werkzeuge-ifconfig}
\begin{abstractsec}
  Das Programm ifconfig dient traditionell der Konfiguration der
  Netzwerkschnittstellen. Außerdem liefert es Informationen über den aktuellen
  Zustand und die Konfiguration der Netzwerkschnittstelle.
\end{abstractsec}
\begin{normaltext}
  Das Programm ifconfig dient traditionell der Konfiguration der
  Netzwerkschnittstellen. Außerdem liefert es Informationen über den aktuellen
  Zustand und die Konfiguration der Netzwerkschnittstelle.

  Es gibt drei prinzipielle Aufrufmöglichkeiten für ifconfig. Mit
  \begin{verbatim}
# ifconfig [-a]
  \end{verbatim}
  zeigt das Programm den Status der aktiven Schnittstellen (ohne \verb?-a?)
  beziehungsweise aller (aktiven und nichtaktiven) Schnittstellen (mit
  \verb?-a?) an.

  Durch Aufruf von
  \begin{verbatim}
# ifconfig $schnittstellenname
  \end{verbatim}
  zeigt das Programm den Zustand genau der angegebenen Schnittstelle an.

  In der dritten Form,
  \begin{verbatim}
# ifconfig $schnittstellenname $optionen
  \end{verbatim}
  wird die Schnittstelle konfiguriert.

  Die wichtigsten Optionen beim Troubleshooting sind
  \begin{description}
    \item[up] zum Aktivieren von Schnittstellen
    \item[down] zum Deaktivieren
    \item[mtn N] zum Setzen der Maximum Transfer Unit
    \item[netmask M] zum Setzen der Netzmaske
    \item[hw A] zum Setzen der Hardware-Adresse
  \end{description}

  Weitere Informationen liefert die Handbuchseite.

  Es ist möglich, an eine Netzwerkschnittstelle mehrere IP-Adressen zu binden.
  Das Programm ifconfig arbeitet jedoch mit einer Adresse pro Schnittstelle.
  Um weitere Adressen an diese Schnittstelle zu binden, fügt man an den
  Schnittstellennamen einen Doppelpunkt und eine Zahl an.

  In letzter Zeit werden die Netzwerkschnittstellen auch mit dem Programm ip
  vom Paket iproute2 konfiguriert, welches in Sektion
  \ref{sec:netz-werkzeuge-iproute} beschrieben ist.
  Für den schnellen Überblick über die aktuelle Schnittstellenkonfiguration
  gefällt mir die Ausgabe von \verb?ip addr show? besser, da sie kompakter
  ist, was sich insbesondere dann auszahlt, wenn ein Rechner mehrere
  Netzwerkschnittstellen hat, oder mehrere Adressen auf einer Schnittstelle.

  Hier habe ich die Ausgabe für einen Rechner:
  \begin{verbatim}
$ /sbin/ifconfig -a
eth0      Link encap:Ethernet  HWaddr 00:01:6c:6f:c5:d6  
          inet addr:192.0.2.5  Bcast:192.0.2.255  Mask:255.255.255.0
          inet6 addr: 2001:db8::201:6cff:fe6f:c5d6/64 Scope:Global
          inet6 addr: fe80::201:6cff:fe6f:c5d6/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12259377 errors:0 dropped:0 overruns:0 frame:0
          TX packets:13256939 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:1000 
          RX bytes:3104599402 (2.8 GiB)  TX bytes:1370040423 (1.2 GiB)
          Interrupt:30 

eth0:0    Link encap:Ethernet  HWaddr 00:01:6c:6f:c5:d6  
          inet addr:192.0.2.246  Bcast:192.0.2.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          Interrupt:30 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:5386162 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5386162 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:668745964 (637.7 MiB)  TX bytes:668745964 (637.7 MiB)

wlan0     Link encap:Ethernet  HWaddr 0c:60:76:7c:3e:25  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
  \end{verbatim}
  Die Ausgabe von \verb?ip? ist demgegenüber wesentlich kompakter.
  \begin{verbatim}
$ ip addr show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:01:6c:6f:c5:d6 brd ff:ff:ff:ff:ff:ff
    inet 192.0.2.246/24 brd 192.0.2.255 scope global eth0:0
    inet 192.0.2.5/24 brd 192.0.2.255 scope global secondary eth0
    inet6 2001:db8:201:6cff:fe6f:c5d6/64 scope global dynamic 
       valid_lft 86345sec preferred_lft 14345sec
    inet6 fe80::201:6cff:fe6f:c5d6/64 scope link 
       valid_lft forever preferred_lft forever
3: wlan0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 0c:60:76:7c:3e:25 brd ff:ff:ff:ff:ff:ff
  \end{verbatim}

\end{normaltext}

\section{iproute}
\label{sec:netz-werkzeuge-iproute}
\begin{abstractsec}
  Die Programme der iproute-Suite sind moderne Werkzeuge zur Anzeige und
  Konfiguration von Netzwerkschnittstellen, -routen und -verkehrskontrolle.

  Sie bieten gegenüber den Programmen der net-tools-Suite erweiterte
  Möglichkeiten.
\end{abstractsec}
\begin{normaltext}
  Die Programme der iproute-Suite sind moderne Werkzeuge zur Anzeige und
  Konfiguration von Netzwerkschnittstellen, -routen und -verkehrskontrolle.

  Sie bieten gegenüber den Programmen der net-tools-Suite erweiterte
  Möglichkeiten.

  Mit dem Kernel kommunizieren sie über die (rt)netlink-Schnittstelle.

  Die iproute-Suite umfasst unter anderem die folgenden Programme:
  \begin{description}
    \item[ip] zum Anzeigen und Konfigurieren von Netzwerkschnittstellen,
      -adressen, -routen, Policy-Regeln, ARP- und NDISC-Einträgen, IP-Tunneln
      und Multicast
    \item[ss] zur Anzeige von Socketstatistiken
    \item[tc] zur Anzeige und Konfiguration von Netzwerkverkehrskontrolle
      (traffic control)
    \item[arpd] einen Userspace-ARP-Daemon
    \item[*stat, rtacct] verschiedene Statistikwerkzeuge
  \end{description}

  Weitere und genauere Informationen stehen in den betreffenden Handbuchseiten
  und der zugehörigen Dokumentation.

  \subsection*{ip}

  Das Program ip dient zum Anzeigen / Manipulieren von Routen, Schnittstellen,
  Policy-Routing und Tunneln. Es ist das Programm aus der Suite, das ich am
  häufigsten interaktiv aufrufe.

  Allgemein sieht der Aufruf des Programms wie folgt aus:
  \begin{verbatim}
  ip [ Optionen ] Objekt [ Befehl [ Argumente ] ]
  \end{verbatim}

  Die Optionen sind allgemeine Modifikatoren, die das Verhalten des Programms
  ändern, wie zum Beispiel \verb?-4? und \verb?-6?, die die Adressfamilie auf
  IPv4 oder IPv6 einschränken.

  Das Objekt gibt an, worüber ich Informationen wünsche, beziehungsweise, was
  ich manipulieren will. Mögliche Objekte sind unter anderem:
  \begin{description}
    \item[link] Netzwerkschnittstellen
    \item[address] Protokoll-Adressen an einer Schnittstelle
    \item[neighbour] ARP- oder NDISC-Einträge
    \item[route] Einträge in der Kernel-Routingtabelle
    \item[rule] Regeln in der Policydatenbank
    \item[maddress] Multicast-Adressen
    \item[mroute] Multicast-Routingeinträge
    \item[tunnel] IP-Tunnel
    \item[monitor] Nachrichten auf der netlink-Schnittstelle des Kernels
  \end{description}

  Der Befehl schließlich gibt die Aktion an, die wir ausführen wollen und wird
  gegebenenfalls von passenden Argumenten gefolgt. Befehl und Argumente sind
  spezifisch für die entsprechenden Objekte.
\end{normaltext}

  \subsection*{ss}

  Das Programm ss (socket statistics) liefert Informationen und Statistiken zu
  Sockets. Ähnliche Informationen kann ich zum Beispiel auch mit netstat
  bekommen, jedoch habe ich bei ss mehr Möglichkeiten zur Filterung, was mir
  insbesondere bei Servern mit vielen Verbindungen zugute kommt.

  Der Aufruf ist wie folgt:
  \begin{verbatim}
  ss [ Optionen ] [ Filter ]
  \end{verbatim}

  Debei zeigt ss ohne Optionen die verbundenen TCP-Sockets an.

  Die wichtigsten Optionen sind unter anderen:
  \begin{description}
    \item[-a] um alle Sockets anzuzeigen
    \item[-l] um nur die Listening Sockets anzuzeigen (diese werden per
      Default ausgelassen)
    \item[-p] um die zugehörigen Prozesse anzuzeigen (dafür benötige ich
      Rootrechte)
    \item[-t | -u | -w | -x] um TCP-, UDP-, Raw- oder Unix-Sockets auszuwählen
  \end{description}

  Der Filter beim Aufruf von ss hat die allgemeine Form:
  \begin{verbatim}
  [ TCP-Status ] [ Ausdruck ]
  \end{verbatim}

  Um nach TCP-Status zu filtern, gebe ich das Schlüsselwort \verb?state? oder
  \verb?exclude? gefolgt von einem der Standard-TCP-Zustandsnamen oder einem
  der folgenden an:
  \begin{description}
    \item[all] für alle Zustände
    \item[bucket] für TCP-Minisockets (TIME-WAIT|SYN-RECV)
    \item[big] für alle außer den Minisockets
    \item[connected] für alle nicht geschlossenen und nicht lauschenden
      Sockets
    \item[synchronized] für alle verbundenen Sockets, die nicht im Zustand
      SYN-SENT sind
  \end{description}

  Falls weder ein \verb?state? noch ein \verb?exclude? Statement vorhanden
  ist, ist die Voreinstellung \verb?all? bei Option \verb?-a? und ansonsten
  alle außer \verb?listening?, \verb?syn-recv?, \verb?time-wait? und
  \verb?closed?.

  Mit dem (booleschen) Ausdruck kann ich nach Adressen und Ports filtern.

  Weitere Optionen und ausführlichere Informationen zur Filterung gibt es in
  der Handbuchseite und im Artikel ``SS Utility: Quick Intro'', der sich bei
  der Dokumentation des iproute-Pakets befindet.

  \subsection*{tc}

  Mit dem Programm tc (traffic control) kann ich die Einstellungen zur
  Verkehrssteuerung des Kernels ansehen und manipulieren.

  Dabei gilt es drei Arten von Objekten zu unterscheiden:
  \begin{description}
    \item[QDISC] (queueing discipline) beschreiben das
      Warteschlangenverhalten, das heißt, wie und in welcher Reihenfolge
      Datenpakete, die in eine QDISC eingereiht wurden, an den Treiber der
      Netzwerkkarte zum Senden übergeben werden. Wenn ein Datenpaket gesendet
      werden soll, wird es in die für das Interface konfigurierte QDISC
      eingereiht. Unmittelbar danach versucht der Kernel, so viele Pakete wie
      möglich an den Netzwerkadapter zu übergeben.
    \item[CLASS] (Klassen) können in QDISC enthalten sein und wiederum weitere
      QDISC enthalten. Datenpakete werden in den inneren QDISC eingereiht.
      Datenpakete, die an den Netzwerkadapter übergeben werden, können
      von jeder inneren QDISC kommen. Dadurch, dass bestimmte Klassen vor
      anderen drankommen, kann der Datenverkehr priorisiert werden.
    \item[FILTER] entscheiden, welcher Klasse ein Datenpaket bei einem
      klassenbasierten QDISC zugeordnet wird. Alle Filter einer Klasse werden
      aufgerufen, bis einer eine Entscheidung trifft.
  \end{description}

  \subsubsection*{Klassenlose QDISC}
  Die folgenden Klassenlosen QDISC stehen zur Verfügung:
  \begin{description}
    \item[fifo] ist die einfachste Form (First In, First Out). Die QDISC
      kann auf Paketebene (pfifo) oder Byteebene (bfifo) begrenzt werden.
    \item[pfifo\_fast] ist die Standard-QDISC für Advanced Router Kernel. Diese
      enthält eine dreireihige Warteschlange, die das TOS-Feld und die
      Priorität des Datenpakets beachten.
    \item[red] (Random Early Detection) simuliert eine überlastete Leitung,
      indem zufällig Datenpakete verworfen werden, wenn sich der Durchsatz der
      konfigurierten Bandbreite nähert.
    \item[sfq] (Stochastic Fairness Queueing) sortiert die wartenden
      Datenpakete um, so dass jede Sitzung reihum dran ist.
    \item[tbf] (Token Bucket Filter) ist geeignet, um den Traffic zu eineer
      präzise konfigurierten Bandbreite zu verlangsamen.
  \end{description}

  Klassenlose QDISC müssen an der Wurzel installiert werden:
  \begin{verbatim}
tc qdisc add dev $device root $disc $params
  \end{verbatim}

  \subsubsection*{Klassenbasierte QDISC}
  Die folgenden klassenbasierten QDISC stehen zur Verfügung:
  \begin{description}
    \item[cbq] (Class Based Queueing) bildet eine Hierarchie von Klassen, die
      sich einen Link teilen und kann sowohl priorisieren als auch den
      Durchsatz begrenzen.
    \item[htb] (Hierarchy Token Buffer) ermöglicht garantierte Bandbreiten für
      Klassen und erlaubt die Ausgabe von oberen Grenzen für das Teilen von
      Bandbreite zwischen Klassen. Es enthält begrenzende Elemente auf Basis
      von TBF und kann Klassen priorisieren.
    \item[prio] wird für Priorisierung ohne Begrenzung der Bandbreite
      verwendet.
  \end{description}

  \subsubsection*{Theorie}
  Die Klassen formen einen Baum, bei dem jede Klasse genau einen Vorfahren hat
  und mehrere Kinder haben kann.

  Manche QDISC erlauben zur Laufzeit Klassen hinzuzufügen (CBQ, HTB), andere
  nicht (PRIO). Erstere können beliebig viele (auch keine) Subklassen haben,
  in denen die Datenpakete einsortiert werden.

  Jede Klasse enthält genau ein Blatt-QDISC (per Default pfifo), welcher durch
  ein anderes ersetzt werden kann. Diese QDISC kann wiederum andere Klasse
  enthalten, die zunächst auch nur ein QDISC haben.

  Wenn ein Datenpaket in einer klassenbasierten QDISC ankommt, wird es genau
  einer der enthaltenen Klassen zugeordnet. Sind Filter für eine Klasse
  definiert, werden diese zuerst für die Klassifizierung herangezogen. Einige
  QDISC werten auch das TOS-Feld des IP-Headers aus.

  Jeder Knoten im Klassenbaum kann seine eigenen Filter haben. Filter in
  höheren Ebenen können direkt auf niedrigere Klassen verweisen.

  Wenn ein Paket nicht klassifiziert werden konnte, geht es in die
  Blatt-QDISC der Klasse.

  \subsubsection*{Namen}
  Alle QDISC, Klassen und Filter haben Ids, die automatisch bestimmt oder
  explizit spezifiziert werden. Diese Ids bestehen aus einer Haupt- und einer
  Nebennummer, getrennt durch Doppelpunkt.

  Ein QDISC, welche potentiell Kinder haben kann, bekommt eine Hauptnummer,
  die 'Handle' genannt wird und lässt die Nebennummer als Namensraum für die
  Klassen. Üblicherweise benennt man QDISC, die Kinder haben, explizit.

  Alle Klassen, die zur selben QDISC gehören, teilen sich die gleiche
  Hauptnummeer. Jede hat eine separate Nebennummer, die Class-Id genann wird
  un sich auf die QDISC (nicht die Elternklasse bezieht).

  Filter haben eine dreiteilige Filter-Id, die nur bei einer Filter-Hierarchie
  benötigt werden.

  \subsubsection*{tc Befehle}
  \begin{description}
    \item[add] Fügt eine QDISC, Klasse oder einen Filter an. Der Vorfahre
      (root oder Class-Id) muss angegeben werden. QDISC oder Filter können mit
      dem \verb?handle? Parameter benannt werden, Klassen mit \verb?classid?.
    \item[remove] entfernt eine QDISK
    \item[change] modifiziert eine Einheit am Orte
    \item[replace] gleichzeitiges \verb?remove? / \verb?add?, der neue Knoten
      wird gegebenenfalls neu erzeugt
    \item[link] gleichzeitiges \verb?remove? / \verb?add?, der neue Knoten
      muss bereits existieren.
  \end{description}

  Weitere Informationen finden sich in der Handbuchseite von \verb?tc?.
  \subsection*{lnstat / nstat / rtacct}
  Diese Programme liefern Netzwerkstatistiken. Nähere Informationen siehe
  Handbuchseiten.

  \subsection*{rtmon}
  Mit dem Programm rtmon kann ich Änderungen an der Routingtabelle des Kernels
  über den \verb?netlink? Socket beobachten. Das Programm kann vor der ersten
  Netzwerkkonfiguration, zum Beispiel in einem Init-Script, gestartet werden.

  Rtmon schreibt in eine Datei und stellt der Historie der Routingtabelle
  einen Schnappschuss des Zustandes beim Start des Programms voran. Die Datei
  kann ich mit dem bereits besprochenen Programm ip auswerten.

  Der typische Aufruf sieht in etwa so aus:
  \begin{verbatim}
  # rtmon file /var/log/rtmon.log
  \end{verbatim}
  Anschließend kann ich die protokollierten Änderungen wie folgt ausgeben
  lassen:
  \begin{verbatim}
  # ip monitor file /var/log/rtmon.log
  \end{verbatim}

  Sowohl beim Aufruf von rtmon, als auch bei dem von ip kann ich angeben, an
  welchen Objekten ich interessiert bin:
  \begin{description}
    \item[link], den Netzwerkgeräten
    \item[address], den Protokolladressen (IPv4, IPv6) an einem Gerät
    \item[route], den Einträgen der Routingtabelle
    \item[all], an allem
  \end{description}

  Weitere Informationen finden sich auch hier in der Handbuchseite.
\section{netstat}
\label{sec:netz-werkzeuge-netstat}
\begin{abstractsec}
  Mit netstat ist es möglich essentielle Informationen zur
  Netzwerkkonfiguration und zum aktuellen Zustand der Netzwerksockets und
  Verbindungen eines Rechners zu erfahren.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, dass ich auch bei der Analyse von lokalen Rechnerproblemen
  einsetze und dort bereits vorgestellt habe, ist netstat. Im Bereich
  Netzwerkprobleme kann es viele Informationen liefern, die mir, je nach
  Problemfall weiterhelfen können.

  \subsection*{Sockets}
  \label{sec:netz-werkzeuge-netstat-sockets}

  Rufe ich \verb?netstat? ohne Argumente auf, liefert es mir eine Liste der
  offenen und aktiven Sockets aller konfigurierten Adressfamilien, das
  heisst, der bestehenden Verbindungen.

  Meist interessieren mich nicht alle Adressfamilien, sondern nur ganz
  bestimmte. Dann kann ich diese zum Beispiel mit der Option
  \verb?--protocol=$familie? einschränken. Für \verb?$familie? kan ich in
  einer kommaseparierten Liste die folgenden angeben: \verb?unix?,
  \verb?inet?, \verb?ipx?, \verb?ax25?, \verb?netrom?, \verb?ddp?. Alternativ
  kann ich jeden gewünschten Familiennamen einzeln als Option übergeben:
  \verb?--unix?, \verb?--inet?, \ldots

  In diesem Teil der Buches interessiert mich vor allem die Familie
  \verb?--inet?. Diese kann ich weiter eingrenzen. Mit der Option \verb?-4?
  beziehungsweise \verb?-6? beschränke ich die Ausgabe auf die entsprechende
  Version des Internet Protokolls.

  Außerdem verwende ich
  \begin{description}
    \item[--raw oder -w] wenn ich an Raw-Sockets interessiert bin,
    \item[--tcp oder -t] für TCP-Sockets, und
    \item[--udp oder -u] für UDP-Sockets.
  \end{description}

  Bin ich nur daran interessiert, ob überhaupt ein Prozess an einem bestimmten
  Socket wartet, verwende ich die Option \verb?--listening? beziehungsweise
  \verb?-l?. Diese werden bei der normalen Ausgabe weggelassen. Will ich
  hingegen sowohl die aktiven als auch die lauschenden Sockets erfassen,
  verwende ich die Option \verb?--all? beziehungsweise \verb?-a?.

  \subsection*{Routen}
  \label{sec:netz-werkzeuge-netstat-routen}

  Wenn ich statt an den Sockets eher an den Routen interessiert bin, verwende
  ich die Option \verb?--routes? beziehungsweise \verb?-r?. Damit bekomme ich
  die gleiche Ausgabe, wei mit dem Befehl \verb?route -e?. Auch hier kann ich
  mit \verb?-4? oder \verb?-6? die Protokollversion einschränken.

  Füge ich die Option \verb?-C? hinzu, bekomme ich Informationen aus dem
  Routencache, mit der Option \verb?-F? stattdessen aus der Forwarding
  Information Base (der Routentabelle), aber das ist sowieso die
  Voreinstellung.

  \subsection*{Interfaces}
  \label{sec:netz-werkzeuge-netstat-interfaces}

  Mit der Option \verb?--interfaces? oder \verb?-i? kann ich Informationen
  über die Netzwerk-Interfaces bekommen.

  Ein einfaches \verb?netstat -i? liefert mir in einer übersichtlichen Tabelle
  zu jedem aktiven Interface unter anderem die MTU, die Anzahl der gesendeten
  und empfangenen Datenpakete sowie die Anzahl der Sende- beziehungweise
  Empfangsfehler.

  Kombiniere ich das mit \verb?-e?, bekomme ich die gleiche Ausgabe wie vom
  Program \verb?ifconfig?. Kombiniert mit \verb?-a? werden auch Interfaces
  angezeigt, die nicht im Zustand \verb?UP? sind.

  \subsection*{Multicast-Gruppen}
  \label{sec:netz-werkzeuge-netstat-groups}
  Die Option \verb?--groups? beziehungsweise \verb?-g? liefert mir
  Informationen zur Mitgliedschaft des Rechners in Multicast-Gruppen.

  Auch diese kann ich mit \verb?-4? oder \verb?-6? einschränken.

  \subsection*{Statistiken}
  \label{sec:netz-werkzeuge-netstat-statistics}

  Mit der Option \verb?--statistics? beziehungsweise \verb?-s? zeigt netstat
  zusammengefasste Statistiken für alle Protokolle.

  \subsection*{allgemeine Optionen}
  \label{sec:netz-werkzeuge-netstat-allgemein}

  Abschließen möchte ich diese kleine Vorstellung von netstat mit ein paar
  allgemeinen Optionen, mit denen ich die Ausgabe modifizieren kann.

  Die von mir wohl am meisten eingesetzte Option ist \verb?--numeric?, kurz
  \verb?-n?. Mit dieser Option zeigt netstat numerische statt symbolischer
  Informationen an und das ist insbesondere bei Netzwerkadressen ein immenser
  Geschwindigkeitsvorteil, da sonst unter Umständen etliche DNS-Anfragen mit
  den entsprechenden Verzögerungen gestellt werden, bevor die Ausgabe
  angezeigt werden kann. Natürlich kann man das auch selektiv einstellen mit
  \verb?--numeric-hosts?, \verb?--numeric-ports? und \verb?--numeric-users?.

  Mit der Option \verb?--verbose? oder \verb?-v? kann ich mehr Informationen
  bekommen, insbesondere zu nicht konfigurierten Adressfamilien.

  Ähnliches bietet die Option \verb?--extend? oder \verb?-e?, die zusätzliche
  Informationen zum Beispiel bei Interfaces liefert.

  Gebe ich die Option \verb?--continuos? oder \verb?-c? an, bekomme ich die
  Informationen aller Sekunde ausgegeben.
\end{normaltext}


\section{route}
\label{sec:netz-werkzeuge-route}
\begin{abstractsec}
  Das Programm route ist für die Anzeige und Manipulation von Routingeinträgen
  zuständig.
\end{abstractsec}
\begin{normaltext}
  Das Programm \verb?route? ist für die Anzeige und Manipulation von
  Routingeinträgen zuständig.
  
  Da die gleiche Funktionialität mit dem Befehl \verb?ip route? und
  entsprechenden Optionen erreicht werden kann, gehe ich hier nicht näher auf
  das \verb?route? ein. Falls das Paket iproute2 auf einen Rechner nicht
  installiert ist, verweise ich auf die Handbuchseite.
\end{normaltext}
\section{ethtool, mii-diag, mii-tools}
\label{sec:netz-werkzeuge-ethtool}
\begin{abstractsec}
  Mit den Programmen ethtool, mii-diag beziehungsweise mii-tool kann ich die
  Konfiguration der Ethernetschnittstellen anzeigen und manipulieren,
  zumindest bei modernen Schnittstellen.
\end{abstractsec}
\begin{normaltext}
  Mit den Programmen ethtool, mii-diag beziehungsweise mii-tool kann ich die
  Konfiguration der Ethernetschnittstellen anzeigen und manipulieren,
  zumindest bei modernen Schnittstellen.

  Dazu verwenden diese Programme meist das Media Independend Interface (MII),
  von dem sich auch der Name ableitet.

  Welches Programm installiert ist, hängt von der verwendeten
  Linux-Distribution ab. Ob man es überhaupt verenden kann, hängt auch von der
  verwendeten Ethernetkarte ab. Moderne Ethernetkarten und die
  Onboardschnittstellen neuerer Rechner funktionieren üblicherweise gut mit
  diesen Programmen.

  Unter anderem kann man mit diesen Programmen
  \begin{itemize}
    \item die Ethernet-Geschwindigkeit, das Duplexverhalten und das Aushandeln
      der Parameter mit dem Switch beziehungsweise der angeschlossenen
      Gegenstelle einstellen oder abfragen
    \item die Wake-On-Lan-Konfiguration bearbeiten
    \item Selbsttests anstoßen
  \end{itemize}

  Gerade die Möglichkeit, Fehlanpassungen in der Geschwindigkeit oder beim
  Duplexverhalten zu erkennen, kann sich als sehr wertvoll bei der Diagnose
  von Performanceproblemen erweisen.

  Bei einer LWL-Verbindung über mehrere Kilometer hatten wir ernste
  Performanceprobleme, bei denen die Transferrate in ener Richtung auf wenige
  KB/s beim beidseitigen Lasttest herunterging. Der erste Gedanke war eine
  schlechte Faser, da das Problem nur in einer Richtung auftrat. Mit den
  mii-tools konnten wir eine Fehlanpassung der Ethernetkarte mit dem
  Medienwandler diagnostizieren. Nachdem wir die Schnittstelle auf Full-Duplex
  eingestellt hatten, blieb die verfügbare Bandbreite auch bei Volllast in
  beiden Richtungen im erwarteten Rahmen.
\end{normaltext}

\section{ping}
\label{sec:netz-werkzeuge-ping}
\begin{abstractsec}
  Eines der grundlegenden und vielseitigsten Werkzeuge für das
  Netzwerk-Troubleshooting ist ping. Mit diesem Programm kann ich die
  Erreichbarkeit einer Maschine testen, die Paketlaufzeit sehen, die
  Bandbreite einer Verbindung ermitteln, die Performance meines Rechners und
  des Netzwerkes abschätzen, Netzlast für bestimmte Tests erzeugen.
\end{abstractsec}
\begin{normaltext}
  Eines der grundlegenden und vielseitigsten Werkzeuge für das
  Netzwerk-Troubleshooting ist Ping. Mit diesem Programm kann ich:
  \begin{itemize}
    \item testen, ob eine Maschine überhaupt erreichbar ist,
    \item sehen, wie lange ein Paketaustausch dauert,
    \item analysieren, welche Bandbreite die Verbindung zu einem Rechner hat,
    \item die Performance meines Rechners und Netzwerkes einschätzen,
    \item eine hohe Netzlast für andere Tests erzeugen.
  \end{itemize}

  Natürlich sind alle mit Ping gewonnen Erkenntnisse mit einer Prise Salz zu
  nehmen, aber das trifft schließlich auf jedes Werkzeug zu.

  In \cite{sloan2001} sind die Anwendungen von Ping beim
  Netzwerk-Troubleshooting sehr gut und ausführlich beschrieben.

  Die wichtigsten Kommandozeilenoptionen von \verb?ping? sind:
  \begin{description}
    \item[-c count] um die Anzahl der gesendeten Datenpakete zu begrenzen,
    \item[-i interval] um den zeitlichen Abstand in Sekunden zwischen den
      einzelnen Paketen vorzugeben (Voreinstellung ist eine Sekunde)
    \item[-s size] um die Größe der Datenpakete in Bytes vorzugeben
      (Voreinstellung ist 56, hinzu kommen immer noch 8 Byte für den
      ICMP-Header)
    \item[-n] um die Auflösung von Hostnamen abzuschalten
    \item[-q] um die Ausgabe der einzelnen Zeiten abzuschalten (die
      Statistikinformationen am Ende werden trotzdem ausgegeben)
    \item[-f] um die Ping-Pakete mit maximaler Geschwindigkeit zu senden und
      dadurch eine möglichst hohe Netzlast zu erzeugen (diese Option sowie die
      Option \verb?-i? mit Zeiten unter 0,2 Sekunden benötigen
      Superuserrechte)
  \end{description}
  Daneben gibt es sehr viele weitere Optionen, die seltener benötigt werden
  und deren genaue Auswirkungen aus den Handbuchseiten erschlossen werden
  können.

  \subsection{Verbindungstest}
  Das ist der einfachste Test, den ich mit Ping ausführen kann. Ich gebe
  \begin{verbatim}
$ ping rechnername
  \end{verbatim}
  ein und bekomme heraus, ob die betreffende Maschine erreichbar ist. Das
  heißt, ob Antwortpakete von dort zurück kommen. Ältere Versionen des
  Programms begnügten sich auch schon mit der Ausgabe:\
  \begin{verbatim}
rechnername is alive
  \end{verbatim}
  Moderne Versionen zeigen nach Beendigung des Programms (nötigenfalls durch
  Abbruch mit \verb?<CTRL>-C?) die Paketlaufzeiten und einige Statistiken an.

  Ein Problem, das das Testen der Verbindung mit Ping verhindern kan, sind zu
  restriktive Firewalleinstellungen. Bei etlichen Rechnern habe ich erlebt,
  dass diese nach der Installation zwar am Netzverkehr teilnehmen konnten,
  aber selbst nicht auf ICMP-Hello-Pakete (Ping) antworteten. Das ist, aus
  meiner Sicht, eine Überreaktion auf die Tatsache, das einige DoS-Angriffe
  das ICMP-Protokoll und insbesondere ICMP-Hello (Ping) verwendet haben. Man
  kann schlecht jedem vorschreiben, was er in seinem Netzwerk erlaubt und was
  nicht. Auf jeden Fall möchte ich jeden bitten, sachlich einen möglichen oder
  eingebildeten Gewinn an Sicherheit gegenüber der Erschwernis der
  Netzwerkdiagnose abzuwägen.

  \subsection{Netzwerkperformancemessungen}
  Ein weiteres Anwendungsgebiet sind Performancemessungen im Netzwerk. Am
  einfachsten geht die Bestimmung der Paketlaufzeit zu einem entfernten
  Rechner und zurück, denn diese gibt Ping selbst aus. Bin ich an der reinen
  Laufzeit interessiert, muss ich mir einen Zeitpunkt suchen, zu dem sehr
  wenig im Netz los ist. Aber auch die Bandbreite kann ich mit Ping bestimmen
  sowie Netzwerklast für Lastmessungen erzeugen.

  \subsection{Probleme mit Ping}
  Ein paar Sachen gibt es zu beachten, wenn ich Ping beim Troubleshooting
  verwende.

  Zunächst arbeitet Ping nicht im luftleeren Raum, snondern hängt vom
  Funktionieren anderer Netzwerkelemente ab. Arbeite ich mit Hostnamen statt
  IP-Adressen, dann muss DNS fuktionieren, oder die Namen via /etc/hosts
  auflösbar sein.

  Dann muss die Ethernet-Adresse des Zielrechners oder Routers aufgelöst
  werden können. Dazu muss ich sicherstellen, dass das ARP-Protokoll
  funktioniert oder statische ARP-Einträge verwenden (und zwar auf beiden
  Seiten). Üblicherweise wird die erste RTT bei einer Messung mit Ping durch
  das ARP-Protokoll verfälscht. Diesem Problem kann ich begegnen, indem ich
  grundsätzlich mehrere Ping-Pakete sende und die erste Zeit ignoriere.

  Bei der Bestimmung der Bandbreite eines Links verwende ich ohnehin die
  niedrigste Zeit, da ist dieses Problem bereits berücksichtigt. Ich muss
  lediglich daran denken, immer mehrere gleichartige Ping-Pakete zu senden.

  Ein weiteres mögliches Problem ist, das das korrekte Funktionieren des
  Netzwerkes von Faktoren abhängen kann, die Ping nicht beeinflussen. So kann
  zum Beispiel ein kleines Ping-Paket problemlos hindurch gelangen, während
  größere Datenpakete der Anwendungsprotokolle verworfen werden.

  Andererseits kann ICMP administrativ geblockt sein, während
  Anwendungsprotokolle von der Firewall durchgelassen werden, was zu einem
  False Negative führen kann. Gerade diese Konstellation trifft man häufig in
  Netzen, die von paranoiden Administratoren konfiguriert werden oder in
  solchen, deren Administration die Auswirkungen der betreffenden Sperren
  nicht in vollem Maße abschätzen können. Trotzdem halte ich es für sinnvoll,
  die Argumente für und wieder diese Sperren im Einzelfall zu klären und zu
  dokumentieren, damit es an dieser Stelle nicht immer wieder zu Diskussionen
  kommt, weil die Sicherheitseinstellungen das Troubleshooting erschweren. Für
  eine entsprechende Argumentation ist es notwendig, die möglichen
  Sicherheitsprobleme und gegebenenfalls alternative Gegenmaßnahmen genau zu
  kennen.

  Mögliche Argumente für ein Sperren von ICMP sind:
  \begin{description}
    \item[Smurf Attacks] Ein ICMP-Paket mit gefälschter Absenderadresse wird
      an die Broadcast-Adresse eines Netzes gesendet. Der Rechner, dem die
      gefälschte Absenderadresse gehört, bekommt von allen Rechnern des
      Netzsegments eine Antwort.
      Zur Abhilfe kann man Pakete an Netz-Broadcast-Adressen am Router
      ausfiltern. Damit schränkt man diesen Angriff auf das lokale Netz ein.
      In diesem sollte es relativ einfach möglich sein, den Verursacher zu
      ermitteln.
    \item[Ping of Death] Es gibt (ältere) Betriebssysteme, die mit übergroßen
      ICMP-Paketen nicht umgehen können und damit außer Betrieb genommen
      werden können. Dieses Problem sollte mit allen aktuellen
      Betriebssystemen behoben sein.
    \item[Auskundschaften des Netzes] Mit ICMP ist es möglich, die Adressen
      der Rechner in einem IPv4-Netz zu ermitteln. Hier ist zu bedenken, ob
      das wirklich ein Problem darstellt.
    \item[Unerwünschter Traffic] Durch ICMP (insbesondere Floodping) kann
      unnötiger unerwünschter Traffic erzeugt werden, der legitimen
      Datenverkehr behindert. Hier kann man das Problem, soweit es geht mit
      Rate-Limiting am Router eindämmen.
  \end{description}

  Wenn Ping nicht komplett blockiert wird, ist immerhin noch möglich, dass das
  Protokoll eine sehr niedrige Priorität am Router bekommt und allein dadurch,
  insbesondere bei gut ausgelateten Routern unter den Tisch fällt oder
  zumindest die RTT stark verfälscht wird.

  Bei manchen Routern kann es vorkommen, dass im Fall von NAT die
  ICMP-Echo-Antwort nicht zum anfragenden Host zurückgeschickt wird.

  Interessanterweise kann man trotz unterdrücktem ICMP zumindest im lokalen
  Netzsegment herausbekommen, ob eine bestimmte IP-Adresse verwendet wird.
  Dazu löscht man den ARP-Cache und schickt dann ein Ping-Paket zur
  entsprechenden Adresse. Ist danach ein korrekter ARP-Eintrag vorhanden, ist
  der Host angeschlossen und unterdrückt das ICMP-Echo.

  Eines muss man bei Ping-Tests immer im Hinterkopf behalten: Ping testet nur
  die Erreichbarkeit einer bestimmten IP-Adresse. Ob die angebotenen Dienste
  funktionieren und ob überhaupt der richtige Rechner diese Adresse verwendet,
  muss ich auf anderem Wege herausbekommen.
  \begin{notes}
  \item Kann Ping ohne funktionierendes Routing funktionieren?
  \end{notes}
\end{normaltext}

\section{traceroute}
\label{sec:netz-werkzeuge-traceroute}
\begin{abstractsec}
  Traceroute ist ein Werkzeug zur Untersuchung des Netzwerkpfades zu einer
  IP-Adresse.
\end{abstractsec}
\begin{normaltext}
  Traceroute ist ein Werkzeug zur Untersuchung des Netzwerkpfades zu einer
  IP-Adresse.

  Bei Problemen mit der Erreichbarkeit eines Rechners oder Netzwerkes kann ich
  es unter Umständen dazu verwenden, das letzte erreichbare Netzsegment zu
  bestimmen und dann meine nächsten Schritte auf dieses zu fokussieren. Bei
  manchen Problemen kann es auch bereits einen Hinweis auf die Art des
  Problems geben. Zum Beispiel können in der Ausgabe mehrfach auftretende
  IP-Adressen auf eine Routingschleife hin deuten.

  Die grundlegende Arbeitsweise von traceroute ist, Datenpakete zum
  Zielrechner zu senden, deren IP-time-to-live-Feld mit 0 beginnt und
  sukzessive erhöht wird, bis der Zielhost erreicht ist. Wenn ein Host oder
  Router ein Datenpaket mit einer TTL von 0 erhält, verwirft er das Datenpaket
  und schickt an den Absender eine ICMP-Nachricht, dass die TTL abgelaufen
  war. Diese ICMP-Nachricht enthält die ersten Bytes des verworfenen
  Datenpaketes, damit der Empfänger die ICMP-Nachricht dem gesendeten
  Datenpaket zuordnen kann.

  In der ursprünglichen Variante sendet traceroute UDP-Pakete ab einer
  bestimmten Portnummer und erhöht beim Senden nicht nur die TTL, sondern
  gleichzeitig auch die Portnummer. Dadurch ist es einfach, die zuückkehrenden
  ICMP-Nachrichten über den Port den richtigen TTL zuzuordnen. Damit ist es
  möglich mehrere Datenpakete mit verschiedenen TTL und Port quasi-parallel zu
  versenden und die Messzeit zu verkürzen.

  Wenn eine UDP-Nachricht am Zielhost angekommen ist, sendet dieser keine
  ICMP-ttl-exceeded-Nachricht, sondern stattdessen ICMP-port-unreachable, wenn
  an dem betreffenden Port kein Prozess lauscht. Darum ist es wichtig für
  traceroute via UDP einen Bereich zu verwenden, in dem auf dem Zielhost kein
  UDP-Port in Verwendung ist. Zwar kann der Zielhost auch an der IP-Adresse
  erkannt werden, aber gerade bei multihomed Hosts oder Routern kann das
  Datenpaket an einem anderen Interface ankommen und damit die ICMP-Antwort
  eine andere IP-Adresse.

  Da Firewalleinstellungen in Netzwerken immer restriktiver werden, gibt es
  einige Varianten von traceroute, die auch andere Protokolle verwenden und
  mit einem Port auf dem Zielrechner auskommen. So ist es möglich, traceroute
  mit ICMP-echo-Paketen (Ping), TCP-Paketen (zum Beispiel Port 25 oder 80)
  oder mit nur einem UDP-Port (zum Beispiel 53 oder 123) zu verwenden, wenn
  die Firewall für eines dieser Protokolle freigegeben ist.

  Zusätzlich zur IP-Adresse der Hops auf dem Weg zum Zielrechner zeigt
  traceroute of noch die RTT zwischen gesendetm Datenpaket und ICMP-Antwort
  an, aus der ich Rückschlüsse auf Art und Zustand des betreffenden
  Netzsegmentes ziehen kann.

  Auch bei traceroute, wie bei allen Werkzeugen, muss ich bei der
  Interpretation der Ergebnisse einige Sachen berücksichtigen.

  So zeigt zum Beispiel die Reihenfolge der Hops nur, wie die Daten in einer
  Richtung zum Zeitpunkt der Messung gelaufen sind. Bei Änderungen im Routing
  kann sich der Weg bereits während der Messung ändern. Und der Rückweg kann
  ganz anders aussehen, wenn das Routing asymmetrisch ist.

  Einige IP-Stacks senden ICMP-unreachable-Nachrichten mit einer TTL, die
  gleich der ist, mit der das Datenpaket ankam. Diese Host erscheinen dann
  (bei symmetrischem Routing) erst bei der doppelten TTL, also viel weiter weg
  als sie in Wirklichkeit sind.

  Wenn auf dem Weg der Daten zum Zielhost eine Adressumsetzung (NAT) erfolgt,
  dann gehen die ICMP-Nachrichten nach der NAT an die umgesetzte Adresse und
  erreichen möglicherweise nicht den Rechner, auf dem ich traceroute gestartet
  habe.

  Schließlich ist es möglich, dass eine sehr restriktive Firewall die
  Traceroute-Pakete einfach stillschweigend verwirft. In diesem Fall kann es
  sinnvoll sein, traceroute mit anderen Protokollen zu wiederholen und die
  Ergebnisse zu vergleichen.

  Abgesehen von diesen Problemen ist es möglich, mit traceroute eine
  hinreichend genaue Karte der erreichbaren Netze zu erstellen.

  Da es etliche Implementierungen von traceroute gibt, deren
  Kommandozeilenoptionen zum Teil erheblich voneinander abweichen, verweise
  ich auf die Dokumentation des auf dem Rechner installierten Programmes.
\end{normaltext}

\section{tcpdump}
\label{sec:netz-werkzeuge-tcpdump}
\begin{abstractsec}
  Bei besonders schwierigen Netzwerkproblemen verwende ich tcpdump zum
  Mitschreiben des Datenverkehrs im Netz.
\end{abstractsec}
\begin{normaltext}
  Bei besonders schwierigen Netzwerkproblemen verwende ich - quasi als große
  Kanone - tcpdump zum Mitschreiben des Datenverkehrs im Netz. Dabei setze ich
  tcpdump vorzugsweise auf Servern, die keine grafische Benutzeroberfläche
  haben, oder auf Routern/Bridges mit Linux oder BSD als Betriebssystem.

  Ich verwende tcpdump dann
  \begin{itemize}
    \item um das Verhalten andere Werkzeuge zu kontrollieren und zu
      verifizieren. Erhalte ich zum Beispiel via Ping keine Antwort von einer
      bestimmten IP-Adresse, sehe ich mit tcpdump nach, ob mein Rechner die
      ICMP-Anfragen überhaupt absendet. Sehe ich dann mit tcpdump die Antwort
      ebenfalls ankommen, kann ich auf die Firewallregeln auf meinem Rechner
      als Verursacher schließen.
    \item um das Vorkommen bestimmter Datenpakete zu verifizieren. Zum einen
      überhaupt, wie im Beispiel mit Ping und zum anderen an verschiedenen
      Stellen im Netz, um durch Bisektion die Stelle im Netz zu finden, an der
      der Datenfluß unterbrochen wird.
    \item um Protokollverhalten zu verifizieren und/oder Protokollfehler
      nachzuweisen. Das erfordert seinerseits widerum umfangreiche Kenntnisse
      der untersuchten Protokolle, die sich in vielen Fällen durch Studium der
      relevanten RFCs erlangen lassen.
    \item um Datenmitschnitte für die Auswertung mit Wireshark zu sammeln.
      Zwar habe ich in Wireshark auch nur die selben Daten zur Verfügung wie
      in tcpdump, aber bereits die Statistikfunktionen können mir Hinweise auf
      Netzprobleme geben, die ich mit tcpdump gar nicht wahrgenommen hätte.
      Abgesehen davon ist die Darstellung der einzelnen Protokollschichten bei
      Wireshark einfach anschaulicher.
  \end{itemize}

  Nach dem ich nun geklärt habe, wofür ich tcpdump im Allgemeinen einsetze,
  komme ich nun dazu, was ich damit konkret machen kann und wie ich das mache.

  Die häufigste Anwendung ist das Mitschneiden von Datenverkehr. Dazu benötige
  ich Superuserrechte. Je nachdem, wie viele Schnittstellen mein Rechner hat,
  muss ich diese noch angeben. Prinzipiell schalte ich die Namensauflösung ab,
  wenn ich mir die Datenpakete anzeigen lasse, um Verzögerungen durch
  DNS-Anfragen zu vermeiden.

  Will ich die mitgeschnittenen Daten nicht sofort auswerten, kann ich diese
  auch in eine Datei schreiben lassen, die ich dann später mit tcpdump oder
  wireshark auswerte. Für die Auswertung der Datei benötige ich keine
  Superuserrechte sondern nur Leserechte auf die Datei.

  Will ich über einen längeren Zeitraum Datenpakete mitschneiden und in
  Dateien archivieren, kann ich tcpdump anweisen, bei Erreichen einer
  bestimmten Dateigröße oder alternativ periodisch nach einer bestimmten Zeit
  mit einer neuen Datei zu beginnen.

  Manche IPSEC-Verbindungen kann tcpdump dekodieren, wenn ich den Schlüssel
  angebe.

  Bin ich nur an den Kopfdaten und nicht an den Anwendungsdaten interessiert,
  kann ich die maximale pro Datenpaket mitgeschnittene Länge vorgeben. Damit
  erhöht sich gleichzeitig die Verarbeitungsgeschwindigkeit, wenn ich die
  Datei in eine Datei schreibe.

  \subsection{Kommandozeilenoptionen}

  Die Optionen, die ich am häufigsten verwende, sind:
  \begin{description}
    \item[-n] um die Namensauflösung abzuschalten. Diese Option benötige ich
      nicht, wenn ich den Mitschnitt lediglich in eine Datei schreibe.
    \item[-l] um die Daten gleich während des Mitschnitts zu sehen.
      Andernfalls puffert tcpdump die Standardausgabe und zeigt die
      Datenpakete nicht sofort an, wenn sie eingetroffen sind.
    \item[-U] um den Schreibpuffer beim Schreiben in eine Datei nach jedem
      angekommenen Datenpaket zu leeren. Das ist nützlich, wenn ich die
      geschriebene Datei in einem anderen Fenster zur gleichzeitigen
      Auswertung geöffnet habe. Dort verwende ich dann die Option \verb?-l?.
    \item[-w filename] um in eine Datei zu schreiben.
    \item[-r filename] um aus einer Datei zu lesen.
    \item[-i device] um das Interface anzugeben, an dem ich mitschreiben will.
      Ab einem Kernel der Version 2.2 ist es möglich an allen Interfaces
      gleichzeitig mitzuschreiben. Dafür gebe ich als Device \verb?any? an.
    \item[-C filesize] weist tcpdump an, beim Schreiben in eine Datei
      automatisch eine neue Datei zu öffnen, wenn die alte größer als
      \verb?filesize? ist. An den Dateinamen wird eine fortlaufende Nummer
      angehängt.
    \item[-G seconds] um die mit \verb?-w? angegebene Datei nach der
      angegebenen Zeit zu rotieren. Der Name der Datei sollte eine
      Zeitformatangabe für strftime(3) haben, damit sie nicht überschrieben
      wird.
    \item[-F filename] um den Filterausdruck, der sonst am Ende der
      Kommandozeile folgt, aus der angegebenen Datei zu lesen.
    \item[-q] um die ausgegebenen Informationen zu reduzieren, so dass die
      Ausgabezeilen kürzer werden.
    \item[-v] um mehr Informationen pro Datenpaket angezeigt zu bekommen.
      Ich kann mehrere \verb?-v? verwenden, um noch mehr Informationen zu
      bekommen.
    \item[-s snaplen] um die Zahl der Bytes pro Datenpaket, die mitgeschrieben
      werden, zu begrenzen. 0 bedeutet hier keine Begrenzung.
    \item[-W filecount] um die Anzahl der Dateien, die mit \verb?-C? oder
      \verb?-G? automatisch erzeugt werden, zu begrenzen.
    \item[-x]
    \item[-X] um die Header und Daten als Hexadezimal- und ASCII-Werte
      ausgeben zu lassen.
    \item
  \end{description}

  \subsection{Filter}

  Ein wesentlicher Punkt beim Einsatz von tcpdump ist die Möglichkeit, durch
  Filter zu bestimmen, welche Datenpakete mitgeschrieben werden und welche
  nicht. Das macht man mit Filterausdrücken, die einfach am Ende der
  Kommandozeile angefügt werden oder in einer Datei gesammelt und mit der
  Option \verb?-F dateiname? übergeben werden. Detaillierte Informationen zu
  den Filtermöglichkeiten von tcpdump oder libpcap im Allgemeinen finden sich
  in der Handbuchseite \verb?pcap-filter?.
  
  In den meisten Fällen hänge ich
  den Filterausdruck an das Ende der Kommandozeile, weil das schneller geht.
  Nur bei komplizierten Filtern schreibe ich den Filter vor Benutzung in eine
  Datei.

  Ein Filterausdruck besteht aus einem oder mehreren Primitiven, die über die
  Begriffe \verb?and?, \verb?or? oder \verb?not? miteinander kombiniert werden
  können. Ein Primitiv besteht aus einer ID, das ist ein Name oder eine Zahl,
  der ein oder mehrere Qualifizierer vorangestellt werden. Die Qualifizierer
  bestimmen, welche Bedeutung die ID hat. So kann zum Beispiel die ID smtp
  zusammen mit dem Qualifizierer zum einen auf eine Ethernetadresse verweisen
  (\verb?ether host smtp?), auf eine IP-Adresse (\verb?host smtp?), auf den
  TCP-Port 25 (\verb?port smtp?) oder auf etwas anderes.

  Es gibt drei Arten von Qualifizierern, die miteinander kombiniert werden
  können:
  \begin{description}
    \item[Typqualifizierer] geben an, worum es sich bei der ID handelt.
      Mögliche Typen sind \verb?host? (ein einzelner Rechner), \verb?net? (ein
      ganzes Netz, Netznamen können zum Beispiel in /etc/networks definiert
      werden), \verb?port? (ein TCP- oder UDP-Port, Portnamen werden in
      /etc/services definiert) oder \verb?portrange? (ein Portbereich, zwei
      Ports verbunden mit Bindestrich).
    \item[Richtungsqualifizierer] geben die Datenübertragungsrichtung zu oder
      von der ID an. Mögliche Richtungen sind unter anderem \verb?src?,
      \verb?dst?, \verb?src or dst?, \verb?src and dst?, \verb?inbound?,
      \verb?outbound?. Fehlt der Richtungsqualifizierer, wird
      \verb?src or dst? angenommen.
    \item[Protokollqualifizierer] beschränken das Primitiv auf ein bestimmtes
      Protokoll. Das können unter anderem \verb?ether? für Ethernet, \verb?ip?
      für IPv4, \verb?ip6? für IPv6, \verb?arp?, \verb?tcp?, \verb?udp? sein.
      Protokollqualifizierer können noch weiter unterteilt sein, die Details
      entnimmt man im Zweifel der Handbuchseite.
  \end{description}
  Daneben gibt es noch einige spezielle Primitive, wie \verb?gateway?,
  \verb?broadcast?, \verb?less?, \verb?greater? und arithmetische Ausdrücke,
  die man in Filterausdrücken verwenden kann.

  Nachfolgend erläutere ich noch einige Primitive, die ich relativ häufig
  einsetze:
  \begin{description}
    \item[src host h]
    \item[dst host h]
    \item[host h] Entweder die Quelladresse oder die Zieladresse oder
      mindestens eine von beiden gehört zu Host \verb?h?.
    \item[ether src e]
    \item[ether dst e]
    \item[ether host e] Entweder die Ethernet-Quelladresse oder die
      -Zieladresse oder mindestens eine von beiden ist \verb?e?. Dabei kann
      \verb?e? als sechs durch Doppelpunkt getrennte Hexbytes oder als Name,
      welcher in /etc/ethers definiert ist, angegeben werden.
    \item[gateway host] Die Ethernet-Adresse gehört zu \verb?host?, aber die
      IP-Adresse nicht. So kann man Datenpakete filtern, die über ein
      bestimmtes Gateway ankommen oder abgehen. Das funktioniert nur, wenn
      \verb?host? sowohl als IP-Adresse als auch als Ethernet-Adresse
      aufgelöst werden kann.
    \item[src net n/l]
    \item[dst net n/l]
    \item[net n/l] Entweder die Quelladresse oder die Zieladresse oder
      mindestens eine von beiden liegt im Netz \verb?n? mit einer
      Bitmaskenlänge von \verb?l?. Es gibt noch andere Primitive, um das
      auszudrücken, aber diese Notation funktioniert für IPv4 und IPv6.
    \item[src port p]
    \item[dst port p]
    \item[port p] Entweder der Quellport oder der Zielport oder mindestens
      einer von beiden ist gleich \verb?p?. Das ist nur gültig für TCP oder
      UDP. Falls \verb?p? als Name angegeben wird, muss er in /etc/services
      definiert sein.
    \item[greater l]
    \item[less l]
      Die Paketlänge ist größer/gleich \verb?l? oder kleiner/gleich \verb?l?.
      Achtung, \verb?l? ist nicht die Größe des angezeigten IP-Pakets sondern
      inklusive weiterer Protokollheader. Gegebenenfalls testet man das
      erstmal an einem einfacheren Filterausdruck.
    \item[ip proto p]
    \item[ip6 proto p]
      Das Potokoll \verb?p? ist eines der in /etc/protocols definierten
      Protokolle oder die betreffende Nummer, zum Beispiel 1 für \verb?icmp?,
      6 für \verb?tcp?, 17 für \verb?udp? oder 89 für \verb?ospf?. Da
      \verb?icmp?, \verb?tcp? und \verb?udp? Schlüsselwörter sind, müssen sie
      hier mit Backslash (\verb?\?) geschützt werden: \verb?\icmp?,
      \verb?\tcp?, \verb?\udp?.
    \item[ether broadcast]
    \item[ip broadcast]
    \item[ether multicast]
    \item[ip multicast]
      Diese Primitive sind wahr, wenn das betreffende Paket ein Ethernet- oder
      IP-Broadcast oder -Multicastpaket ist.
    \item[icmp | tcp | udp]
      Sind Abkürzungen für \verb?ip proto \p or ip6 proto \p?, wobei \verb?p?
      für eines der drei Protokolle steht. Das heisst, ich bekomme die
      entsprechenden Protokolle, unabhängig davon, ob sie via IPv4 oder IPv6
      transportiert werden.
    \item[expr relop expr]
      Damit ist es möglich, gezielt nach einzelnen Protokolloptionen zu
      filtern, vorausgesetzt man kennt die entsprechenden Positionen.

      So filtert zum Beispiel \verb?ip[0] & 0xf != 5? alle IPv4 Pakete mit
      gesetzten Optionen.

      Damit lassen sich sehr spezielle Filter erzeugen. Es setzt allerdings
      auch sehr genaue Kenntnis der untersuchten Protokolle voraus.
  \end{description}

  Weitere Informationen zu Optionen, Filterausdrücken und deren Bedeutungen
  gibt es in der Handbuchseite.
\end{normaltext}



\section{wireshark}
\label{sec:netz-werkzeuge-wireshark}
\begin{abstractsec}
  Neben tcpdump verwende ich sehr gern Wireshark zur Auswertung von
  Paketmitschnitten. Da dieses Werkzeug mit einer grafischen
  Benutzeroberfläche daherkommt, habe ich es zwar auf kaum einem Server
  installiert, aber wegen der bequemen Handhabung setze ich es sehr gern zur
  Auswertung von Paketmitschnitten auf meiner Arbeitsstation ein.
\end{abstractsec}
\begin{normaltext}
  Neben tcpdump verwende ich sehr gern Wireshark zur Auswertung von
  Paketmitschnitten. Da dieses Werkzeug mit einer grafischen
  Benutzeroberfläche daherkommt, habe ich es zwar auf kaum einem Server
  installiert, aber wegen der bequemen Handhabung setze ich es sehr gern zur
  Auswertung von Paketmitschnitten auf meiner Arbeitsstation ein. Und, wen es
  sich ergibt, auch zum Mitschneiden der Datenpakete.

  Im Netz finden sich einige Tutorials zum Einsatz von Wireshark, darum gehe
  ich hier nur kurz auf die Menüpunkte ein, die ich am häufigsten einsetze.

  \subsection*{Analyze > Expert Info Composite}
  Einen ersten Überblick über einen geladenen oder mit Wireshark erzeugten
  Paketmitschnitt bekomme ich über den
  Menüeintrag \verb?Analyze > Expert Info Composite?.
  In dem daraufhin geöffneten Fenster sind fünf Panels über die Reiter
  \verb?Errors?, \verb?Warnings?, \verb?Notes?, \verb?Chats? und
  \verb?Details? zu erreichen. Die ersten vier Panels enthalten Bemerkungen
  von Wiresharks zu Ereignissen mit der Wichtung entsprechend dem zugehörigen
  Reiter. Im Panel \verb?Details? finde ich noch einmal alle Bemerkungen in
  der Reihenfolge, in der sie im Paketmitschnitt vorkommen. Praktisch ist, das
  beim Anklicken einer Notiz das zugehörige Datenpaket im Hauptfenster
  ebenfalls gleich ausgewählt wird.

  \subsection*{Statistics > Conversations}
  Über den Menüeintrag \verb?Statistics > Conversations? bekomme ich ebenfalls
  ein Fenster mit mehreren Panels, die über Reiter wie \verb?Ethernet?,
  \verb?IPv4?, \verb?IPv6?, \verb?TCP?, \verb?UDP?, \ldots, jeweils gefolgt
  von einer Zahl, ausgewählt werden. Dabei sind nur die Reiter aktiv, für die
  Wireshark Konversationen (das heisst Datenaustausch mit dem entsprechenden
  Protokoll) identifizieren konnte. Die Zahl gibt die Anzahl der verschiedenen
  Konversationen an.

  Im Panel ist dann eine Liste mit einer Zeile pro Konversation und den
  zugehörigen Parametern zu sehen. Über das Kontextmenü kann man die
  entsprechende Konversation zu einem Displayfilter für das Hauptfenster
  hinzufügen oder einferben.
  
  Bei TCP und UDP kann man auch \verb?Follow Stream? anwählen um in einem
  weiteren Fenster die Nutzdaten der Verbindung zu sehen und zu speichern.
  Dieses Feature von Wireshark ist vor allem dadurch praktisch, weil
  Paketwiederholungen automatisch herausgerechnet werden un man so bequem an
  die Nutzdaten herankommt.

  \subsection*{Statistics > IO Graphs}
  Über diesen Menüeintrag bekomme ich einen grafischen Überblick über den
  zeitlichen Ablauf des Datenverkehrs. Hier kann ich mit Filtern einzelne
  Aspekte farblich hervorheben.

  \subsection*{Hauptfenster}
  Bleibt schließlich die Paketliste im Hauptfenster.

  Mit Displayfiltern kann ich die angezeigten Datenpakete einschränken. Es
  lassen sich Zeitreferenzpunkte für eine genauere Analyse des Zeitverhaltens
  setzen.

  Auch hier habe ich die Möglichkeit, über das Kontextmenü und
  \verb?Follow Stream? an die Nutzdaten zu kommen.

  Und vor allem kann ich für jedes Datenpaket die verschiedenen
  Protokollschichten auf und zu klappen und  brauch die entsprechenden
  Protokollparameter nicht aus dem Hexdump selbst zu ermitteln.
\end{normaltext}
\begin{notes}
\item Wo finde ich Tutorials zu Wireshark?
\end{notes}

\section{libtrace und libtrace-tools}
\label{sec:netz-werkzeuge-librace}
\begin{abstractsec}
  Neben Tcpdump und Wireshark gibt es noch ein drittes Werkzeug, das ich gern
  einsetze, wenn ich auf Paketmitschnitte zurückgreifen muss: libtrace und die
  dazugehörigen Tools.

  Ein großer Vorteil von libtrace ist, dass diese Bibliothek und die damit
  geschriebenen Werkzeuge mit Paketmitschnitten aus unterschiedlichen Quellen
  umgehen können und die verschiedenen Formate ineinander umwandlen können.
\end{abstractsec}
\begin{normaltext}
  Neben Tcpdump und Wireshark gibt es noch ein drittes Werkzeug, das ich gern
  einsetze, wenn ich auf Paketmitschnitte zurückgreifen muss: libtrace und die
  dazugehörigen Tools.

  Mit libtrace kann man ähnlich wie mit libpcap eigene Analysewerkzeuge
  programmieren. Aber hier will ich mehr auf die mitgelieferten libtrace-tools
  eingehen, mit denen Mitschnitte angefertigt und weiter bearbeitet werden
  können.

  Ein großer Vorteil von libtrace ist, dass diese Bibliothek und die damit
  geschriebenen Werkzeuge mit Paketmitschnitten aus unterschiedlichen Quellen
  umgehen können und die verschiedenen Formate ineinander umwandlen können.
  Dazu verwendet libtrace sogenannte URI um das Format und die Quelle
  beziehungsweise das Ziel anzugeben.

  \begin{table}
    \begin{tabularx}{\textwidth}{X | l | c | c}
    Format & URI & Lesen & Schreiben \\
    \hline
    Live PCAP Schnittstelle & pcapint:<interface> & Ja & Ja \\
    PCAP Trace Datei & pcapfile:<filename> & Ja & Ja \\
    ERF Trace Datei & erf:<filename> & Ja & Ja \\
    DAG Gerät & dag:<device location> & Ja & Ja \\
    Native Linux interface & int:<interface> & Ja & Ja \\
    Native Linux interface (ring buffers) & ring:<interface> & Ja & Ja \\
    Native BSD interface & bpf:<interface> & Ja & Nein \\
    TSH trace file & tsh:<filename> & Ja & Nein \\
    FR+ trace file & fr+:<filename> & Ja & Nein \\
    Legacy DAG ATM Trace Datei & legacyatm:<filename> & Ja & Nein \\
    Legacy DAG POS Trace Date & legacypos:<filename> & Ja & Nein \\
    Legacy DAG Ethernet Trace Datei & legacyeth:<filename> & Ja & Nein \\
    Legacy DAG NZIX Trace Datei & legacynzix:<filename> & Ja & Nein \\
    ATM Cell Header Trace Datei & atmhdr:<filename> & Ja & Nein \\
    RT Network Protocol & rt:<host>:<port> & Ja & Nein \\
    \end{tabularx}
    \caption{Unterstützte Formate für Paketmitschnitte}
  \end{table}

  Damit genug der Vorrede, kommen wir nun zu den Werkzeugen.

  \subsection*{traceanon}
  Mit traceanon kann man die IP-Adressen von Paketmitschnitten anonymisieren.
  Das ist immer dann wichtig, wenn ein Paketmitschnitt zu einem Problem
  weitergereicht werden, aber möglichst wenig Informationen zur
  Netzwerkstruktur preisgegeben werden soll.

  Traceanon ändert die IP-Header der Datenpakete sowie die in ICMP
  eingebetteten IP-Header und repariert die Prüfsummen innerhalb von TCP- und
  UDP-Headern.

  Es gibt zwei Schemata, zum Einen wird ein kompletter Adressblock durch einen
  anderen ersetzt und zum Anderen werden die Adressen mit dem
  Cryptopan-Verfahren ersetzt.

  Wichtig beim Einsatz von traceanon ist, immer im Hinterkopf zu behalten,
  dass IP-Adressen auch auf anderem Weg offenbar werden können. So werden zum
  Beispiel IP-Adressen innerhalp von ARP-Paketen nicht anonymisiert und einige
  Anwendungsprotokolle wie zum Beispiel HTTP, SMTP, OSPF und andere
  Routingprotokolle können in den Anwendungsdaten Informationen über die
  beteiligten Netze preisgeben.

  Der Aufruf sieht so aus:
  \begin{verbatim}
  traceanon [options] sourceuri desturi
  \end{verbatim}
  Die möglichen Optionen sind der Handbuchseite zu entnehmen.

  \subsection*{tracediff}
  Dieses Werkzeug findet Differenzen zwischen zwei Mitschnitten und gibt diese
  aus. Dabei wird der Inhalt aus den Framingheadern (PCAP oder ERF) nicht
  ausgewertet.

  Mit der Option \verb?-m max? kann ich die Ausgabe nach \verb?max?
  Unterschieden abbrechen lassen.

  Der Aufruf sieht so aus:
  \begin{verbatim}
  tracediff [ -m maxdiff ] firsturi seconduri
  \end{verbatim}

  Tracediff ist zum Beispiel nützlich, wenn ich mehrere Mitschnitte einer
  Verbindungssitzung an verschiedenen Stellen aufgenommen habe und diese
  vergleichen will.

  \subsection*{tracemerge}
  Mit diesem Werkzeug kann ich zwei oder mehrere Paketmitschnitte zu einer
  kombinieren, wobei die Reihenfolge der Pakete beibehalten wird.

  Der Aufruf sieht so aus:
  \begin{verbatim}
  tracemerge [ options ] outputuri inputuri ...
  \end{verbatim}
  Die möglichen Optionen sind der Handbuchseite zu entnehmen.

  \subsection*{tracepktdump}
  Mit diesem Programm kann ich Datenpakete in lesbarer Form ausgeben.
  Dabei kann ich mit der Option \verb?-f filter? die Ausgabe auf bestimmte
  Pakete einschränken und mit \verb?-c count? die Anzahl der angezeigten
  Pakete begrenzen.

  Die Ausgabe ist abhängig davon, inwieweit die mitgeschnittenen Protokolle in
  libtrace bekannt sind und ändert sich folglich von Version zu Version.

  Folgender Beispielaufruf mit tracepktdump aus den libtrace-tools Version
  3.0.10 soll das verdeutlichen:
  \begin{verbatim}
$ tracepktdump pcap/ospf-1.pcap
Wed Sep 26 13:54:58 2012
 Capture: Packet Length: 138/142 Direction Value: -1
 Ethernet: Dest: 01:00:5e:00:00:05 Source: 12:6a:17:1a:52:6e Ethertype: 0x0800
 IP: Header Len 20 Ver 4 DSCP 30 ECN 0 Total Length 124
 IP: Id 10064 Fragoff 0
 IP: TTL 1 Proto 89 (ospf) Checksum 11126
 IP: Source 132.147.1.11 Destination 224.0.0.5
unknown protocol ip/89
 Unknown Protocol: 89
  02 01 00 68 84 93 01 0b 00 00 00 00 e2 48 00 00    ...h.........H..
  00 00 00 00 00 00 00 00 ff ff 00 00 00 0a 02 01    ................
  00 00 00 28 84 93 01 0d 84 93 01 12 84 93 01 03    ...(............
  c0 a8 fe 09 c0 a8 fe 05 c0 a8 ef 0a c0 a8 ef 0b    ................
  c0 a8 ef 14 c0 a8 ef 15 0a 09 01 01 84 93 04 01    ................
  84 93 04 0f 84 93 04 11 84 93 04 13 84 93 05 02    ................
  84 93 05 03 84 93 01 0e                            ........                        

  \end{verbatim}
  In dieser Version ist das OSPF-Protokoll in der Bibliothek noch nicht
  bekannt und wird daher als Hexdump präsentiert.
  Die IP- und Ethernetheader hingegen werden dekodiert und erscheinen nicht
  im Hexdump.

  \subsection*{tracereplay}
  Dieses Werkzeug spielt einen Paketmitschnitt mit den gleichen Zeitabständen
  aus einer URI zu einer anderen. Insbesondere wenn die zweite URI ein
  Netzwerkinterface bestimmt, kann ich damit einen Mitschnitt wieder auf das
  Netz schicken.
  Prüfsummen werden dabei während des Abspielens neu berechnet.

  Mit der Option \verb?-f filter? kann ich die zurückgespielten Datenpakete
  einschränken und \verb?-b? kann ich als Zielethernetadresse die
  Broadcast-Adresse verwenden.

  Beim Zurückspielen werden ansonsten die Ethernetadresssen aus dem Mitschnitt
  verwendet, so dass ich das vorwiegend im selben Netzsegment einspielen will.

  Abhängig vom Switch und dem Verkehr im Netz können die Reaktionen anderer
  Rechner auf die wiedereingespielten Datenpakete auch an andere Rechner
  gehen, wenn deren Ethernetadresse als Absender im Mitschnitt steht.

  Der Aufruf sieht so aus:
  \begin{verbatim}
  tracereplay [ options ] inputuri outputuri
  \end{verbatim}
  Die möglichen Optionen sind der Handbuchseite zu entnehmen.

  \subsection*{tracereport}
  Dieses Programm kann eine Reihe von Berichten über die Eigenschaften von
  Paketmitschnitten produzieren. Die Berichte landen in Dateien deren Name
  gleich der Langoption gefolgt vom Suffix \verb?.rpt? ist.

  Unter anderem folgende Optionen und Reports stehen zur Verfügung:
  \begin{description}
    \item[-e | --error] erzeugt einen Bericht über Paketfehler (zum Beispiel
      Prüfsummenfehler, Empfangsfehler).
    \item[-F | --flow] erzeugt einen Bericht über die Anzahl von Datenflüssen.
    \item[-m | --misc] liefert einen allgemeinen Bericht (Zeitpunkt des ersten
      und letzten Paketes, Gesamtzahl der Pakete, \ldots)
    \item[-P | --protocol] erzeugt einen Bericht über die im Mitschnitt
      vorkommenden Protokolle der Transportschicht
    \item[-p | --ports] liefert einen Bericht über die vorkommenden Ports
    \item[-t | --ttl] berichtet über die TTL der Datenpakete im Mitschnitt
    \item[-n | --nlp] berichtet über die im Mitschnitt vorkommenden Protokolle
      der Netzwerkschicht
    \item[-d | --direction] berichtet, wieviel Traffic in jede Richtung geht
  \end{description}
  Mehr Optionen und Berichte beschreibt die Handbuchseite.

  \subsection*{tracertstats}
  Mit diesem Programm bekomme ich eine einfache filter- und zeitbasierte
  Analyse eines Paketmitschnitts.
  Dabei wird der Mitschnitt in Intervalle aufgeteilt und für jedes Intervall
  angegeben, wie viele Datenpakete passen zu den angegebenen Filtern im
  Intervall vorkommen.

  Die möglichen Optionen sind unter anderen:
  \begin{description}
    \item[-f filter] legt die Filter für die Analyse fest, kann auch mehrfach
      angegeben werden
    \item[-i interval] bestimmt das zugrunde liegende Zeitraster in Sekunden
    \item[-m] wenn mehrere Paketmitschnitte angegeben werden, sollen diese
      zusammengefasst werden (merge)
    \item[-o format] legt das Ausgabeformat fest (\verb?txt?, \verb?csv?,
      \verb?html?)
  \end{description}
  Weitere Optionen stehen in der Handbuchseite.
  
  \subsection*{tracestats}
  Dieses Programm gibt ähnliche Analysen wie tracertstats aus, aber jeweils
  für den gesamten Paketmitschnitt und nicht für einzelne Zeitintervalle
  daraus. Mit der Option \verb?-f filter? kann ich auch hier die Pakete
  angeben, an denen ich interessiert bin.

  Das Programm tracesummary ist ein Shellwrapper um tracestats und gibt eine
  einfache Zusammenfassung für einen Paketmitschnitt an.

  \subsection*{tracesplit}
  Dieses Programm teilt einen Paketmitschnitt in mehrere Dateien auf.

  Das kann ich unter anderen mit diesen Optionen beeinflussen:
  \begin{description}
    \item[-f filter] gibt nur die Pakete aus, die zu dem angegebenen Filter
      passen
    \item[-c count] schreibt maximal \verb?count? Pakete pro Ausgabedatei. Die
      Ausgabedateien werden benannt nach dem in outputuri angegeben Basisnamen
      mit der angehängten Nummer des ersten Paketes in der Datei.
    \item[-b bytes] schreibt maximal \verb?bytes? Bytes in eine Datei
    \item[-i seconds] startet eine neue Datei aller \verb?seconds? Sekunden
    \item[-s unixtime] beginnt die Ausgabe bei \verb?unixtime?
    \item[-e unixtime] endet die Ausgabe bei \verb?unixtime?
    \item[-m max] erzeugt nicht mehr als \verb?max? Ausgabedateien
    \item[-S snaplen] schneidet die Datenpakete bei \verb?snaplen? ab. Ohne
      diese Angabe wird das komplette Datenpaket geschrieben.
    \item[-z level] setzt den Kompressionsgrad (0..9)
    \item[-Z method] wählt die Kompressionsmethode (\verb?gzip?, \verb?bzip2?,
      \verb?lzo? oder \verb?none?)
  \end{description}
  Weitere Optionen stehen in der Handbuchseite.

  Zwei weitere Werkzeuge sind lediglich Shellwrapper um das Programm
  tracesplit:
  \begin{description}
    \item[traceconvert] transformiert einen Mitschnitt aus einem Format in
      ein anderes
    \item[tracefilter] extrahiert Datenpakete anhand von BPF-Filtern aus einem
      Mitschnitt
  \end{description}

  \subsection*{tracesplit\_dir}
  Dieses Programm teilt einen Mitschnitt in zwei Richtungen auf. Die
  Richtungen müssen aus der Inputuri erkennbar sein.

  Der Aufruf sieht so aus:
  \begin{verbatim}
  tracesplit_dir inputuri outputuri_incoming outputuri_outgoing
  \end{verbatim}

  \subsection*{tracetop}
  Das Programm zeigt die obersten n Datenflüsse in jeder Sekunde an, ähnlich
  wie top für Prozesse oder mytop für MySQL-Verbindungen.

  Mit den folgenden Optionen kann ich die Ausgabe beeinflussen:
  \begin{description}
    \item[-f filter] zählt nur die Pakete, die zu dem Filter passen
    \item[-i interval] gibt das Intervall in Sekunden zwischen den
      Bildschirmaktualisierungen vor (Voreinstellung 2 Sekunden)
    \item[--percent] zeigt die Bytes und Pakete der Datenflüsse als Anteil vom
      Gesamtdatenverkehr
    \item[--bits-per-second] zeigt die Bandbreite als Bits pro Sekunde an
  \end{description}
\end{normaltext}
\begin{notes}
\item URIs erklären
\item Cryptopan erklären
\item bpf-Filter erklären
\end{notes}


\section{quagga}
\label{sec:netz-werkzeuge-quagga}
\begin{abstractsec}
  Einige Probleme im Netzwerk lassen sich auf fehlerhafte Routen zurückführen.
  Die Routingtabelle des Kernels kann ich mit den Befehlen \verb?netstat -rn?
  oder \verb?ip route show? schnell kontrollieren.
  Stelle ich dabei eine fehlerhafte Route fest, ist meine nächste Frage: woher
  kommt diese Route?
  Bei der Beantwortung dieser Frage kann mir das Programm quagga helfen.
\end{abstractsec}
\begin{normaltext}
  Einige Probleme im Netzwerk lassen sich auf fehlerhafte Routen zurückführen.
  Die Routingtabelle des Kernels kann ich mit den Befehlen \verb?netstat -rn?,
  \verb?route -n? oder \verb?ip route show? schnell kontrollieren.
  Stelle ich dabei eine fehlerhafte Route fest, ist meine nächste Frage: woher
  kommt diese Route?
  Bei der Beantwortung dieser Frage kann mir das Programm quagga helfen.

  Quagga ist eine Programmsuite, die Protokolldämonen für die
  Routingprotokolle RIP, OSPF, BGP und ISIS enthält. Die Konfigurationssprache
  ist derjenigen von Cisco-Routern sehr ähnlich, so dass jemand, der diese
  Geräte kennt, sich schnell hineinfindet.

  Konfiguriert werden die Protokolldämonen entweder via telnet, über ein
  Programm namens vtysh oder durch Editieren der Konfigurationsdateien im
  Verzeichnis /etc/quagga und anschließenden Neustart der Protokolldämonen.

  \subsection*{interaktive Konfiguration}

  Bei der interaktiven Konfiguration via telnet und vtysh habe ich die
  Möglichkeit, die interne Hilfefunktion als Gedächtnisstütze heranzuziehen.
  Ausserdem werden Syntaxfehler sofort abgewiesen.
  Der Befehl \verb?list? listet alle momentan möglichen Befehle nebst Argument
  auf.
  Ein \verb!?! an beliebiger Stelle zeigt die möglichen Fortsetzungen. Das
  heißt, ein Fragezeichen am Zeilenanfang listet alle momentan möglichen
  Befehle, ein Fragezeichen nach einem Befehl listet die möglichen nächsten
  Argumente.
  Befehle müssen nor soweit ausgeschrieben werden, dass sie eindeutig sind.
  Das gleiche gilt für die Argumente.

  Mit \verb?<Ctrl-P>? erhalte ich die letzte Zeile, mit \verb?<Ctrl-N>? die
  nächste. An den Anfang der Zeile der Zeile komme ich mit \verb?<Ctrl-A>?, an
  das Ende mit \verb?<Ctrl-E>?. Ausserdem funktionieren auf neueren Systemen
  die Cursortasten und alle anderen Funktionen der libreadline.

  Bei der interaktiven Arbeit mit den Protokolldaemonen habe ich drei Modi. Im
  ersten, dem Operatormodus kann ich im wesentlichen nur Informationen über
  den aktuellen Zustand und die Routen abfragen. Mit dem Befehl \verb?enable?
  gelange ich in den Administratormodus und mit \verb?disable? komme ich
  wieder zurück.
  Im Administratormodus sehe ich mehr Informationen, vor allem kann ich die
  aktuelle Konfiguration ansehen, sichern oder wiederherstellen.
  Aus dem Administratormodus komme ich mit dem Befehl \verb?configure terminal?
  in den Konfigurationsmodus und aus diesem mit \verb?end? oder \verb?exit?
  zurück in den Administratormodus.
  Der Befehl \verb?exit? im Administrator- oder Operatormodus beendet die
  Sitzung.

  Im Konfigurationsmodus kann ich jeden einzelnen Aspekt der Konfiguration
  ändern. Dabei lassen sich einzelne Befehle zurücknehmen, indem sie mit
  vorangestelltem \verb?no? noch einmal eingegeben werden. Finde ich zum
  Beispiel eine statische Route in der Konfiguration:
  \begin{verbatim}
zebra# ip route destination gateway
  \end{verbatim}
  dann kann ich diese wie folgt entfernen:
  \begin{verbatim}
zebra# config t
zebra(config)# no ip route destination gateway
zebra# end
  \end{verbatim}

  Auf die gleiche Art bearbeite ich auch ACL. Diese werden oft mit einer
  Auffangregel am Ende abgeschlossen. Füge ich eine neue spezielle Regel an,
  ist diese nicht aktiv, weil die Auffangregel nun davor steht. In diesem Fall
  entferne ich die Auffangregel mit vorangestelltem \verb?no? und füge sie
  sofort wieder am Ende an.

  \subsection*{Protokollierung}
  Mit den \verb?show ..? Befehlen kann ich mir den aktuellen Zustand des
  Routingprotokolldämons ansehen. Das hilft mir oft schon, den Fehler
  einzugrenzen. Suche ich aber nach der Ursache für den Fehler, dann benötige
  ich Informationen darüber, wann etwas passiert ist. Dabei helfen mir die
  \verb?log? und \verb?debug? Befehle. Mit dem \verb?log? Befehl lege ich
  fest, wohin die Routingdämonen protokollieren und mit den \verb?debug?
  Befehlen, was protokolliert wird. Je nach Routingprotokoll und eingestellter
  Protokollierung können die Logdateien sehr schnell sehr unübersichtlich
  werden. Dann helfen mir ein paar Zeilen Perl-Skript, die relevanten
  Informationen herauszufischen und zusammenzusetzen.
\end{normaltext}

\section{telnet}
\label{sec:netz-werkzeuge-telnet}
\begin{abstractsec}
  Neben SSH ist Telnet ein sehr wichtiges Programm für die Fehlersuche im
  Netz. Zum Einen verwende ich es für den Zugriff auf ältere Router und
  Switches, die das SSH-Protokoll nicht anbieten oder für den Zugriff auf die
  interaktive Shell der Quagga-Protokolldämonen. Zum Anderen setze ich es für
  kurze Tests von Anwendungsprotokollen wie SMTP, POP, IMAP, FTP oder HTTP
  ein, die mit Plaintext via TCP arbeiten.
\end{abstractsec}
\begin{normaltext}
  Neben SSH ist Telnet ein sehr wichtiges Programm für die Fehlersuche im
  Netz. Zum Einen verwende ich es für den Zugriff auf ältere Router und
  Switches, die das SSH-Protokoll nicht anbieten oder für den Zugriff auf die
  interaktive Shell der Quagga-Protokolldämonen. Zum Anderen setze ich es für
  kurze Tests von Anwendungsprotokollen wie SMTP, POP, IMAP, FTP oder HTTP
  ein, die mit Plaintext via TCP arbeiten.

  Zwar ist beim Testen der Plaintextprotokolle netcat etwas praktischer, aber
  gerade auf älteren Rechnern findet man häufiger telnet als netcat.

  Der Vorteil von telnet liegt eindeutig bei den interaktiven Shells, weil
  hier Kennworte nicht auf der Konsole ausgegeben werden, so dass sie nicht
  durch einfaches Schultersurfen abgeschaut werden können. Außerdem
  funktionieren die Cursortasten mit telnet besser.

  Ein Nachteil von telnet gegenüber netcat beim Testen der Plaintextprotokolle
  ist, dass das Abbrechen einer Verbindung insbesondere mit einer deutschen
  Tastatur eher unbequem ist, da die Escape-Sequenz um in den Kommandomodus zu
  kommen hier ungünstig belegt ist und ich dann meist darauf setze, dass die
  Gegenstelle die Verbindung abbaut. Alternativ kann ich beim Aufruf von
  telnet mit der Option \verb?-e <irgendwas>? ein anderes Zeichen für das
  Umschalten in den Kommandomodus mitgeben, muss dann aber ein Zeichen
  auswählen, dass im Protokoll nicht vorkommt und trotzdem leicht zu erreichen
  ist.
\end{normaltext}

\section{netcat}
\label{sec:netz-werkzeuge-netcat}
\begin{abstractsec}
  Ein weiteres Werkzeug um schnell eine Netzwerkverbindung herzustellen,
  ähnlich wie telnet doch weitaus flexibler, ist netcat. Damit kann ich nicht
  nur TCP-, UDP- oder UNIX-Socket-Verbindungen sehr einfach aufbauen, sondern
  außerdem ganz schnell mal eben einen Socket-Server für die genannten
  Protokolle einrichten.
\end{abstractsec}
\begin{normaltext}
  Ein weiteres Werkzeug um schnell eine Netzwerkverbindung herzustellen,
  ähnlich wie telnet doch weitaus flexibler, ist netcat. Damit kann ich nicht
  nur TCP-, UDP- oder UNIX-Socket-Verbindungen sehr einfach aufbauen, sondern
  außerdem ganz schnell mal eben einen Socket-Server für die genannten
  Protokolle einrichten.

  Netcat ist sehr gut in Skripten einsetzbar und kann auch ein rudimentäres
  Port-Scanning für TCP-Ports. Und, was in manchen Umgebungen wichtig sein
  kann: netcat kann mit Proxy-Servern umgehen und darüber Verbindungen
  herstellen.

  \subsection*{Aufruf}

  Der grundlegende Aufruf ist
  \begin{verbatim}
$ netcat [ optionen ] host port
  \end{verbatim}
  wenn ich eine Verbindung via TCP oder UDP aufbauen will,
  \begin{verbatim}
$ netcat [ optionen ] port
  \end{verbatim}
  wenn ich auf TCP- oder UDP-Verbindungen warten will, und
  \begin{verbatim}
$ netcat [ optionen ] socketpath
  \end{verbatim}
  wenn ich mit UNIX-Domain-Sockets arbeiten will.

  Wenn ich einen Portscan mit Option \verb?-z? starten will, kann ich statt
  eines Ports auch einen Bereich (\verb?port1-port2?) angeben.

  \subsection*{Optionen}

  Einige der wichtigsten Optionen sind:
  \begin{description}
    \item[-k] In Verbindung mit der Option \verb?-l? wartet netcat auf weitere
      Verbindungen, wenn die erste beendet ist. Ohne diese Option beendet sich
      netcat nach der ersten Verbindung.
    \item[-l] Netcat wartet auf eine ankommende Verbindung anstatt selbst eine
      Verbindung zu öffnen.
    \item[-s addr] Setzt die Absenderadresse auf \verb?addr?. Das ist
      insbesondere nützlich, wenn der Rechner mehrere Adressen hat.
    \item[-U] verwendet UNIX-Domain-Sockets
    \item[-u] verwendet UDP statt TCP
    \item[-X proto] verwendet Proxyprotokoll \verb?proto?. Mögliche Werte sind
      \verb?4? für SOCKS Version 4, \verb?5? für SOCKS Version 5 und
      \verb?connect? für die CONNECT-Methode bei HTTP-Proxies.
    \item[-x addr:port] spezifiziert die Adresse und den Port des
      Proxieservers.
    \item[-z] weist netcat an, keine Verbindung aufzubauen, sondern nur
      nachzuschauen, ob der Port oder Portbereich offen ist. Diese Option
      kombiniert man sinnvollerweise mit \verb?-v?.
  \end{description}
  Weitere Optionen finden sich in den Handbuchseiten.

  \subsection*{Beispiele}

  Die folgenden Beispiele sind der Handbuchseite von netcat entnommen.

  \subsubsection*{Client/Server}
  Für eine einfache Client-Server-Verbindung gebe ich folgendes auf der
  Serverseite ein:
  \begin{verbatim}
$ netcat -l 1234
  \end{verbatim}
  Auf der Clientseite dann das folgende:
  \begin{verbatim}
$ netcat host.example.net 1234
  \end{verbatim}
  um mich mit dem Server zu verbinden.

  Mit Option \verb?-u? verwende ich UDP statt TCP zur Übertragung.

  Mit Option \verb?-U? geht es stattdessen (auf demselben Rechner) über
  UNIX-Domain-Sockets. Dann lasse ich auf Clientseite den Rechnernamen weg und
  verwende statt der Portnummer den Pfadnamen zur Socketdatei. Diese darf bei
  Aufruf der Serverseite noch nicht existieren.

  \subsubsection*{Datentransfer}
  Um schnell mal eine Datei zu übertragen erweitere ich das Client/Server
  Beispiel auf Serverseite wie folgt:
  \begin{verbatim}
$ netcat -l 1234 > file.out
  \end{verbatim}
  Und auf Clientseite:
  \begin{verbatim}
$ netcat host.example.net 1234 < file.in
  \end{verbatim}
  Die Verbindung widr nach erfolgter Datenübertragung automatisch geschlossen.
  Vertausche ich die spitzen Klammern, wird die Datei vom Server zum Client
  übertragen.

  \subsubsection*{Einen Server testen}
  Wenn ich das Plaintextprotokoll des Servers kenne, kann ich mit netcat auch
  differenziertere Protokolle bedienen oder testen:
  \begin{verbatim}
$ netcat -C mail.example.net 25 <<EOT
HELO host.example.net
MAIL FROM:<user@host.example.net>
RCPT TO:<user2@host.example.net>
DATA
Subject: Testmail

Body of email.
.
QUIT
EOT
  \end{verbatim}
  Damit kann ich eine E-Mail einspeisen, um einen Mailserver zu testen. Das
  gleiche könnte ich auch interaktiv (von Hand) eingeben. Oder zum Beispiel an
  einem POP3-Server nachsehen, ob eine bestimmte E-Mail angekommen ist.

  \subsubsection*{Portscanning}
  Um festzustellen, welche Ports an einem Rechner erreichbar sind, kann ich
  netcat wie folgt aufrufen:
  \begin{verbatim}
$ nc -z -v smtp.example.net 22-25
Connection to smtp.example.net 22 port [tcp/ssh] succeeded!
nc: connect to smtp.example.net port 23 (tcp) failed: Connection refused
nc: connect to smtp.example.net port 24 (tcp) failed: Connection refused
Connection to smtp.example.net 25 port [tcp/smtp] succeeded!
  \end{verbatim}
\end{normaltext}

\section{openssl s\_client}
\label{sec:netz-werkzeuge-openssl}
\begin{abstractsec}
  Openssl s\_client ist das dritte Werkzeug, welches ich zu Verbindungstests
  verwende. Dabei handelt es sich um einen generischen SSL/TLS Client, mit dem
  ich verschlüsselte Protokolle wie HTTPS, SSMTP, \ldots und die
  entsprechenden Server testen kann.
\end{abstractsec}
\begin{normaltext}
  Openssl s\_client ist das dritte Werkzeug, welches ich zu Verbindungstests
  verwende. Dabei handelt es sich um einen generischen SSL/TLS Client, mit dem
  ich verschlüsselte Protokolle wie HTTPS, SSMTP, \ldots und die
  entsprechenden Server testen kann.

  \subsection*{Aufruf}
  Der Grundlegende Aufruf sieht wie folgt aus:
  \begin{verbatim}
$ openssl s_client -connect host:port [ options ]
  \end{verbatim}
  
  \subsection*{Optionen}
  Die folgenden Optionen verwende ich hin und wieder, weitere gibt es wie
  fast immer in den Handbuchseiten.
  \begin{description}
    \item[-connect host:port] Baut eine SSL- oder TLS-Verbindung zu dem
      angegebenen Server und Port auf.
    \item[-crlf] Setzt den Zeilenvorschub des Terminals in CR+LF, wie für
      einige Protokolle gefordert, um.
    \item[-quiet] Unterdrückt die Ausgabe der Zertifikatinformationen.
    \item[starttls proto] sendet die Protokollspezifischen Befehle um eine
      Verbindung auf TLS umzuschalten. Für \verb?proto? sind momentan nur die
      folgenden Protokolle erlaubt: \verb?smtp?, \verb?pop3?, \verb?imap?,
      \verb?ftp?.
  \end{description}
  Bei Problemen mit der Aushandlung des SSL-Protokolls kann man mit den
  Optionen \verb?-bugs?, \verb?-ssl2?, \verb?-ssl3?, \verb?-tls?,
  \verb?-no_ssl2?, \ldots experimentieren. Details finden sich in der
  Handbuchseite.

  \subsection*{Beispiel}
  Das folgende Beispiel zeigt eine HTTP-Abfrage mit openssl:
  \begin{verbatim}
$ openssl s_client -connect encrypted.example.net:443 -quiet
depth=0 CN = encrypted.example.net
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = encrypted.example.net
verify return:1
GET / HTTP/1.0
Host: encrypted.example.net

HTTP/1.1 200 OK
Date: Fri, 05 Apr 2013 09:39:20 GMT
Server: Apache
Vary: Accept-Encoding
Content-Length: 709
Connection: close
Content-Type: text/html;charset=UTF-8

<!DOCTYPE HTML PUBLIC ``-//W3C//DTD HTML 3.2 Final//EN''>
<html>
<head>
<title>Index of /</title>
</head>
<body>
<h1>Index of /</h1>
...
<address>Apache Server at encrypted.example.net Port 443</address>
</body></html>
  \end{verbatim}
\end{normaltext}


\section{samba, smbclient}
\label{sec:netz-werkzeuge-smbclient}
\begin{abstractsec}
  Die Programme der Samba-Suite, insbesondere die zum Paket smbclient
  zusammengefassten können bei der Fehlersuche in Zusammenhang mit MS Windows
  Rechnern helfen.
\end{abstractsec}
\begin{normaltext}
  Die Programme der Samba-Suite, insbesondere die zum Paket smbclient
  zusammengefassten können bei der Fehlersuche in Zusammenhang mit MS Windows
  Rechnern helfen.

  Konkret handelt es sich dabei um die Programme
  \begin{description}
    \item[findsmb] liefert Informationen über Maschinen, die auf SMB
      Namensanfragen in einem Netz antworten
    \item[rpcclient] führt MS-RPC-Funktionen aus
    \item[smbcacls] erfragt oder setzt ACLs auf NTFS Dateien oder
      Verzeichnissen
    \item[smbclient] ist ein FTP-ähnliches Programm um auf SMB/CIFS Ressourcen
      auf Servern zuzugreifen
    \item[smbcquota] dient zum Setzen und Abfragen der Quotas von NTFS 
      Freigaben
    \item[smbget] kann, ähnlich wget für HTTP, Dateien mit dem SMB-Protokoll
      herunterladen
    \item[smbtar] ist ein Shellskript, mit dem SMB/CIFS Freigaben direkt auf
      UNIX Bandlaufwerke gesichert werden können
    \item[smbtree] ist eine Art textbasierter SMB Netzwerkbrowser
    \item[smbspool] kann eine Druckdatei an einen SMB Drucker senden
  \end{description}
\end{normaltext}
\section{perl}
\label{sec:netz-werkzeuge-perl}
\begin{abstractsec}
  Für knifflige Probleme, die ich mit den spezialisierten Werkzeugen nicht zu
  fassen kriege und denen mit einfacher Shell-Programmierung auch nicht
  beizukommen ist, benötige ich eine Programmiersprache, die mächtiger als die
  Shell ist, mit der ich aber trotzdem mit wenig Aufwand ein passendes
  Programm schreiben kann. Insbesondere durch die vielen verfügbaren Module
  auf CPAN kann ich damit relativ schnell eine Speziallösung für vertrackte
  Probleme zusammenbauen.
\end{abstractsec}
\begin{normaltext}
  Perl hatte ich als Werkzeug bereits im Abschnitt über die Werkzeuge zur
  lokalen Fehlersuche beschrieben. Durch die vielen einfach verfügbaren und
  meist sehr gut getesteten und dokumentierten Module auf CPAN ist Perl auch
  ein unentbehrliches Werkzeug für die Fehlersuche bei Netzwerkproblemen.

  Das Perl Kochbuch \cite{ChristiansenTorkington04de} hatte ich bereits
  erwähnt. Mit dessen Hilfe und den darin beschriebenen Modulen von CPAN war
  es mir zum Beispiel möglich ein Testprogramm für ein Timing-Problem bei
  einem Webservice zu schreiben.

  \subsection*{HTTP Injector}

  Vor einiger Zeit hatte ich ein Problem, bei dem 502-Fehler von
  einem Webservice abhängig waren von der Zeit für die
  Anfrage. Der Betreiber des Webservices stritt das ab und um das
  Problem zu verifizieren benötigte ich die Möglichkeit HTTP-Anfragen gezielt
  zu verzögern.
  
  Ich kam mit Hilfe des Kochbuches zu folgendem Programm:
  \begin{verbatim}
01:#!/usr/bin/perl
02:use Getopt::Long;
03:use IO::Socket;
04:use Time::HiRes qw(sleep);
05:
06:my %opt = ( delay => 0 );
07:
08:GetOptions( \%opt, 'delay=i');
09:
10:my $server = shift;
11:my $port   = shift || 80;
12:
13:my $socket = IO::Socket::INET->new(PeerAddr => $server,
14:                                   PeerPort => $port,
15:                                   Proto    => 'tcp',
16:                                   Type     => SOCK_STREAM);
17:
18:my @in = <>;
19:my $del = $opt{delay} / ( 1.0 + scalar @in );
20:foreach (@in) {
21:    s/[\r\n]+$//;
22:    sleep $del;
23:    print $socket $_, "\r\n";
24:}
25:sleep $del;
26:print $socket "\r\n";
27:
28:while (my $line = <$socket>) {
29:    print $line;
30:}
  \end{verbatim}
  In den Zeilen 2-4 lade ich die benötigten Module. \verb?Getopt::Long? ist
  für die Verarbeitung der Kommandozeilenoptionen und sichert ab, dass ich mit
  \verb?--delay? einen Integerwert angebe. \verb?IO::Socket? stellt die
  Socketfunktionalität bereit, so dass ich diesen Socket wie eine Datei
  verwenden kann. \verb?Time::HiRes? stellt mir eine verbesserte
  \verb?sleep()? Funktion bereit, die mit Gleitkommazahlen zurechtkommt.

  In Zeile 6 stelle ich die Option \verb?--delay? auf den Wert 0 ein, falls
  sie nicht explizit angegeben wird. In Zeile 8 werden die Optionen
  eingelesen.

  Zeile 10 und 11 entnehmen den Server und gegebenenfalls den Port der
  Kommandozeile und in Zeile 13 öffne ich mit diesen Angaben den Socket.

  In Zeile 18 lese ich die gesamte Eingabe in ein Array ein. Dies benötige
  ich, da ich die Anzahl der Zeilen wissen muss, denn ich verzögere das Senden
  zeilenweise um jeweils einen Bruchteil der Gesamtverzögerung. Die Zeilen
  20-25 schließlich bereiten die Zeilenenden auf und senden die modifizierten
  Zeilen verzögert über den Socket. Zeile 26 schickt die Leerzeile, nach der
  der Server antwortet.

  In Zeile 28-30 liest das Skript die Antwort des Servers vom Socket und
  schreibt sie zur Standardausgabe.

  Dieses Skript kann ich nun wie folgt aufrufen:
  \begin{verbatim}
time ./http-injector.pl --delay 5 localhost 80 < request > reply

real  0m5.072s
user  0m0.056s
sys   0m0.012s
  \end{verbatim}
  Dabei steht in der Datei request die HTTP-Anfrage, die ich an den Server
  sende.
  Nach fünf Sekunden ist die Anfrage beim Server, und die Antwort landet in
  der Datei reply.

  Damit konnte ich nachweisen, dass dieselbe Anfrage einen Fehler
  lieferte, wenn sie mehr als drei Sekunden zur Übertragung brauchte und
  fehlerfrei beantwortet wurde, wenn sie weniger als drei Sekunden brauchte.
\end{normaltext}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "troubleshoot-linux"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:

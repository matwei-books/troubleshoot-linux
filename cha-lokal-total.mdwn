# Totalausfall {#cha-lokal-totalausfall}

Ein Totalausfall bedeutet für mich zuallererst, der Rechner selbst ist keine
große Hilfe bei der Fehlersuche.
Das muss nicht heißen, dass der Rechner überhaupt nicht mehr reagiert, aber
auf jeden Fall stehen mir nicht alle Werkzeuge zur Verfügung, die ich sonst
zur Analyse einsetzen könnte.

Ich betrachte die folgenden Probleme als Totalausfall eines Rechners.

*  Hardwarefehler, der Rechner reagiert überhaupt nicht beim Einschalten.
   Abgesehen von dem Tipp, den Stromanschluss zu überprüfen, gehe ich darauf
   hier nicht weiter ein.


*  Boot-Probleme, zwar passiert etwas, die Hardware scheint größtenteils in
   Ordnung, aber das Betriebssystem wird nicht gestartet.
   Hier analysiere ich den Bootprozess Schritt für Schritt, beobachte, wie
   weit das System kommt und versuche die Ursache zu ermitteln.

*  Der Rechner war normal gestartet, hat eine Zeit lang gearbeitet, aber jetzt
   reagiert er nicht mehr.
   Hier versuche ich zunächst den Rechner mit Magic SysRequest halbwegs
   geordnet neu zu starten und nachträglich zu analysieren.
   Falls möglich, werte ich die mit SysRequest gewonnenen Erkenntnisse aus.

*  Überlast, Swapping, Thrashing. Ich sehe oder höre, dass der Rechner
   intensiv arbeitet.
   Trotzdem reagiert er sehr langsam.
   Auf Grund von Timeouts kann ich mich nicht einmal mehr anmelden, in einer
   angemeldeten Shell bekomme ich kein Programm gestartet.
   Wenn ich die Last nicht auf anderem Weg vom Rechner nehmen kann, bleibt mir
   auch hier nur, den Rechner neu zu starten.
   Anschließend versuche ich zu ermitteln, was die Überlast ausgelöst hatte.

*  Ausfälle bei virtuellen Maschinen.
   Das sind oft die gleichen Fehler wie bei "echten" Maschinen aus Blech.
   Hinzu kommen Probleme mit der Virtualisierungsschicht.
   Im Gegenzug bekomme ich mehr Diagnosemöglichkeiten an die Hand.

   Hier gibt es neben dem Totalausfall des Gastsystems noch die Möglichkeit,
   das das Wirtssystem ausgefallen ist. Diese Fehler behandle ich, wie oben
   beschrieben.

   Bei den Gastsystemen sind meine Optionen abhängig von der verwendeten
   Virtualisierungslösung und deren Diagnosewerkzeugen.
   Manchmal kann ich einfach die Festplattenpartitionen des Gastsystems im
   Hostsystem oder einem anderen Gastsystem einhängen und dann dort untersuchen.
   Damit stehen mir dann zusätzliche Werkzeuge zur Verfügung.

## Bootprobleme {#sec-lokal-bootprobleme}

Eine Art von Totalausfall eines Linux-Servers sind Bootprobleme. Wenn der
Rechner gar nicht erst startet, kann er seine Dienste nicht erfüllen, von
Performance gar nicht zu reden.

Zwar treten Bootprobleme eher selten auf, wenn sie erstmal da sind, bekommen
sie aber die volle Konzentration, weil eben wirklich ``nichts mehr geht``.

Um die Bootprobleme eines kaputten Systems diagnostizieren und beheben zu
können, muss ich das Verhalten eines gesunden Systems beim Startvorgang
kennen. Dieses zeichnet sich durch verschiedene Phasen mit unterschiedlicher
Zuständigkeit und dementsprechend unterschiedlicher Herangehensweise aus. Grob
kann man den Startvorgang eines Linux-Rechners in die folgenden Phasen
einteilen:

1.  Die Firmware des Rechners initialisiert die Hardware. Das ist bei
    einem PC zum Beispiel gekennzeichnet durch die verschiedenen
    BIOS-Meldungen. Eingriffe an dieser Stelle sind abhängig von der konkreten
    Hardware und nicht explizit Thema dieses Buches, obwohl diese das
    Verhalten des Linux-Systems sehr wohl beeinflussen.
2.  Die Firmware lädt und startet den Bootmanager (Grub, Lilo, ...). Je
    nach Bootmanager habe ich hier eventuell bereits die Möglichkeit, das
    spätere Verhalten des Linux-Systems direkt (zum Beispiel durch
    Kernel-Optionen) zu steuern.
3.  Der Bootloader als Bestandteil des Bootmanagers lädt den Kernel und
    das Initramfs und startet den Kernel. Hier werden Änderungen, die ich
    ebentuell im Bootmanager vorgenommen habe, zum ersten Mal wirksam.
4.  Der Kernel nimmt die wichtsten Systemkomponenten in Betrieb und
    startet ein Initialisierungsskript vom Initramfs. In dieser Phase kann ich
    nicht eingreifen, nur beobachten.
5.  Das Initialisierungsskript vom Initramfs lädt Treiber, überprüft das
    Root-Dateisystem und hängt dieses ein. Bei Problemen startet es eine
    Shell, in der das Problem interaktiv bearbeitet werden kann.
6.  Sobald das Root-Dateisystem als rootfs eingehängt ist, übergibt das
    Initialisierungsskript an das Programm an den Initd des Systems, der
    weitere Dateisysteme einhängt, Hintergrunddienste und Anmeldeprogramme
    startet. Wenn dieser auf Probleme mit Dateisystemen trifft, bietet er an,
    das Problem in einer Shell (nach Eingabe des Root-Kennworts) zu lösen,
    oder einen Neustart zu versuchen.
7.  Sobald ich mich am System regulär anmelden kann (getty, sshd, xdm,
    ...) kann ich den Rechner benutzen, auch wenn eventuell noch
    Systemteile initialisiert werden.

### Startphasen des Rechners identifizieren

Da ich, je nachdem in welcher Phase ein Problem auftritt, auf verschiedene
Weise an die Lösung des Problems herangehe, ist es wichtig, dass ich die
einzelnen Phasen erkennen und auseinander halten kann.

Dazu muss ich gegebenenfalls die nötigen Startinformationen erst freilegen.
Das können zum einen BIOS-Einstellungen sein, die abhängig von der Hard- und
Firmware und daher nicht Thema dieses Buches sind. Gerade viele moderne
Linux-Distributionen verstecken die Informationen, die Linux-Kernel und System
auf den Bildschirm schicken. Mit dem Bootmanager kann ich die betreffenden
Kerneloptionen ändern, um mehr Informationen zu erhalten. So entferne ich zum
Beispiel die folgenden Kerneloptionen:

*  `quiet`

*  `rhgb` bei Fedora oder Red Hat

*  `splash` bei Ubuntu

*  `splash=silent` bei OpenSuse

*  `vt.handoff=7` bei Ubuntu 11.10

Außerdem gibt es bei Grub2 eventuell in der Konfiguration die Zeile

    set gfxpayload=$linux_gfx_mode

die ich ändere in

    set gfxpayload=text

Habe ich die Bootinformationen sichtbar gemacht, kann ich mit Ihrer Hilfe den
Bootvorgang besser diagnostizieren und dabei die einzelnen Phasen
unterscheiden.

Nach den Firmwaremeldungen meldet sich der Bootmanager. Manchmal nur mit einer
kurzen Zeile, die den Namen des Bootmanagers (Grub, Lilo, ...) enthält, oft
aber auch mit einem Menü, aus dem ich das System, welches starten soll,
auswählen kann.
Fehlt das Menü, kann ich es mit `<ESC>` oder `<TAB>` hervorrufen,
bevor der Bootloader den Kernel lädt.

Die Meldung 'Loading Kernel' oder 'Loading initial ramdisk' zeigt den Übergang
von Phase 2 zu Phase 3 an.
Diese wird gefolgt von Dutzenden Kernelmeldungen zur Hardware-Initialisierung,
die von der Kernel-Option `quiet` unterdrückt worden wären.

Eine Meldung wie 'dracut: dracut ...' bei Fedora oder 'Write protecting the
kernel ...' und Meldungen von Udev zeigen an, dass der Kernel geladen ist
und die Skripte des Initramfs die Arbeit übernommen haben.

Meldungen wie 'Switching root' und 'Welcome to xyz Linux' zeigen an, dass die
Skripte des Initramfs fertig sind und der Init-Daemon des Systems übernimmt.
Sobald ein Konsole-Login oder grafisches Login präsentiert wird und ich mich
anmelden kann, betrachte ich den Systemstart als abgeschlossen, auch wenn im
Hintergrund noch der eine oder andere Dienst gestartet wird.

Mit dem Wissen um die Übergänge zwischen den einzelnen Phasen des
Startvorgangs kann ich mich nun den möglichen Problemen in den einzelnen
Bootphasen zu wenden.

Da Probleme mit der Firmware abhängig von der konkreten Hardware sind, werden
diese hier nicht weiter behandelt. Wichtig für die Fehlersuche ist trotzdem
ein grundlegendes Verständnis der Einstellmöglichkeiten in der Firmware (dem
BIOS beim PC), weil diese Einfluss auf das Verhalten des Kernels haben können.

### Probleme mit dem Bootmanager

Bleibt nach den Selbsstests der Firmware der Bildschirm schwarz, kommt eine
Meldung wie 'Operating system not found' oder erscheinen Fehlermeldungen von
Grub, Lilo oder welcher Bootmanager vorhanden ist, haben wir ein Problem mit
dem Bootmanager.

Eine mögliche Ursache ist, dass die Firmware den Bootmanager nicht gefunden
hat. Das kann auf einen defekten Master Boot Record (MBR)hindeuten. Möglich
ist auch, dass der Bootloader nicht im Master Boot Record, sondern in einer
Partition installiert wurde und diese nicht als bootfähig in der
Partitionstabelle gekennzeichnet wurde. Möglicherweise wurde die
Bootreihenfolge im BIOS geändert oder durch einen zusätzlich angesteckten
Datenträger durcheinander gebracht. Eventuell ist die Installation des
Bootmanagers beschädigt. Grub2 zum Beispiel speichert einen Teil des
Bootmanagers direkt hinter dem MBR vor der ersten Partition. Eventuell ist
auch die Partition beziehungsweise das Dateisystem, welches weitere Teile des
Bootmanagers enthält, beeschädigt.

A> #### Grub-Shell
A> 
A> Bei Bootproblemen kann ich den Rechner vielleicht mit der Grub-Shell starten.
A> In dieser lande ich automatisch, wenn Grub seine Dateien nicht finden kann.
A> Alternativ gelange ich dorthin, wenn ich im Auswahlmenü mit der Taste `c` die
A> Konsole oder mit `e` den Editor aufrufe.
A> Mit `help` bekomme ich alle verfügbaren Befehle angezeigt, mit `help Befehl`
A> die Hilfe zu einem Befehl.
A> Mit der Tabulatortaste greife ich auf die automatische Vervollständigung zu,
A> wo diese zur Verfügung steht.
A> Mit `boot` kann ich den Rechner schließlich mit meinen Änderungen starten
A> lassen beziehungsweise mit `reboot` ganz von vorn anfangen.
A> Das ist praktisch, wenn ich eigentlich in das BIOS wollte, aber den rechten
A> Zeitpunkt verpasst habe.
A> 
A> Wichtig ist, falls ich den Rechner mit meinen Änderungen starten konnte, dass
A> ich die Änderungen permanent in der Grub-Konfiguration ablege.
A> Das ist distributionsabhängig, die Anleitung der entsprechenden Distribution
A> hilft mir da weiter.

Wenn eine Vertauschung der Bootreihenfolge und ein zusätzlicher Datenträger
ausgeschlossen werden können, starte ich den Rechner von einem Live- oder
Rescue-System auf einer CD-ROM oder einem USB-Stick. Dann kann ich die
Systemplatte mit allen zur Verfügung stehenden Mitteln und Werkzeugen
überprüfen.

*   Ist die Partitionstabelle defekt?

*   Sind die Dateisysteme in Ordnung?

Außerdem kann ich den Bootmanager neu installieren. Das mache ich am besten
aus dem System auf der Festplatte heraus. Dazu hänge ich die Partitionen an
dern korrekten Mountpoints ein und wechsle mit `chroot` in das System.

### Probleme beim Start des Kernels

Nach dem der Bootloader den Kernel startet, bleibt das System stehen oder
startet neu. Das passiert mitunter nach einem BIOS- oder Kernel-Upgrade oder
nach Änderungen in den BIOS-Einstellungen. Daher versuche ich
herauszubekommen, ob eine dieser Bedingungen hier vorliegt und ob ich diese
möglicherweise rückgängig machen kann.

Testweise kann ich alle Peripherie (USB, seriell, parallel, ...) und oder
alle nicht zum Booten benötigten Komponenten entfernen. Falls das System dann
startet, füge ich nach die einzelnen Komponenten wieder hinzu, bis der Fehler
wieder auftritt.

Als nächstes kann ich systematisch die verschiedenen Hardware-relevanten
Kernelparameter durchprobieren. Dann genauso die BIOS-Einstellungen und
schließlich die Kombination beider.

### Abbruch des Kernels

Nach Ausgabe einiger Zeilen bleibt der Kernel eventuell mit der Meldung
'Kernel panic' stehen.

Das kann an einer fehlerhaften Kernkomponente, wie Prozessor, Speicher,
Chipsatz auf dem Mainboard leigen. Insbesondere, wenn der Kernel gleich nach
dem Anlaufen ohne Panic abbricht. In diesem Fall muss ich mit den
Kernelparametern experimentieren. Eventuell hilft eine Internet-Suche nach der
gleichen Hardware in Zusammenhang mit Problemen bei Linux.

Bei Problemen mit Treibern versuche ich meist die folgenden Strategien:

*   Internet-Suche mit den Informationen aus den letzten Zeilen oberhalb
    der Abbruchmeldung

*   Suche in der Kernel-Dokumentation zu Parametern für diesen Treiber.
    Bei modularen Treibern hilft auch `modinfo -p treibername` für eine
    erste Übersicht.

*   Mit der Kerneloption `modulename.disable=1` kann ich das Laden
    diesen Treibers unterbinden.

Wenn bereits nach einigen Zeilen der Bildschirm schwarz wird oder das System
neu startet, könnte es auch am Grafiktreiber liegen, falls die Zeilen davor
nicht auf andere Ursachen hindeuten.

Als erstes kann ich den Standard-VGA-Textmodus mit dem Kernelparameter
`nomodeset` einschalten. Falls das funktioniert, könnte es an einer
fehlerhaften Erkennung des Monitors liegen. Mit `video=1024x768-24@75`
gebe ich eine Auflösung von 1024x768 bei 24 Bit Farbtiefe und einer
Bildwiederholrate von 75 Hertz vor. Funktioniert auch das, kann ich den
Parameter so ändern, das er zu meinem Monitor passt. Sitzen die Probleme
tiefe, kann ich versuchen, die Debug-Informationen des Direct Rendering
Manager (DRM) des Kernels mittels des Kernelparameters `drm.debug=14`
auszuwerten. Auch die DRM-Treiber bieten Optionen, mit denen ich
experimentieren kann. Auf diese gehe ich an dieser Stelle jedoch nicht weiter
ein, da das zu weit ab vom Thema führen würde.

### Kernel-Panik

Der Kernel schreibt eine Zeile mit `Kernel panic` und arbeitet nicht mehr
weiter. In dieser Zeile folgt noch eine Kurzbeschreibung des Problems.

#### Attempted to kill init

Der Prozess mit PID 1 ist abgestürzt. Das könnte durch ein beschädigtes
Initramfs verursacht sein oder, falls das System schon mit dem
Root-Dateisystem arbeitet, durch beschädigte oder fehlende Dateien auf eben
diesem.

Zur Lösung starte ich den Rechner mit einem Live- oder Rescue-System,
ermittele die genaue Ursache und repariere diese.

Alternativ, falls ich gerade nicht von einem anderen Medium starten kann,
starte ich mit dem Kernelparameter `init=/bin/sh` eine Shell anstelle des
Init-Daemons und muss dann die Initialisierungen von Hand erledigen, bevor ich
das System reparieren kann.

#### No init found ...

Der Kernel hat das Programm, das er als erstes starten soll, nicht gefunden.
Ich behandle das Problem ähnlich wie das vorige und starte ein Live- oder
Rescue-System beziehungsweise gebe mit der Option `init=...` ein
anderes Programm an.

#### Fatal Exception / Aiee, Killing Interrupt Handler

Diese Probleme können vielfältige Ursachen haben. Meist finden sich Hinweise
ein paar Zeilen weiter oben. Steht dort ein `Oops`, hat der Kernel ein
Problem erkannt und zunächst versucht weiter zu arbeiten.

Ein `Oops` ist eine Abweichung vom korrekten Verhalten des Kernels, die
eine Fehlermeldung produziert, welche via syslog protokolliert werden kann (im
Gegensatz zu einem Kernel-Panik, bei dem kein Logging mehr möglich ist). Wenn
der Kernel ein Problem entdeckt, gibt er eine `Oops` Nachricht aus und
beendet den verursachenden Prozess. Die offizielle Dokumentation dazu findet
sich in der Datei oops_tracing.txt bei der Kernel-Dokumentation. Sobald ein
System einen `Oops` erlebt hat, arbeiten einige interne Ressourcen nicht
mehr korrekt. Das wiederum kann zu weiteren `Oops` und schließlich zum
Kernel-Panik führen. Daher ist es bei der Analyse wichtig, sich zunächst auf
den ersten `Oops` zu konzentrieren. Dabei helfen Internet-Suchen, die
Dokumentation und gegebenenfalls eine Anfrage auf der entsprechenden
Mailingliste.

#### not syncing: VFS: Unable to mount rootfs on ...

Der Kernel findet sein Root-Dateisystem nicht. Das kann an einem fehlenden
oder defekten Initramfs liegen. Oder das in der Kernel-Kommandozeile genannte
Dateisystem ist nicht erreichbar.

Als erstes sehe ich mir hier die Booloader-Konfiguration genau an. Ist das
Initramfs korrekt angegeben? Ist das Root-Dateisystem korrekt angegeben? Ist
(zum Beispiel bei NFS-Rootfs) der Server mit dem Rootfs erreichbar und auf ihm
das Dateisystem mit dem entsprechenden Protokoll? Eventuell muss ich den
Rechner mit einem Live- oder Rescue-System starten, um das Problem genauer
einzugrenzen und zu beheben.

### Probleme im Initramfs

Bekomme ich Meldungen wie `dracut: Warning: ...` (Fedora) oder
`Gave up waiting for root device` (Debian, Ubuntu) und anschließend einen
Shell-Prompt, dann haben die Skripts des Initramfs das Root-Dateisystem nicht
gefunden.

Mit `dmesg|less` kann ich mir die Kernelmeldungen noch einmal ansehen.
Dabei suche ich nach Meldungen zu den Speichersystemen. Habe ich less nicht
zur Verfügung, kann ich mit `<Shift>-<Bild auf/ab>` blättern. Dabei
überprüfe ich, ob die Systemplatte gefunden wurde (beziehungsweise bei
NFS-Root der Netzwerkadapter).

Falls das Root-Dateisystem als UUID oder Label spezifiziert wurde, kann ich
mit `blkid` alle erkannten Label und UUIDs ausgeben lassen. Unter /proc
und /sys kann ich weitere Informationen zu erkannten Hardware finden. So
liefert mir zum Beispiel /proc/mdstat Informationen zu einem Software-RAID.

### Udev

Kurz nachdem Udev gestartet wurde, bleibt das System hängen.

In diesem Fall helfen mir die Kerneloptionen `udev.log_priority=info` und
`udev.children-max=1`. Damit startet Udev nur einen Kind-Prozess und gibt
eine Reihe von zusätzlichen Informationen aus. Habe ich damit ein
problematisches Modul identifiziert, kann ich dieses mit
`modulename.disable=1` in den Kernel-Optionen deaktivieren.

### Stopp bei der Dateisystemüberprüfung

    ...
    error checking filesystem
    ...
    Give root password for rescue shell or type Control-D for reboot.

Der Init-Daemon hat ein Problem beim Dateisystemcheck erkannt und bietet mir
an, dieses in einer Shell zu beheben. Dazu muss ich das Rootkennwort wissen.

Ein Neustart mit Steuerung-D wird mir nicht weiterhelfen, da wir es hier mit
einem schwerwiegenden Problem im Dateisystem zu tun haben und beim nächsten
Start genauso weit kommen würden.

Ich brauche also das Rootkennwort oder eine andere Möglichkeit, eine
Root-Shell auf dem Rechner zu bekommen (wie zum Beispiel die Option
`init=/bin/sh`).

A> #### der erste Prozess: init
A> 
A> Bei der Erläuterung des [UNIX-Prozessmodelles](#sec-unix-prozessmodell) hatte
A> ich erwähnt, dass der Lebenszyklus aller Prozesse bis auf den ersten mit dem
A> `fork()` Systemaufruf beginnt.
A> Dieser erste Prozess wird vom Kernel gestartet und führt traditionell das
A> Programm */sbin/init* aus.
A> Dieses Programm liest seine Konfiguration ein und startet entsprechend dieser
A> andere Prozesse, welche die Hardware initialisieren oder Dienste
A> bereitstellen.
A> Mit dem Kernelparameter `init`, denn der Bootlader an den Kernel übergibt,
A> kann ich ein anderes Programm bestimmen, dass als erstes gestartet wird.
A> Mit `init=/bin/sh` lege ich zum Beispiel die Standard-Shell als Startprogramm
A> fest.
A> Das ist im Normalfall nicht sinnvoll, da diese Shell keinerlei
A> Initialisierung vornimmt und somit keine Dateisysteme (ausser dem
A> Root-Dateisystem) einhängt und auch sonst keine Dienste startet.
A> In Notfällen, wenn *init* beschädigt ist, oder ich das Kennwort von *root*
A> nicht weiss, kann ich aber die nötigen Initialisierungen selbst vornehmen
A> und damit das System wieder benutzbar machen.

Dann starte ich die Dateisystemüberprüfung und -reparatur von Hand für alle
benötigten Dateisysteme und starte den Rechner anschließend neu. Läuft deer
Rechner wieder, muss ich nun noch schauen, ob und gegebenenfalls welche
Dateien ich aus dem Backup ersetzen muss.

Problem erkannt, Problem gelöst.

Oder?

Habe ich den Rechner selbst aufgesetzt und mir notiert, welche Partitionen mit
welchem Dateisystem wo eingehängt sind, dann ist es wirklich so einfach. Bei
einem fremden Rechner, oder wenn es ein älteres Gerät ist, zu dem ich keine
Aufzeichnungen habe, dann muss ich noch herausfinden, welche Partitionen ich
mit fsck überprüfen muss.

In der Bildschirmmeldung steht, bei welcher Partition die automatische
Überprüfung aufgegeben hat. Nötigenfalls kann ich mit Shift-PgUp nach oben
blättern, wenn die Meldung schon nach oben rausgerollt ist.

Aber je nach Alter des Rechners und verwendeter Linux Distribution steht dann
da entweder ein Gerätename wie /dev/sda1, ein Label wie ``rootfs'' oder eine
UUID. Und das fsck-Programm erwartet als Angabe einen Gerätenamen. Beim Label
und bei der UUID muss ich nun die Zuordnung herausbekommen.

Die Datei /etc/fstab kann ich als erste Anlaufstelle nehmen, die mir Hinweise
auf die Partition und das Dateisystem gibt. Diese benötige ich, um das
richtige Programm für die Dateisystemüberprüfung zu verwenden. Allerdings
stehen in /etc/fstab auch nur die Label beziehungsweise UUID, die ich aus der
Konsolenmeldung bereits kenne.

Mit den verschiedenen Diskpartitionierungsprogrammen kann ich mir die
Partitionen ausgeben lassen. Insbesondere cfdisk ist hier nützlich, weil es
vergebene Label anzeigt, so dass ich sie einem Gerätenamen zuordnen kann. Bei
UUID hilft es mir leider nicht.

Das Programm blkid zeigt mir sowohl Label als auch UUIDs an:

    # blkid
    /dev/sda1: UUID="f779141e-e3b1-4521-9333-9dde9de0b64f" TYPE="ext3" 
    /dev/sda5: LABEL="swap" UUID="bc3aa59f-55fc-460d-86ef-cf72ce99b70b" TYPE="swap" 

Alternativ kann ich die Gerätedateien mit findfs bestimmen:

    # findfs LABEL=swap
    /dev/sda5
    # findfs UUID=f779141e-e3b1-4521-9333-9dde9de0b64f
    /dev/sda1

Habe ich keines dieser Programme, aber file, dann kann ich mir auch wie folgt
behelfen (Umbruch ist von mir eingefügt):

    # dd if=/dev/sda1 of=sda1 bs=4096 count=1
    1+0 records in
    1+0 records out
    4096 bytes (4.1 kB) copied, 0.000275722 s, 14.9 MB/s
    # dd if=/dev/sda5 of=sda5 bs=4096 count=1
    1+0 records in
    1+0 records out
    4096 bytes (4.1 kB) copied, 0.000103642 s, 39.5 MB/s
    # file sda1 sda5
    sda1: Linux rev 1.0 ext3 filesystem data, \
    UUID=f779141e-e3b1-4521-9333-9dde9de0b64f (needs journal recovery) \
    (large files)
    sda5: Linux/i386 swap file (new style), version 1 (4K pages), \
    size 1319329 pages, LABEL=swap, UUID=bc3aa59f-55fc-460d-86ef-cf72ce99b70b

Da file bei der direkten Abfrage der Gerätedateien nur deren Typ angeben
würde, kopiere ich den ersten Block des Dateisystems in eine Datei und lasse
diese dann von file analysieren.

## Bootprobleme bei virtuellen Maschinen {#sec-lokal-bootprobleme-vm}

### Partitionen von Festplattenimages einhängen {#sec-mount-hdimage-partition}

Bei Problemen mit dem Start von virtuellen Maschinen ist es oft notwendig,
wenigstens die Bootpartition der betroffenen VM zu untersuchen.

Manchmal kann
ich dazu das Festplattenimage der defekten VM einfach einer anderen VM
zuordnen und es von dieser aus untersuchen. Das erscheint zumindest bei
grafischen Oberflächen für die Administration als der einfachste Weg.
Allerdings muss ich dann immer zwischen dem Hostsystem beziehungsweise der
Administrationsoberfläche und der VM, mit der ich das Festplattenimage
untersuche wechseln und verliere viel Zeit beim Zuordnen, Ein- und Aushängen
und den Startversuchen.

Besser ist in meinen Augen, die Partitionen des betroffenen Images gleich im
Hostsystem für die Analyse und Störungsbeseitigung einzubinden und die
Vorteile der Shell für zügiges Arbeiten zu nutzen.

Nun habe ich aber das Problem, dass ich auf dem Hostsystem nicht, wie bei den
eigenen Festplatten, die Partitionen direkt zur Verfügung habe, sondern nur
das Komplettimage der Festplatte für die VM. Und dieses beginnt nicht mit dem
Dateisystem sondern mit der Partitionstabelle. Um die gewünschte Partition
einzubinden, muss ich dem Mount-Befehl den Offset der Partition mitgeben.

Den Offset kann ich mit dem Programm fdisk bestimmen. Dieses listet mit der
Option `-l` die Partitionen und deren Offsets auf. Da wir letztere genau
bestimmen müssen, verwenden wir zusätzlich die Option `-u`, damit fdisk
die Offsets als Anzahl von Sektoren zu je 512 Byte ausgibt:

    # fdisk -l -u /dev/camion/ssh3 

    Disk /dev/camion/ssh3: 4294 MB, 4294967296 bytes
    255 heads, 63 sectors/track, 522 cylinders, total 8388608 sectors
    Units = sectors of 1 * 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 4096 bytes
    I/O size (minimum/optimal): 4096 bytes / 4096 bytes
    Disk identifier: 0x000c48f7

                Device Boot      Start         End      Blocks   Id  System
    /dev/camion/ssh3p1            2048     7706623     3852288   83  Linux
    /dev/camion/ssh3p2         7708670     8386559      338945    5  Extended
    Partition 2 does not start on physical sector boundary.
    /dev/camion/ssh3p5         7708672     8386559      338944   82  Linux swap

Der Offset für die Systempartition `ssh3p1` ist $512 * 2048$, also
1048576. Damit kann ich diese Partition im Hostsystem wie folgt einhängen:

    # mount /dev/camion/ssh3 /tmp/mnt -o loop,offset=1048576

Wenn ich fertig bin, hänge ich die Partition normal mit umount wieder aus.

Wichtig ist, dass ich die Partition im Hostsystem nur einhänge, wenn die VM
nicht läuft. Das ist beim Untersuchen von Bootproblemen meist gegeben. Bei
laufenden VMs habe ich mit LVM die Möglichkeit, einen Snapshot anzufertigen
und diesen Snapshot nur-lesend einzuhängen. Dabei muss ich aber bedenken, dass
Dateien, die in der VM geöffnet waren, eventuell in einem inkonsistenten
Zustand sind. Für Backups kann ich jedoch die VM kurz runterfahren, den
Snapshot anlegen und die VM gleich wieder starten.

A> #### Reparatur mit chroot
A> 
A> Manchmal geht die Reparatur eines Systems einfacher, wenn ich den Datenträger
A> in einem anderen anderen System (Live-System von DVD oder Reparatursystem bei
A> einer VM) einhänge und mit `chroot` in das defekte System wechsle.
A> Damit die chroot-Umgebung funktioniert, benötige ich mehr als nur das
A> Dateisystem.
A> Viele Programme greifen auf die Informationen des *proc*, *dev* und *sys*
A> Dateisystems zurück, die ich ohne Vorkehrungen nicht in der chroot-Umgebung
A> habe.
A> Darum gehe ich wie folgt vor:
A> 
A>     # mount /dev/sdXY /mnt/rescue
A>     # mount /dev/sdXZ /mnt/rescue/boot
A>     # mount -o bind /dev /mnt/rescue/dev
A>     # mount -o bind /sys /mnt/rescue/sys
A>     # mount -o bind /proc /mnt/rescue/proc
A>     # chroot /mnt/rescue
A> 
A> Dann kann ich zum Beispiel aus der chroot-Umgebung heraus den Bootlader
A> *grub* mit `grub-install /dev/sdX` erneut im MBR installieren.
A> Oder mit `update-grub` die Steuerdatei neu zusammensetzen lassen.

## Fehlersuche beim Initramfs {#sec-lokal-initramfs}

Einen wesentlichen Einfluss auf den Systemstart hat das Initramfs.
Das ist ein kleines, komprimiertes Dateisystem, das zusammen mit dem Kernel
vom Bootloader in den Hauptspeicher geladen wird und dann für das Laden beim
Start benötigter Treiber und deren Konfiguration zuständig ist.
Damit ist es möglich, einen modularen Kernel, wie er bei den beisten
Distributionen heutzutage verwendet wird, an unterschiedliche Hardware
anzupassen.
Somit ist es nur noch in seltenen Fällen nötig, einen Kernel speziell für
eine bestimmte Maschine zu kompilieren.

Im Rahmen der Fehlersuche beschäftige ich mich mit dem Initramfs eigentlich
nur, wenn ein System nicht startet. Dabei interessieren mich vor allem
folgende Fragen:

*   Wie funktioniert das Initramfs?

*   Wie kann ich Fehler im Initramfs finden?

*   Wie mache ich eine gefundene Lösung permanent?

### Wie funktioniert das Initramfs?

Beim Systemstart lädt der Bootloader sowohl den Kernel als auch das
komprimierte Initramfs in den Hauptspeicher.
Anschließend startet er den Kernel und übergibt dabei die Kerneloptionen.
Der Kernel selbst reserviert einen Teil des Hauptspeichers und erzeugt darin
ein virtuelles RAM-Dateisystem.
In dieses entpackt er das komprimierte Initramfs.
Anschließend startet er das Skript init in der Wurzel der virtuellen RAM-Disk.
Alles weitere kann durch Analyse dieses Skripts erschlossen werden und ist von
Distribution zu Distribution verschieden.

### Wie kann ich Fehler im Initramfs finden?

Ich setze bei der Fehlersuche im Initramfs an, wenn ich genau weiß, dass der
Fehler nach dem Start des init Skripts und vor dem Einhängen des eigentlichen
Root-Dateisystems passiert.

Bei den automatisch erzeugten Initramfs der verschiedenen Distributionen lande
ich bei Problemen manchmal in einer Shell und kann darin dann versuchen, mit
den Werkzeugen des Initramfs das Problem zu analysieren.
Da auf der Initramfs fast immer busybox vorhanden ist, stehen mir hier oft
mehr Werkzeuge zur Verfügung, als auf den ersten Blick ersichtlich ist.

Bekomme ich keine Shell oder fehlt mir ein Werkzeug, dann komme ich nicht
umhin, das Initramfs zu modifizieren.
Dabei kann ich das aktuelle als Ausgangsbasis nehmen.

Bei Debian-basierten Distributionen ist das Initramfs ein komprimiertes
cpio-Archiv im Verzeichnis /boot.
Dieses kann ich wie folgt entpacken:

    # zcat /boot/initrd.img-$(uname -r) | cpio -idmv

Nun kann ich in den entpackten Verzeichnissen die Skripts anpassen und
gegebenenfalls weitere Programme installieren.
Dabei muss ich aber darauf achten, dass alle benötigten Bibliotheken vorhanden
sind.
Das kann ich mit chroot überprüfen.
Anschließend baue ich ein neues Initramfs:

    # find . | cpio -oH newc | gzip -c > /boot/initrd-test.img

Anschließend muss ich dem Bootloader klarmachen, dass er das modifizierte
Initramfs laden soll.
Bei Grup ist das kein Problem, da ich die Booteinträge während des
Bootvorgangs modifizieren kann.
Bei anderen Bootloadern muss ich diesen gegebenenfalls neu konfigurieren
und/oder installieren.
Bei PXELINUX passe ich einfach die Datei im Verzeichnis pxelinux.cfg auf dem
TFTP-Server an, so dass das modifizierte Initramfs geladen wird.

### Wie mache ich eine gefundene Lösung permanent?

Habe ich im vorigen Schritt eine Lösung für mein Problem gefunden, dann will
ich diese dauerhaft im System verankern.
Hier kommt aber das Problem in's Spiel, dass bei jedem Kernelupdate oder der
Installation von Kernelmodulen automatisch ein neues Initramfs erzeugt wird.
Dabei werden meine Änderungen ignoriert, wenn ich sie nicht an den richtigen
Stellen unterbringe.

#### Permanente Initramfs-Modifikationen bei Debian GNU/Linux
Bei Debian und darauf basierenden Distributionen sind das:

*   /etc/initramfs-tools/scripts - für eigene Skripts

*   /usr/share/initramfs-tools/init - falls ich das init-Skript selbst
    modifizieren muss

*   /etc/initramfs-tools/modules - für zusätzliche Module

*   /etc/modprobe.d - für Moduloptionen

*   /etc/udev/rules.d - für zusätzliche udev-Regeln

Nachdem ich die Änderungen eingearbeitet habe, erzeuge ich ein Initramfs nach
Art des Hauses:

    # update-initramfs -k $(uname -r) -u

Anschließend starte ich den Rechner neu und verifiziere meine Änderungen.

## Ein hängendes System mit Magic SysRequest neu starten {#sec-lokal-total-magic-sysrq}

Einem Totalausfall recht nahe kommt der Zustand, wenn ein oder mehrere
Prozesse so viele Ressourcen belegen, dass andere Prozesse kaum noch zum Zuge
kommen.

Erkennbar ist zum Beispiel daran, dass Netzverbindungen scheinbar noch
funktioniernieren, der Rechner auf Ping antwortet, die Dienste des Rechners
eventuell noch neue Verbindungen annehmen aber keine Antworten senden. An der
Konsole kann ich beim Login noch Benutzername und Kennwort eingeben, aber die
Prüfung des Kennworts dauert so lange, dass sie mitunter durch Timeout
abgebrochen wird. In einer Shell kann ich Befehle absetzen, aber ein Befehle,
der einen neuen Prozess startet, dauert ewig.

Habe ich bereits einen Systemmonitor laufen, zeigt dieser mir meist mindestens
eines dieser Symptome: die CPUs sind 100 Prozent ausgelastet, der
Hauptspeicher ist voll und das System lagert ständig Speicherseiten aus und
die Systemlast (die Anzahl der Prozesse, die auf Rechenzeit warten) ist sehr
hoch.

Mit normalen Mitteln werde ich dieser Situation nicht mehr Herr, da ich gar
nicht genug Einfluss nehmen kann. Als letzter Ausweg bliebe hier nur ein
hartes Ausschalten des Systems mit den entsprechenden Folgen, wie Fehlern im
Dateisystem und beschädigten Dateien. Bei einer sehr großen Platte würde
allein der Dateisystemcheck sehr lange dauern, bis das System wieder
einsatzfähig wäre.

Hier hilft mir der Magic SysRequest, wenn ich Zugang zur Konsole habe. Der
Magic SysRequest besteht aus der Tastenkombination `<Alt>` plus
`<Druck>` plus einer weiteren Taste, die eine bestimmte Funktion auslöst.

Um ein hängendes System halbwegs geordnet neu zu starten, halte ich
`<Alt>` und `<Druck>` gedrückt und drücke dann nacheinander, mit
jeweils einigen Sekunden Abstand die Tasten `r`, `e`, `i`,
`s`, `u`, `b`. Als Eselsbrücke kann ich mir das Wort busier
(geschäftiger) rückwärts merken.

Die genannten Schlüsseltasten bewirken das folgende:

| r | X11 die Tastatur entziehen                                  |
| e | alle Prozesse außer Prozess 1 (init) mit SIGTERM beenden    |
| i | alle Prozesse außer Prozess 1 (init) mit SIGKILL abschießen |
| s | alle Dateisystempuffer auf Platte schreiben (sync)          |
| u | alle Dateisystempuffer nur-lesend einhängen                 |
| b | Neustart                                                    |

Insbesondere die letzten drei Funktionen bewirken, dass das Dateisystem vor
dem Neustart sauber ausgehängt wird, so dass der Dateisystemcheck zumindest
von daher keine Fehler finden sollte. Mit dem zweiten Befehl (`e`) haben
die Prozesse zumindest die Chance, ihre geöffneten Dateien sauber zu
schließen. Dazu ist die Pause von einigen Sekunden vor dem nächsten Aufruf
notwendig.

Außer diesen sechs Funktionen bietet der Magic SysRequest noch weitere, deren
Beschreibung sich in der Datei sysrq.txt in der Kerneldokumentation findet.

Damit Magic SysRequest überhaupt zur Verfügung steht, muss dieses Feature im
Kernel kompiliert sein. Das ist vermutlich bei den Kerneln der meisten
Distributionen der Fall. Die entsprechende Konfigurationsvariable heisst
`CONFIG_MAGIC_SYSRQ`. Außerdem muss es aktiviert sein. Das kontrolliere
ich über die Datei /proc/sys/kernel/sysrq. Steht in dieser 0, ist Magic
SysRequest deaktiviert. Bei einer 1 sind alle Funktionen aktiv, bei einer
höheren Zahl erfahre ich aus der oben erwähnten Datei sysrq.txt, welche
Funktionen aktiv sind.

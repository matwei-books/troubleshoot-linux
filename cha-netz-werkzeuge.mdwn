
## samba, smbclient {#sec-netz-werkzeuge-smbclient}

Die Programme der Samba-Suite, insbesondere die zum Paket smbclient
zusammengefassten können bei der Fehlersuche in Zusammenhang mit MS Windows
Rechnern helfen.

Konkret handelt es sich dabei um die Programme

findsmb
: liefert Informationen über Maschinen, die auf SMB
  Namensanfragen in einem Netz antworten

rpcclient
: führt MS-RPC-Funktionen aus

smbcacls
: erfragt oder setzt ACLs auf NTFS Dateien oder Verzeichnissen

smbclient
: ist ein FTP-ähnliches Programm um auf SMB/CIFS Ressourcen
  auf Servern zuzugreifen

smbcquota
: dient zum Setzen und Abfragen der Quotas von NTFS Freigaben

smbget
: kann, ähnlich wget für HTTP, Dateien mit dem SMB-Protokoll herunterladen

smbtar
: ist ein Shellskript, mit dem SMB/CIFS Freigaben direkt auf
  UNIX Bandlaufwerke gesichert werden können

smbtree
: ist eine Art textbasierter SMB Netzwerkbrowser

smbspool
: kann eine Druckdatei an einen SMB Drucker senden

### findsmb

Aufruf:

    $ findsmb [ broadcast_address ]

Das Programm listet die IP Adresse, den NetBIOS-Namen, den Namen der
Arbeitsgruppe, des Betriebssystem und der SMB-Server-Version. Bei einem
lokalen Masterbrowser wird ein `+` hinzugefügt, bei einem Domain
Masterbrowser ein `*`.

### rpcclient

Das Programm wurde ursprünglich entwickelt, um die MS-RPC-Funktionalität in
Samba zu testen. Es ist möglich, damit Windows NT Clients von
UNIX-Arbeitsstationen aus zu administrieren. Und das Programm läßt sich gut
in Skripten verwenden.
  
Für nähere Informationen schaut man in die Handbuchseiten.

### smbclient

Das ist ein Client-Programm mit dem man auf SMB- oder CIFS-Ressourcen auf
Servern zugreifen kann. Das Interface ist ähnlich dem Programm `ftp`
für den Zugriff auf FTP-Server.

Damit kann man Dateien vom Server holen, auf dem Server ablegen und
Verzeichnisinformationen bekommen.

So kann man zum Beispiel mit dem Aufruf

    $ smbclient -L hostname -N

anonym alle Dienste des Servers `hostname` abfragen.
  
### smbget

Mit diesem  Programm kann man Dateien von Servern mit dem SMB-Protokoll
abholen, ähnlich wie mit dem Programm wget für das HTTP-Protokoll. Die
Dateien werden als smb-URL angegeben. Eine smb-URL sieht wie folgt aus:

    smb://[[[domain;]user[:pass]@]server[/share[/path[/file]]]]

Für Informationen zu den möglichen Optionen schaut man in die Handbuchseite.

### smbtree

Dieses Programm gibt einen Baum als Text auf, der alle bekannten Domains,
die Server in diesen Domains und die Freigaben auf diesen Servern auflistet.
Dieser sieht in etwa so aus:

    $ smbtree -N
    WORKGROUP1
      \\HOST1             host1 server (Samba, Ubuntu)
         \\HOST1\bilder         	
         \\HOST1\psc_1100 HEWLETT-PACKARD OFFICEJET REFLASH
         \\HOST1\IPC$     IPC Service (host1 server (Samba, Ubuntu))
         \\HOST1\print$   Printer Drivers
    WORKGROUP2
      \\HOST2             Samba 3.5.6
         \\HOST2\public
         \\HOST2\share
         \\HOST2\IPC$     IPC Service (Samba 3.5.6)

## iperf, nttcp, nuttcp {#sec-netz-werkzeuge-iperf}

In diesem Abschnitt stelle ich drei Werkzeuge kurz vor, mit denen auf
einfache Weise der Netzwerkdurchsatz für TCP und UDP gemessen werden kann.

Welches der drei ich zum Einsatz bringe, hängt im Wesentlichen von deer
Verfügbarkeit auf den beteiligten Rechnern ab und, bei mehreren, womit ich
die meisten Erfahrungen habe, da ich dann die Ergebnisse schneller
interpretieren kann.

Bei allen drei Werkzeugen brauche ich Zugang zu zwei Rechnern zwischen denen
ich messen will. Rootrechte sind nicht erforderlich.

Für genauere Informationen zu den einzelnen Programmen sind wie immer die
Handbuchseiten da.

### iperf

Bei diesem Programm, dass ich als Client und Server einsetzen kann, erzeugt
der Client den Traffic aus dem Hauptspeicher heraus und der Server verwirft
die angekommenen Daten, so dass nur der Durchsatz im Netz und das Handling
der Pakete im Hauptspeicher gemessen wird.

Ich kann einseitige Messungen machen und anschließend die Client- und
Serverrolle tauschen odeer zwei Verbindungen in den verschiedenen Richtungen
gleichzeitig messen lassen. Die verschiedenen Messergebnisse lassen
Rückschlüsse auf den Zustand des Netzes zu.

Normalerweise dauert eine Messung 10 Sekunden, während derer das Programm
versucht, so viele Daten wie möglich zu versenden und an deren Ende es das
Ergebnis ausgibt. Alternativ ist es möglich, die Datenmenge vorzugeben, so
dass die Dauer vom Durchsatz abhängt. Außerdem ist es möglich, die Zeitdauer
zu verändern und periodische Berichte ausgeben zu lassen anstelle eines
Berichts am Ende der Übertragung.

Bei UDP ist es möglich die Datenrate vorzugeben und damit das Verhalten des
Netzes bei unterschiedlich starker Auslastung zu untersuchen. Dazu kann man
beispielsweise sich mit Ping die RTT anzeigen lassen und dann das Netz
verschieden stark auslasten.

### nttcp

Das Programm nttcp, das auf dem älteren Programm ttcp basiert, kann die
Transferrate für TCP, UDP und UDP-Multicast messen.

Da es die Daten aus Puffern im Hauptspeicher über das Netzwerk sendet, fällt
am Rechner nur die Zeit zum Messen und die Zeit im Netzwerkcode im Kernel
in's Gewicht.

Zusätzlich zu den Transferdaten gibt das Programm auch die benötigte
CPU-Zeit aus.

Das Programm kann via inetd auf einem Rechner verfügbar gemacht werden, so
dass man sich dort dann nicht anmelden muss.

### nuttcp

Dieses Programm, dass auf nttcp basiert, misst ebenfalls den Durchsatz für
TCP und UDP und UDP-Multicast.

Es kann etwa die gleichen Daten wie nttcp anzeigen und außerdem die Verluste
bei UDP.

Wie bei nttcp gibt es einen Sender- und einen Empfängermodus. Zusätzlich
gibt es einen Servermodus, in dem es sowohl senden als auch empfangen kann.
Dieser ist insbesondere beim Aufruf via inetd nützlich. Die Ergebnisse
werden beim Client angezeigt.

Eine Besonderheit von nuttcp ist, dass es außer dem üblichen
memory-to-memory-Transfer auch disk-to-memory, memory-to-disk und
disk-to-disk messen kann. Damit ist es möglich Szenarien zu messen, die
realistischen Einsatzgebieten näher kommen.

## perl {#sec-netz-werkzeuge-perl}

Für knifflige Probleme, die ich mit den spezialisierten Werkzeugen nicht zu
fassen kriege und denen mit einfacher Shell-Programmierung auch nicht
beizukommen ist, benötige ich eine Programmiersprache, die mächtiger als die
Shell ist, mit der ich aber trotzdem mit wenig Aufwand ein passendes
Programm schreiben kann. Insbesondere durch die vielen verfügbaren Module
auf CPAN kann ich damit relativ schnell eine Speziallösung für vertrackte
Probleme zusammenbauen.

Perl hatte ich als Werkzeug bereits im Abschnitt über die Werkzeuge zur
lokalen Fehlersuche beschrieben. Durch die vielen einfach verfügbaren und
meist sehr gut getesteten und dokumentierten Module auf CPAN ist Perl auch
ein unentbehrliches Werkzeug für die Fehlersuche bei Netzwerkproblemen.

Das Perl Kochbuch [[CT2000](#bib-ct2000)] hatte ich bereits
erwähnt. Mit dessen Hilfe und den darin beschriebenen Modulen von CPAN war
es mir zum Beispiel möglich ein Testprogramm für ein Timing-Problem bei
einem Webservice zu schreiben.

### HTTP Injector

Vor einiger Zeit hatte ich ein Problem, bei dem 502-Fehler von
einem Webservice abhängig waren von der Zeit für die
Anfrage. Der Betreiber des Webservices stritt das ab und um das
Problem zu verifizieren benötigte ich die Möglichkeit HTTP-Anfragen gezielt
zu verzögern.
  
Ich kam mit Hilfe des Kochbuches zu folgendem Programm:

<<[http-injector.pl](code/http-injector.pl)

In den Zeilen 2-4 lade ich die benötigten Module. `Getopt::Long` ist
für die Verarbeitung der Kommandozeilenoptionen und sichert ab, dass ich mit
`--delay` einen Integerwert angebe. `IO::Socket` stellt die
Socketfunktionalität bereit, so dass ich diesen Socket wie eine Datei
verwenden kann. `Time::HiRes` stellt mir eine verbesserte
`sleep()` Funktion bereit, die mit Gleitkommazahlen zurechtkommt.

In Zeile 6 stelle ich die Option `--delay` auf den Wert 0 ein, falls
sie nicht explizit angegeben wird. In Zeile 8 werden die Optionen
eingelesen.

Zeile 10 und 11 entnehmen den Server und gegebenenfalls den Port der
Kommandozeile und in Zeile 13 öffne ich mit diesen Angaben den Socket.

In Zeile 18 lese ich die gesamte Eingabe in ein Array ein. Dies benötige
ich, da ich die Anzahl der Zeilen wissen muss, denn ich verzögere das Senden
zeilenweise um jeweils einen Bruchteil der Gesamtverzögerung. Die Zeilen
20-25 schließlich bereiten die Zeilenenden auf und senden die modifizierten
Zeilen verzögert über den Socket. Zeile 26 schickt die Leerzeile, nach der
der Server antwortet.

In Zeile 28-30 liest das Skript die Antwort des Servers vom Socket und
schreibt sie zur Standardausgabe.

Dieses Skript kann ich nun wie folgt aufrufen:

{line-numbers=off}
    $ time ./http-injector.pl --delay 5 localhost 80 < request > reply

    real  0m5.072s
    user  0m0.056s
    sys   0m0.012s

Dabei steht in der Datei request die HTTP-Anfrage, die ich an den Server
sende.
Nach fünf Sekunden ist die Anfrage beim Server, und die Antwort landet in
der Datei reply.

Damit konnte ich nachweisen, dass dieselbe Anfrage einen Fehler
lieferte, wenn sie mehr als drei Sekunden zur Übertragung brauchte und
fehlerfrei beantwortet wurde, wenn sie weniger als drei Sekunden brauchte.

## Notizen

*   nmap zum Testen von Anwendungsprotokollen

*   bridge-utils: Skript, um Interface zu MAC-Adressen auszugeben

*   bridge-utils: Referenzen zum Spanning Tree Protocol

*   Kann Ping ohne funktionierendes Routing funktionieren?

*   Wo finde ich Tutorials zu Wireshark?

*   libtrace: URIs erklären

*   libtrace: Cryptopan erklären

*   libtrace: bpf-Filter erklären

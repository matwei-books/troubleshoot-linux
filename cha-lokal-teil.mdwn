# Partieller Ausfall {#cha-lokal-teilausfall}

## Die ersten Minuten auf dem Server

Bevor ich mich wegen eines Problems an einem Server anmelde, habe ich bereits
einige Informationen gesammelt.

*   Wie äußert sich das Problem?

*   Wann wurde es zuerst bemerkt?

*   Ist es reproduzierbar?

*   Gibt es zeitliche Muster (zum Beispiel, wenn das Problem immer zur
    gleichen Stunde auftritt)?

*   Sind alle betroffen oder nur ein Teil der Nutzer?

Damit habe ich schon eine gewisse Vorstellung, wonach ich schauen werde, wenn
ich mich anmelde.
Zusätzlich habe ich die Gewohnheit entwickelt, bestimmte Informationen immer
abzufragen, wenn ich mich an einem Server anmelde.
Damit bekomme ich einen intuitiven Einblick in den Allgemeinzustand des
Servers und eventuell weitere Hinweise.

### uptime, w, last - Systemlast und Benutzer

Das Programm `uptime` zeigt mir neben der Systemzeit, wie lange der letzte
Systemstart zurückliegt, wieviel Benutzer momentan angemeldet sind und die
durchschnittliche Systemlast der letzten Minute, der letzten fünf Minuten und
der letzten fünfzehn Minuten.

Eine Abweichung der Systemzeit erschwert zum einen die Korrelation von
Lognachrichten.
Außerdem kann sie bei einigen kryptographischen Protokollen, wie zum Beispiel
*kerberos*, die Verbindung stören.

Die Zeit seit dem letzten Neustart kann auf frühere Probleme hinweisen, wenn
diese unerwartet kurz ist, der Rechner also außerplanmäßig neu gestartet
wurde.

Die Anzahl der Benutzer zeigt mir an, ob ich mit jemand Kontakt aufnehmen
muss, bevor ich schwerwiegende Eingriffe in das System vornehme.

Die Last schließlich zeigt an, wieviel Prozesse in dem betreffenden
Zeitraum durchschnittlich auf Rechenzeit gewartet haben.
Eine Durchschnittswert, der kleiner ist als die Anzahl der Prozessoren
bedeutet, dass die Prozessoren Freilauf hatten, der Server also nicht
ausgelastet war.
Ist der Durchschnittswert größer als die Anzahl der Prozessoren bedeutet das,
dass während des betreffenden Zeitabschnitts mehr Rechenleistung benötigt
wurde als zur Verfügung stand.
In diesem Fall ist der Trend interessant, den ich durch Vergleich der Last
für die drei Zeiträume erkennen kann.
Bei steigender Last versuche ich so schnell wie möglich für Entlastung zu
sorgen.
Ist der Trend fallend, brauche ich nichts unmittelbar zu unternehmen, außer
die Last weiter im Auge zu behalten.
Das System kommt nach einer Lastspitze gerade von selbst wieder in den
normalen Betriebsbereich.
Natürlich werde ich versuchen die Ursache der Lastspitze zu ermitteln, um zu
entscheiden, welche präventiven Maßnahmen ich für die Zukunft ergreifen will.

Eine Alternative zu *uptime* ist das Programm `w`.
Dieses zeigt in der ersten Zeile die gleichen Daten an wie *uptime*.
In den nachfolgenden zeigt es, wer gerade angemeldet ist, wann er das letzte
Mal etwas eingegeben hat und welches Programm er zuletzt aufgerufen hat.
Damit weiß ich gleich, mit wem ich Kontakt aufnehmen muss, wenn noch jemand
anderes angemeldet ist.
Das Programm `w` entnimmt, ebenso wie das Programm `who` die Informationen
über angemeldete Benutzer per Voreinstellung der Datei */var/log/utmp*.

Falls ich den Beginn des Problems mit letzten Änderungen am System korrelieren
will, rufe ich das Programm `last` auf.
Dieses Programm zeigt an, wer wann und wie lange am System angemeldet war und
außerdem die letzten Systemstarts.
Meist begrenze ich die Anzahl der angezeigten Zeilen, da mich nur die
letzten Anmeldungen interessieren:

    $ last -5
    mathias pts/2      ..Thu Nov 7 07:38   still...
    mathias pts/1      ..Thu Nov 7 07:33   still...
    mathias pts/0      ..Thu Nov 7 07:21   still...
    reboot  system boot..Thu Nov 7 06:48 - 07:57...
    mathias pts/1      ..Wed Nov 6 09:10 - 11:49...

`last` entnimmt diese Daten per Voreinstellung der Datei */var/log/wtmp*.
Diese Datei wird üblicherweise am Monatsanfang umbenannt in */var/log/wtmp.1*,
so dass immer nur die Daten des laufenden Monats zur Verfügung stehen.
Will ich die Anmeldungen des Vormonats sehen, gebe ich dieses explizit an:

    $ last -f /var/log/wtmp.1

Wenn nur ein Konto für alle Anmeldungen verwendet wird, kann ich mit `history`
nachschauen, was zuletzt gemacht wurde.
Bei mehreren Konten schaue ich in der Datei *.bash_history* im
Benutzerverzeichnis des in der fraglichen Zeit angemeldeten Benutzers nach.
Falls der Benutzer die csh verwendet, schaue ich stattdessen in *.history*.

### free - Hauptspeicher

Der zweiter Befehl, der mir hilft ein schnelles Bild über den Zustand der
Maschine zu bekommen, ist `free`.

    $  free -m
                 total used free shared buffers c..
    Mem:          7734 3466 4267      0     676  ..
    -/+ buffers/cache: 1432 6301
    Swap:         5153    0 5153

Dieser Befehl zeigt mir den insgesamt vorhandenen, den benutzten und den
freien Speicher an.
Außerdem wieviel des Speichers für dynamisch vergebene Dateisystem-Caches
verwendet wurde.
Mich interessiert jedoch vor allem die letzte Zeile, die angibt, wieviel
Auslagerungsspeicher zur Verfügung steht und wieviel davon bereits benutzt
wurde.
Gerade bei hoher Systemlast sorgt auf Festplatten ausgelagerter RAM für eine
weitere spürbare Verlangsamung des Systems, so dass ich hier schnell für
Abhilfe sorgen möchte.

### df - Plattenplatz

Der dritte Befehl schließlich ist `df`.
Dieser zeigt mir den verfügbaren Platz auf den Dateisystemen der eingehängten
Partitionen an.
Ich rufe diesen Befehl zweimal auf, einmal mit Option `-i`, für die Statistik
der Inodes und einmal ohne für die Belegung des Plattenplatzes.

    $ df -hi
    Filesystem     Inodes IUsed IFree IUse% Mounted on
    /dev/sda1         37M  2.7M   35M    8% /
    ...
    $ df -h
    Filesystem      Size  Used Avail Use% Mounted on
    /dev/sda1       586G  207G  350G  38% /
    ...

Mich interessiert vor allem die Spalte mit der prozentualen Nutzung.
Hat diese 100% erreicht, muss ich mit Ausfällen von Diensten rechnen, die, für
sich betrachtet, unter Umständen nicht gleich auf ein Problem mit dem
Plattenplatz gedeutet hätten.
Ab einer Nutzung von 80-90% mache ich mir Gedanken, wie ich für zusätzlichen
verfügbaren Plattenplatz sorgen kann.

Die verfügbaren Inodes in einem Dateisystem werden eher selten aufgebraucht.
Dazu müssten auf dem Dateisystem viele kleine Dateien angelegt sein.
Bei Mailservern mit Postfächern im Maildir-Format oder bei Newsservern kann
das jedoch vorkommen.

### pstree, ps - laufende Prozesse

Der nächste Befehl `pstree` zeigt mir, ob die notwendigen Prozesse laufen und
ob gegebenenfalls Prozesse zuviel sind.
Die Ausgabe des Befehls sieht auf jeder Maschine anders aus, entsprechend den
Diensten, die diese anbietet.
Mit etwas Erfahrung sehe ich damit aber schon intuitiv, ob ein Rechner "krank"
ist.

    $ pstree -A
    init-+-courierlogger---authdaemond---5*[auth...
         |-2*[courierlogger---couriertcpd]
	 |-cron
	 |-famd
	 |-getty
	 |-master-+-pickup
	 |        |-qmgr
	 |        `-tlsmgr
	 |-ntpd
	 |-portmap
	 |-rsyslogd---3*[{rsyslogd}]
	 |-sshd---sshd---sshd---bash---pstree
	 |-6*[stunnel4]
	 `-udevd

Der Befehl `ps aux`, auf Systemen, die `pstree` nicht installiert haben, ist
weit weniger übersichtlich und daher nur ein schwacher Ersatz.

Mit diesen ersten vier Befehlen, die ich beinahe gewohneitsmäßig nach der
Anmeldung am Server aufrufe, bekomme ich sehr schnell eine intuitive
Einschätzung - ein Gefühl - für den Zustand des Systems.
Alle weiteren Schritte hängen vom konkreten Problem und der Situation auf dem
Rechner ab.

## Mount-Fehler {#sec-mount-fehler}

### mount: / is busy

Dieser Fehler tritt mitunter bei `umount` auf, aber auch, wenn ich ein
Dateisystem von read-write auf read-only umhängen will.
Die Meldung `is busy` deutet es schon an, der Kernel, genauer gesagt
das Dateisystem ist (noch) beschäftigt.
Wenn ich das Dateisystem aushängen will, reicht ein Prozess, der auf
irgendeine Art auf das Dateisystem zugreift. Will ich es read-only umhängen,
muss ich nach Prozessen suchen, die Dateien zum Schreiben geöffnet haben.
In [Weidner2012](#bib-weidner2012) habe ich einen solchen Fall detailliert
beschrieben, hier gehe ich nur kurz auf die Schritte ein um die
betreffenden Prozesse und die geöffneten Dateien zu finden.
Die nächsten Schritte sind dann vom konkreten Fall abhängig.

A> ### Offene gelöschte Dateien
A> 
A> Übrigens, auch Dateilöschungen sind Schreibzugriffe. Wenn
A> Systembibliotheken aktualisiert werden, dann wird die alte Datei mit dem
A> Systembefehl `unlink()` gelöscht und die neue Datei mit dem gleichen
A> Namen gespeichert. Neu gestartete Prozesse verwenden dann die neue
A> Bibliothek. Prozesse, die bereits vor der Aktualisierung liefen, arbeiten
A> weiter mit der alten Bibliothek, weil sie diese ja vor der Aktualisierung
A> geöffnet hatten.
A> 
A> Abgesehen von den möglichen Sicherheitsproblemen, die die alte Bibliothek
A> vielleicht noch hat und damit auch die alten Prozesse, kann ich nun das
A> Dateisystem mit der alten Bibliothek nicht read-only umhängen. Denn die
A> alte Bibliothek ist zwar nicht mehr im Dateisystem gelinkt, die
A> betreffenden Blöcke können aber erst freigegeben werden, wenn der letzte
A> Prozess, der sie verwendet, beendet ist. Und erst danach kann ich das
A> Dateisystem read-only umhängen.
A> 
A> Das gleiche gilt für Dateien, die geöffnet werden und unmittelbar darauf
A> im Dateisystem gelöscht. Diese sind damit nur noch für den Prozess, der
A> sie geöffnet hat, verwendbar und die zugehörigen Speicherblöcke werden
A> erst mit Beenden dieses Prozesses im Dateisystem freigegeben.

Prozesse, die in irgendeiner Weise auf ein Dateisystem zugreifen, finde ich
am schnellsten mit:

    # fuser -vm $mntpnt

Diesen Befehl rufe ich mit den Privilegien von *root* auf, um alle Prozesse
angezeigt zu bekommen.
Dabei interessieren mich neben der PID und dem Prozessnamen (COMMAND) vor
allem die Angaben unter ACCESS. Insbesondere Prozesse mit `F` und
`m`, da diese es sind, die das read-only Umhängen des Dateisystems
verhindern.
Ich könnte diese Prozesse mit Option `-k` gleich von fuser beenden
lassen, aber besser ist es, erst mit `lsof -p $pid` nachzuschauen,
welcher Prozess das genau ist und welche Dateien er konkret offen hält.
Auch kann ich erstmal mit `pstree -p` abschätzen, ob ich vielleicht
vitale Systemfunktionen beende, wenn ich den Prozess einfach abschieße.
Handelt es sich um einen Systemdienst, wie SSH, dann ist meist der
Listening-Daemon bereits neu gestartet und nur die Instanz, über die ich
angemeldet bin, verwendet noch die alte Bibliothek. Dann reicht es mitunter,
wenn ich mich ein zweites Mal anmelde und danach die alte Verbindung trenne.

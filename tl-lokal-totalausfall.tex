%% tl-lokal-bootprobleme.tex
\chapter{Totalausfall}
\label{cha:totalausfall}

\begin{abstractsec}
  Bootprobleme sind möglicherweise das häufigste Problem bei einem
  Totalausfall. Andere mögliche Totalausfälle sind Kernel-Panik und ein
  unbenutzbares System auf Grund von Überlast und/oder Speichermangel.
\end{abstractsec}

\begin{notes}
\item Partitionen von Festplattenimage einhängen
%\item geht auch nicht
%\item und auch das
\end{notes}

\section{Bootprobleme}
\label{sec:lokal-bootprobleme}

Eine Art von Totalausfall eines Linux-Servers sind Bootprobleme. Wenn der
Rechner gar nicht erst startet, kann er seine Dienste nicht erfüllen, von
Performance gar nicht zu reden.

Zwar treten Bootprobleme eher selten auf, wenn sie erstmal da sind, bekommen
sie aber die volle Konzentration, weil eben wirklich ``nichts mehr geht``.

Um die Bootprobleme eines kaputten Systems diagnostizieren und beheben zu
können, muss ich das Verhalten eines gesunden Systems beim Startvorgang
kennen. Dieses zeichnet sich durch verschiedene Phasen mit unterschiedlicher
Zuständigkeit und dementsprechend unterschiedlicher Herangehensweise aus. Grob
kann man den Startvorgang eines Linux-Rechners in die folgenden Phasen
einteilen:

\begin{enumerate}
  \item Die Firmware des Rechners initialisiert die Hardware. Das ist bei
    einem PC zum Beispiel gekennzeichnet durch die verschiedenen
    BIOS-Meldungen. Eingriffe an dieser Stelle sind abhängig von der konkreten
    Hardware und nicht explizit Thema dieses Buches, obwohl diese das
    Verhalten des Linux-Systems sehr wohl beeinflussen.
  \item Die Firmware lädt und startet den Bootmanager (Grub, Lilo, \ldots). Je
    nach Bootmanager habe ich hier eventuell bereits die Möglichkeit, das
    spätere Verhalten des Linux-Systems direkt (zum Beispiel durch
    Kernel-Optionen) zu steuern.
  \item Der Bootloader als Bestandteil des Bootmanagers lädt den Kernel und
    das Initramfs und startet den Kernel. Hier werden Änderungen, die ich
    ebentuell im Bootmanager vorgenommen habe, zum ersten Mal wirksam.
  \item Der Kernel nimmt die wichtsten Systemkomponenten in Betrieb und
    startet ein Initialisierungsskript vom Initramfs. In dieser Phase kann ich
    nicht eingreifen, nur beobachten.
  \item Das Initialisierungsskript vom Initramfs lädt Treiber, überprüft das
    Root-Dateisystem und hängt dieses ein. Bei Problemen startet es eine
    Shell, in der das Problem interaktiv bearbeitet werden kann.
  \item Sobald das Root-Dateisystem als rootfs eingehängt ist, übergibt das
    Initialisierungsskript an das Programm an den Initd des Systems, der
    weitere Dateisysteme einhängt, Hintergrunddienste und Anmeldeprogramme
    startet. Wenn dieser auf Probleme mit Dateisystemen trifft, bietet er an,
    das Problem in einer Shell (nach Eingabe des Root-Kennworts) zu lösen,
    oder einen Neustart zu versuchen.
  \item Sobald ich mich am System regulär anmelden kann (getty, sshd, xdm,
    \ldots) kann ich den Rechner benutzen, auch wenn eventuell noch
    Systemteile initialisiert werden.
\end{enumerate}

\subsection{Startphasen des Rechners identifizieren}

Da ich, je nachdem in welcher Phase ein Problem auftritt, auf verschiedene
Weise an die Lösung des Problems herangehe, ist es wichtig, dass ich die
einzelnen Phasen erkennen und auseinander halten kann.

Dazu muss ich gegebenenfalls die nötigen Startinformationen erst freilegen.
Das können zum einen BIOS-Einstellungen sein, die abhängig von der Hard- und
Firmware und daher nicht Thema dieses Buches sind. Gerade viele moderne
Linux-Distributionen verstecken die Informationen, die Linux-Kernel und System
auf den Bildschirm schicken. Mit dem Bootmanager kann ich die betreffenden
Kerneloptionen ändern, um mehr Informationen zu erhalten. So entferne ich zum
Beispiel die folgenden Kerneloptionen:
\begin{itemize}
  \item \verb?quiet?
  \item \verb?rhgb? bei Fedora oder Red Hat
  \item \verb?splash? bei Ubuntu
  \item \verb?splash=silent? bei OpenSuse
  \item \verb?vt.handoff=7? bei Ubuntu 11.10
\end{itemize}

Außerdem gibt es bei Grub2 eventuell in der Konfiguration die Zeile
\begin{verbatim}
set gfxpayload=$linux_gfx_mode
\end{verbatim}
die ich ändere in
\begin{verbatim}
set gfxpayload=text
\end{verbatim}

\begin{notes}
\item Kasten: grub editieren
\end{notes}

Habe ich die Bootinformationen sichtbar gemacht, kann ich mit Ihrer Hilfe den
Bootvorgang besser diagnostizieren und dabei die einzelnen Phasen
unterscheiden.

Nach den Firmwaremeldungen meldet sich der Bootmanager. Manchmal nur mit einer
kurzen Zeile, die den Namen des Bootmanagers (Grub, Lilo, \ldots) enthält, oft
aber auch mit einem Menü, aus dem ich das System, welches starten soll,
auswählen kann.
Fehlt das Menü, kann ich es mit \verb?<ESC>? oder \verb?<TAB>? hervorrufen,
bevor der Bootloader den Kernel lädt.

Die Meldung 'Loading Kernel' oder 'Loading initial ramdisk' zeigt den Übergang
von Phase 2 zu Phase 3 an.
Diese wird gefolgt von Dutzenden Kernelmeldungen zur Hardware-Initialisierung,
die von der Kernel-Option \verb?quiet? unterdrückt worden wären.

Eine Meldung wie 'dracut: dracut \ldots' bei Fedora oder 'Write protecting the
kernel \ldots' und Meldungen von Udev zeigen an, dass der Kernel geladen ist
und die Skripte des Initramfs die Arbeit übernommen haben.

Meldungen wie 'Switching root' und 'Welcome to xyz Linux' zeigen an, dass die
Skripte des Initramfs fertig sind und der Init-Daemon des Systems übernimmt.
Sobald ein Konsole-Login oder grafisches Login präsentiert wird und ich mich
anmelden kann, betrachte ich den Systemstart als abgeschlossen, auch wenn im
Hintergrund noch der eine oder andere Dienst gestartet wird.

Mit dem Wissen um die Übergänge zwischen den einzelnen Phasen des
Startvorgangs kann ich mich nun den möglichen Problemen in den einzelnen
Bootphasen zu wenden.

Da Probleme mit der Firmware abhängig von der konkreten Hardware sind, werden
diese hier nicht weiter behandelt. Wichtig für die Fehlersuche ist trotzdem
ein grundlegendes Verständnis der Einstellmöglichkeiten in der Firmware (dem
BIOS beim PC), weil diese Einfluss auf das Verhalten des Kernels haben können.

\subsection{Probleme mit dem Bootmanager}

Bleibt nach den Selbsstests der Firmware der Bildschirm schwarz, kommt eine
Meldung wie 'Operating system not found' oder erscheinen Fehlermeldungen von
Grub, Lilo oder welcher Bootmanager vorhanden ist, haben wir ein Problem mit
dem Bootmanager.

Eine mögliche Ursache ist, dass die Firmware den Bootmanager nicht gefunden
hat. Das kann auf einen defekten Master Boot Record (MBR)hindeuten. Möglich
ist auch, dass der Bootloader nicht im Master Boot Record, sondern in einer
Partition installiert wurde und diese nicht als bootfähig in der
Partitionstabelle gekennzeichnet wurde. Möglicherweise wurde die
Bootreihenfolge im BIOS geändert oder durch einen zusätzlich angesteckten
Datenträger durcheinander gebracht. Eventuell ist die Installation des
Bootmanagers beschädigt. Grub2 zum Beispiel speichert einen Teil des
Bootmanagers direkt hinter dem MBR vor der ersten Partition. Eventuell ist
auch die Partition beziehungsweise das Dateisystem, welches weitere Teile des
Bootmanagers enthält, beeschädigt.

Wenn eine Vertauschung der Bootreihenfolge und ein zusätzlicher Datenträger
ausgeschlossen werden können, starte ich den Rechner von einem Live- oder
Rescue-System auf einer CD-ROM oder einem USB-Stick. Dann kann ich die
Systemplatte mit allen zur Verfügung stehenden Mitteln und Werkzeugen
überprüfen.
\begin{itemize}
  \item Ist die Partitionstabelle defekt?
  \item Sind die Dateisysteme in Ordnung?
\end{itemize}
Außerdem kann ich den Bootmanager neu installieren. Das mache ich am besten
aus dem System auf der Festplatte heraus. Dazu hänge ich die Partitionen an
dern korrekten Mountpoints ein und wechsle mit \verb?chroot? in das System.

\begin{notes}
\item Kasten ``Zugriff von außen'' aus c't 2012/6/S.199
\end{notes}

\subsection{Probleme beim Start des Kernels}

Nach dem der Bootloader den Kernel startet, bleibt das System stehen oder
startet neu. Das passiert mitunter nach einem BIOS- oder Kernel-Upgrade oder
nach Änderungen in den BIOS-Einstellungen. Daher versuche ich
herauszubekommen, ob eine dieser Bedingungen hier vorliegt und ob ich diese
möglicherweise rückgängig machen kann.

Testweise kann ich alle Peripherie (USB, seriell, parallel, \ldots) und oder
alle nicht zum Booten benötigten Komponenten entfernen. Falls das System dann
startet, füge ich nach die einzelnen Komponenten wieder hinzu, bis der Fehler
wieder auftritt.

Als nächstes kann ich systematisch die verschiedenen Hardware-relevanten
Kernelparameter durchprobieren. Dann genauso die BIOS-Einstellungen und
schließlich die Kombination beider.

\subsection{Abbruch des Kernels}

Nach Ausgabe einiger Zeilen bleibt der Kernel eventuell mit der Meldung
'Kernel panic' stehen.

Das kann an einer fehlerhaften Kernkomponente, wie Prozessor, Speicher,
Chipsatz auf dem Mainboard leigen. Insbesondere, wenn der Kernel gleich nach
dem Anlaufen ohne Panic abbricht. In diesem Fall muss ich mit den
Kernelparametern experimentieren. Eventuell hilft eine Internet-Suche nach der
gleichen Hardware in Zusammenhang mit Problemen bei Linux.

Bei Problemen mit Treibern versuche ich meist die folgenden Strategien:
\begin{itemize}
  \item Internet-Suche mit den Informationen aus den letzten Zeilen oberhalb
    der Abbruchmeldung
  \item Suche in der Kernel-Dokumentation zu Parametern für diesen Treiber.
    Bei modularen Treibern hilft auch \verb?modinfo -p treibername? für eine
    erste Übersicht.
  \item Mit der Kerneloption \verb?modulename.disable=1? kann ich das Laden
    diesen Treibers unterbinden.
\end{itemize}

Wenn bereits nach einigen Zeilen der Bildschirm schwarz wird oder das System
neu startet, könnte es auch am Grafiktreiber liegen, falls die Zeilen davor
nicht auf andere Ursachen hindeuten.

Als erstes kann ich den Standard-VGA-Textmodus mit dem Kernelparameter
\verb?nomodeset? einschalten. Falls das funktioniert, könnte es an einer
fehlerhaften Erkennung des Monitors liegen. Mit \verb?video=1024x768-24@75?
gebe ich eine Auflösung von 1024x768 bei 24 Bit Farbtiefe und einer
Bildwiederholrate von 75 Hertz vor. Funktioniert auch das, kann ich den
Parameter so ändern, das er zu meinem Monitor passt. Sitzen die Probleme
tiefe, kann ich versuchen, die Debug-Informationen des Direct Rendering
Manager (DRM) des Kernels mittels des Kernelparameters \verb?drm.debug=14?
auszuwerten. Auch die DRM-Treiber bieten Optionen, mit denen ich
experimentieren kann. Auf diese gehe ich an dieser Stelle jedoch nicht weiter
ein, da das zu weit ab vom Thema führen würde.

\subsection{Kernel-Panik}

Der Kernel schreibt eine Zeile mit \verb?Kernel panic? und arbeitet nicht mehr
weiter. In dieser Zeile folgt noch eine Kurzbeschreibung des Problems.

\subsubsection{Attempted to kill init}

Der Prozess mit PID 1 ist abgestürzt. Das könnte durch ein beschädigtes
Initramfs verursacht sein oder, falls das System schon mit dem
Root-Dateisystem arbeitet, durch beschädigte oder fehlende Dateien auf eben
diesem.

Zur Lösung starte ich den Rechner mit einem Live- oder Rescue-System,
ermittele die genaue Ursache und repariere diese.

Alternativ, falls ich gerade nicht von einem anderen Medium starten kann,
starte ich mit dem Kernelparameter \verb?init=/bin/sh? eine Shell anstelle des
Init-Daemons und muss dann die Initialisierungen von Hand erledigen, bevor ich
das System reparieren kann.

\begin{notes}
\item Was macht und wie funktioniert \verb!init=/bin/sh!?
\end{notes}

\subsubsection{No init found \ldots}

Der Kernel hat das Programm, das er als erstes starten soll, nicht gefunden.
Ich behandle das Problem ähnlich wie das vorige und starte ein Live- oder
Rescue-System beziehungsweise gebe mit der Option \verb?init=\ldots? ein
anderes Programm an.

\subsubsection{Fatal Exception / Aiee, Killing Interrupt Handler}

Diese Probleme können vielfältige Ursachen haben. Meist finden sich Hinweise
ein paar Zeilen weiter oben. Steht dort ein \verb?Oops?, hat der Kernel ein
Problem erkannt und zunächst versucht weiter zu arbeiten.

Ein \verb?Oops? ist eine Abweichung vom korrekten Verhalten des Kernels, die
eine Fehlermeldung produziert, welche via syslog protokolliert werden kann (im
Gegensatz zu einem Kernel-Panik, bei dem kein Logging mehr möglich ist). Wenn
der Kernel ein Problem entdeckt, gibt er eine \verb?Oops? Nachricht aus und
beendet den verursachenden Prozess. Die offizielle Dokumentation dazu findet
sich in der Datei oops\_tracing.txt bei der Kernel-Dokumentation. Sobald ein
System einen \verb?Oops? erlebt hat, arbeiten einige interne Ressourcen nicht
mehr korrekt. Das wiederum kann zu weiteren \verb?Oops? und schließlich zum
Kernel-Panik führen. Daher ist es bei der Analyse wichtig, sich zunächst auf
den ersten \verb?Oops? zu konzentrieren. Dabei helfen Internet-Suchen, die
Dokumentation und gegebenenfalls eine Anfrage auf der entsprechenden
Mailingliste.

\subsubsection{not syncing: VFS: Unable to mount rootfs on \ldots}

Der Kernel findet sein Root-Dateisystem nicht. Das kann an einem fehlenden
oder defekten Initramfs liegen. Oder das in der Kernel-Kommandozeile genannte
Dateisystem ist nicht erreichbar.

Als erstes sehe ich mir hier die Booloader-Konfiguration genau an. Ist das
Initramfs korrekt angegeben? Ist das Root-Dateisystem korrekt angegeben? Ist
(zum Beispiel bei NFS-Rootfs) der Server mit dem Rootfs erreichbar und auf ihm
das Dateisystem mit dem entsprechenden Protokoll? Eventuell muss ich den
Rechner mit einem Live- oder Rescue-System starten, um das Problem genauer
einzugrenzen und zu beheben.

\subsection{Probleme im Initramfs}

Bekomme ich Meldungen wie \verb?dracut: Warning: \ldots? (Fedora) oder
\verb?Gave up waiting for root device? (Debian, Ubuntu) und anschließend einen
Shell-Prompt, dann haben die Skripts des Initramfs das Root-Dateisystem nicht
gefunden.

Mit \verb?dmesg|less? kann ich mir die Kernelmeldungen noch einmal ansehen.
Dabei suche ich nach Meldungen zu den Speichersystemen. Habe ich less nicht
zur Verfügung, kann ich mit \verb?<Shift>-<Bild auf/ab>? blättern. Dabei
überprüfe ich, ob die Systemplatte gefunden wurde (beziehungsweise bei
NFS-Root der Netzwerkadapter).

Falls das Root-Dateisystem als UUID oder Label spezifiziert wurde, kann ich
mit \verb?blkid? alle erkannten Label und UUIDs ausgeben lassen. Unter /proc
und /sys kann ich weitere Informationen zu erkannten Hardware finden. So
liefert mir zum Beispiel /proc/mdstat Informationen zu einem Software-RAID.

\subsection{Udev}

Kurz nachdem Udev gestartet wurde, bleibt das System hängen.

In diesem Fall helfen mir die Kerneloptionen \verb?udev.log_priority=info? und
\verb?udev.children-max=1?. Damit startet Udev nur einen Kind-Prozess und gibt
eine Reihe von zusätzlichen Informationen aus. Habe ich damit ein
problematisches Modul identifiziert, kann ich dieses mit
\verb?modulename.disable=1? in den Kernel-Optionen deaktivieren.

\subsection{Stopp bei der Dateisystemüberprüfung}

\begin{verbatim}
...
error checking filesystem
...
Give root password for rescue shell or type Control-D for reboot.
\end{verbatim}

Der Init-Daemon hat ein Problem beim Dateisystemcheck erkannt und bietet mir
an, dieses in einer Shell zu beheben. Dazu muss ich das Rootkennwort wissen.

Ein Neustart mit Steuerung-D wird mir nicht weiterhelfen, da wir es hier mit
einem schwerwiegenden Problem im Dateisystem zu tun haben und beim nächsten
Start genauso weit kommen würden.

Ich brauche also das Rootkennwort oder eine andere Möglichkeit, eine
Root-Shell auf dem Rechner zu bekommen (wie zum Beispiel die Option
\verb?init=/bin/sh?).

Dann starte ich die Dateisystemüberprüfung und -reparatur von Hand für alle
benötigten Dateisysteme und starte den Rechner anschließend neu. Läuft deer
Rechner wieder, muss ich nun noch schauen, ob und gegebenenfalls welche
Dateien ich aus dem Backup ersetzen muss.

Problem erkannt, Problem gelöst.

Oder?

Habe ich den Rechner selbst aufgesetzt und mir notiert, welche Partitionen mit
welchem Dateisystem wo eingehängt sind, dann ist es wirklich so einfach. Bei
einem fremden Rechner, oder wenn es ein älteres Gerät ist, zu dem ich keine
Aufzeichnungen habe, dann muss ich noch herausfinden, welche Partitionen ich
mit fsck überprüfen muss.

In der Bildschirmmeldung steht, bei welcher Partition die automatische
Überprüfung aufgegeben hat. Nötigenfalls kann ich mit Shift-PgUp nach oben
blättern, wenn die Meldung schon nach oben rausgerollt ist.

Aber je nach Alter des Rechners und verwendeter Linux Distribution steht dann
da entweder ein Gerätename wie /dev/sda1, ein Label wie ``rootfs'' oder eine
UUID. Und das fsck-Programm erwartet als Angabe einen Gerätenamen. Beim Label
und bei der UUID muss ich nun die Zuordnung herausbekommen.

Die Datei /etc/fstab kann ich als erste Anlaufstelle nehmen, die mir Hinweise
auf die Partition und das Dateisystem gibt. Diese benötige ich, um das
richtige Programm für die Dateisystemüberprüfung zu verwenden. Allerdings
stehen in /etc/fstab auch nur die Label beziehungsweise UUID, die ich aus der
Konsolenmeldung bereits kenne.

Mit den verschiedenen Diskpartitionierungsprogrammen kann ich mir die
Partitionen ausgeben lassen. Insbesondere cfdisk ist hier nützlich, weil es
vergebene Label anzeigt, so dass ich sie einem Gerätenamen zuordnen kann. Bei
UUID hilft es mir leider nicht.

Das Programm blkid zeigt mir sowohl Label als auch UUIDs an:
\begin{verbatim}
# blkid
/dev/sda1: UUID="f779141e-e3b1-4521-9333-9dde9de0b64f" TYPE="ext3" 
/dev/sda5: LABEL="swap" UUID="bc3aa59f-55fc-460d-86ef-cf72ce99b70b" TYPE="swap" 
\end{verbatim}

Alternativ kann ich die Gerätedateien mit findfs bestimmen:
\begin{verbatim}
# findfs LABEL=swap
/dev/sda5
# findfs UUID=f779141e-e3b1-4521-9333-9dde9de0b64f
/dev/sda1
\end{verbatim}

Habe ich keines dieser Programme, aber file, dann kann ich mir auch wie folgt
behelfen (Umbruch ist von mir eingefügt):
\begin{verbatim}
# dd if=/dev/sda1 of=sda1 bs=4096 count=1
1+0 records in
1+0 records out
4096 bytes (4.1 kB) copied, 0.000275722 s, 14.9 MB/s
# dd if=/dev/sda5 of=sda5 bs=4096 count=1
1+0 records in
1+0 records out
4096 bytes (4.1 kB) copied, 0.000103642 s, 39.5 MB/s
# file sda1 sda5
sda1: Linux rev 1.0 ext3 filesystem data, \
UUID=f779141e-e3b1-4521-9333-9dde9de0b64f (needs journal recovery) \
(large files)
sda5: Linux/i386 swap file (new style), version 1 (4K pages), \
size 1319329 pages, LABEL=swap, UUID=bc3aa59f-55fc-460d-86ef-cf72ce99b70b
\end{verbatim}

Da file bei der direkten Abfrage der Gerätedateien nur deren Typ angeben
würde, kopiere ich den ersten Block des Dateisystems in eine Datei und lasse
diese dann von file analysieren.

\section{Bootprobleme bei virtuellen Maschinen}
\label{sec:lokal-bootprobleme-vm}

\subsection*{Partitionen von Festplattenimages einhängen}
\label{sec:mount-hdimage-partition}

Bei Problemen mit dem Start von virtuellen Maschinen ist es oft notwendig,
wenigstens die Bootpartition der betroffenen VM zu untersuchen.

Manchmal kann
ich dazu das Festplattenimage der defekten VM einfach einer anderen VM
zuordnen und es von dieser aus untersuchen. Das erscheint zumindest bei
grafischen Oberflächen für die Administration als der einfachste Weg.
Allerdings muss ich dann immer zwischen dem Hostsystem beziehungsweise der
Administrationsoberfläche und der VM, mit der ich das Festplattenimage
untersuche wechseln und verliere viel Zeit beim Zuordnen, Ein- und Aushängen
und den Startversuchen.

Besser ist in meinen Augen, die Partitionen des betroffenen Images gleich im
Hostsystem für die Analyse und Störungsbeseitigung einzubinden und die
Vorteile der Shell für zügiges Arbeiten zu nutzen.

Nun habe ich aber das Problem, dass ich auf dem Hostsystem nicht, wie bei den
eigenen Festplatten, die Partitionen direkt zur Verfügung habe, sondern nur
das Komplettimage der Festplatte für die VM. Und dieses beginnt nicht mit dem
Dateisystem sondern mit der Partitionstabelle. Um die gewünschte Partition
einzubinden, muss ich dem Mount-Befehl den Offset der Partition mitgeben.

Den Offset kann ich mit dem Programm fdisk bestimmen. Dieses listet mit der
Option \verb?-l? die Partitionen und deren Offsets auf. Da wir letztere genau
bestimmen müssen, verwenden wir zusätzlich die Option \verb?-u?, damit fdisk
die Offsets als Anzahl von Sektoren zu je 512 Byte ausgibt:

\begin{verbatim}
# fdisk -l -u /dev/camion/ssh3 

Disk /dev/camion/ssh3: 4294 MB, 4294967296 bytes
255 heads, 63 sectors/track, 522 cylinders, total 8388608 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disk identifier: 0x000c48f7

            Device Boot      Start         End      Blocks   Id  System
/dev/camion/ssh3p1            2048     7706623     3852288   83  Linux
/dev/camion/ssh3p2         7708670     8386559      338945    5  Extended
Partition 2 does not start on physical sector boundary.
/dev/camion/ssh3p5         7708672     8386559      338944   82  Linux swap
\end{verbatim}

Der Offset für die Systempartition \verb?ssh3p1? ist $512 * 2048$, also
1048576. Damit kann ich diese Partition im Hostsystem wie folgt einhängen:

\begin{verbatim}
# mount /dev/camion/ssh3 /tmp/mnt -o loop,offset=1048576
\end{verbatim}

Wenn ich fertig bin, hänge ich die Partition normal mit umount wieder aus.

Wichtig ist, dass ich die Partition im Hostsystem nur einhänge, wenn die VM
nicht läuft. Das ist beim Untersuchen von Bootproblemen meist gegeben. Bei
laufenden VMs habe ich mit LVM die Möglichkeit, einen Snapshot anzufertigen
und diesen Snapshot nur-lesend einzuhängen. Dabei muss ich aber bedenken, dass
Dateien, die in der VM geöffnet waren, eventuell in einem inkonsistenten
Zustand sind. Für Backups kann ich jedoch die VM kurz runterfahren, den
Snapshot anlegen und die VM gleich wieder starten.

%\begin{abstractsec}
%  Die Aufteilung der Umsetzung wird hier gegliedert in verschiedene Aspekte
%\end{abstractsec}
%\begin{normaltext}
%  Blablabla
%\end{normaltext}

%\subsection{Einschränkung der Umsetzung}
%\label{sec:einschr-der-umsetz}

%\section{Schnittstellen nach außen}
%\label{sec:schn-nach-au3en}

%\subsection{Schnittstelle zu A}
%\label{sec:schnittstelle-zu}

%\begin{notes}
%\item Syntax
%\item Semantik
%\end{notes}

%\subsection{Schnittstelle zu B}
%\label{sec:schnittstelle-zu-b}

%\begin{notes}
%\item Syntax
%\item Semantik
%\end{notes}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "arbeit-hauptdatei"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:

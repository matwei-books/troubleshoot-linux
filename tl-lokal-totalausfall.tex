%% tl-lokal-bootprobleme.tex
\chapter{Bootprobleme}
\label{cha:bootprobleme}

\begin{abstractsec}
  Probleme beim Booten des Rechners betrachte ich als lokalen Totalausfall.
\end{abstractsec}

\begin{notes}
\item Partitionen von Festplattenimage einhängen
%\item geht auch nicht
%\item und auch das
\end{notes}

\section{Stopp bei der Dateisystemüberprüfung}
\label{sec:lokal-stop-at-fsck}

Ein Rechner wurde neu gestartet und taucht nicht wieder in der
Monitoringumgebung auf. Ping vom Administratorplatz funktioniert auch nicht,
wohl aber zu anderen Geräten in diesem Netzsegment. Wohl oder übel muss ich
zur Konsole, die an diesem Rechner angeschlossen ist, beziehungsweise bei
einer VM an die Servicekonsole. Und dann kann ich es sehen:

\begin{verbatim}
...
error checking filesystem
...
Give root password for rescue shell or type Control-D for reboot.
\end{verbatim}

Ein Neustart mit Steuerung-D wird mir nicht weiterhelfen, da wir es hier mit
einem schwerwiegenden Problem im Dateisystem zu tun haben und beim nächsten
Start genauso weit kommen würden.

Ich brauche also das Rootkennwort oder eine andere Möglichkeit, eine
Root-Shell auf dem Rechner zu bekommen.

Dann starte ich die Dateisystemüberprüfung und -reparatur von Hand für alle
benötigten Dateisysteme und starte den Rechner anschließend neu. Läuft deer
Rechner wieder, muss ich nun noch schauen, ob und gegebenenfalls welche
Dateien ich aus dem Backup ersetzen muss.

Problem erkannt, Problem gelöst.

Oder?

Habe ich den Rechner selbst aufgesetzt und mir notiert, welche Partitionen mit
welchem Dateisystem wo eingehängt sind, dann ist es wirklich so einfach. Bei
einem fremden Rechner, oder wenn es ein älteres Gerät ist, zu dem ich keine
Aufzeichnungen habe, dann muss ich noch herausfinden, welche Partitionen ich
mit fsck überprüfen muss.

In der Bildschirmmeldung steht, bei welcher Partition die automatische
Überprüfung aufgegeben hat. Nötigenfalls kann ich mit Shift-PgUp nach oben
blättern, wenn die Meldung schon nach oben rausgerollt ist.

Aber je nach Alter des Rechners und verwendeter Linux Distribution steht dann
da entweder ein Gerätename wie /dev/sda1, ein Label wie ``rootfs'' oder eine
UUID. Und das fsck-Programm erwartet als Angabe einen Gerätenamen. Beim Label
und bei der UUID muss ich nun die Zuordnung herausbekommen.

Die Datei /etc/fstab kann ich als erste Anlaufstelle nehmen, die mir Hinweise
auf die Partition und das Dateisystem gibt. Diese benötige ich, um das
richtige Programm für die Dateisystemüberprüfung zu verwenden. Allerdings
stehen in /etc/fstab auch nur die Label beziehungsweise UUID, die ich aus der
Konsolenmeldung bereits kenne.

Mit den verschiedenen Diskpartitionierungsprogrammen kann ich mir die
Partitionen ausgeben lassen. Insbesondere cfdisk ist hier nützlich, weil es
vergebene Label anzeigt, so dass ich sie einem Gerätenamen zuordnen kann. Bei
UUID hilft es mir leider nicht.

Das Programm blkid zeigt mir sowohl Label als auch UUIDs an:
\begin{verbatim}
# blkid
/dev/sda1: UUID="f779141e-e3b1-4521-9333-9dde9de0b64f" TYPE="ext3" 
/dev/sda5: LABEL="swap" UUID="bc3aa59f-55fc-460d-86ef-cf72ce99b70b" TYPE="swap" 
\end{verbatim}

Alternativ kann ich die Gerätedateien mit findfs bestimmen:
\begin{verbatim}
# findfs LABEL=swap
/dev/sda5
# findfs UUID=f779141e-e3b1-4521-9333-9dde9de0b64f
/dev/sda1
\end{verbatim}

Habe ich keines dieser Programme, aber file, dann kann ich mir auch wie folgt
behelfen (Umbruch ist von mir eingefügt):
\begin{verbatim}
# dd if=/dev/sda1 of=sda1 bs=4096 count=1
1+0 records in
1+0 records out
4096 bytes (4.1 kB) copied, 0.000275722 s, 14.9 MB/s
# dd if=/dev/sda5 of=sda5 bs=4096 count=1
1+0 records in
1+0 records out
4096 bytes (4.1 kB) copied, 0.000103642 s, 39.5 MB/s
# file sda1 sda5
sda1: Linux rev 1.0 ext3 filesystem data, \
UUID=f779141e-e3b1-4521-9333-9dde9de0b64f (needs journal recovery) \
(large files)
sda5: Linux/i386 swap file (new style), version 1 (4K pages), \
size 1319329 pages, LABEL=swap, UUID=bc3aa59f-55fc-460d-86ef-cf72ce99b70b
\end{verbatim}

Da file bei der direkten Abfrage der Gerätedateien nur deren Typ angeben
würde, kopiere ich den ersten Block des Dateisystems in eine Datei und lasse
diese dann von file analysieren.

\section{Bootprobleme bei virtuellen Maschinen}
\label{sec:lokal-bootprobleme-vm}

\subsection*{Partitionen von Festplattenimages einhängen}
\label{sec:mount-hdimage-partition}

Bei Problemen mit dem Start von virtuellen Maschinen ist es oft notwendig,
wenigstens die Bootpartition der betroffenen VM zu untersuchen.

Manchmal kann
ich dazu das Festplattenimage der defekten VM einfach einer anderen VM
zuordnen und es von dieser aus untersuchen. Das erscheint zumindest bei
grafischen Oberflächen für die Administration als der einfachste Weg.
Allerdings muss ich dann immer zwischen dem Hostsystem beziehungsweise der
Administrationsoberfläche und der VM, mit der ich das Festplattenimage
untersuche wechseln und verliere viel Zeit beim Zuordnen, Ein- und Aushängen
und den Startversuchen.

Besser ist in meinen Augen, die Partitionen des betroffenen Images gleich im
Hostsystem für die Analyse und Störungsbeseitigung einzubinden und die
Vorteile der Shell für zügiges Arbeiten zu nutzen.

Nun habe ich aber das Problem, dass ich auf dem Hostsystem nicht, wie bei den
eigenen Festplatten, die Partitionen direkt zur Verfügung habe, sondern nur
das Komplettimage der Festplatte für die VM. Und dieses beginnt nicht mit dem
Dateisystem sondern mit der Partitionstabelle. Um die gewünschte Partition
einzubinden, muss ich dem Mount-Befehl den Offset der Partition mitgeben.

Den Offset kann ich mit dem Programm fdisk bestimmen. Dieses listet mit der
Option \verb?-l? die Partitionen und deren Offsets auf. Da wir letztere genau
bestimmen müssen, verwenden wir zusätzlich die Option \verb?-u?, damit fdisk
die Offsets als Anzahl von Sektoren zu je 512 Byte ausgibt:

\begin{verbatim}
# fdisk -l -u /dev/camion/ssh3 

Disk /dev/camion/ssh3: 4294 MB, 4294967296 bytes
255 heads, 63 sectors/track, 522 cylinders, total 8388608 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disk identifier: 0x000c48f7

            Device Boot      Start         End      Blocks   Id  System
/dev/camion/ssh3p1            2048     7706623     3852288   83  Linux
/dev/camion/ssh3p2         7708670     8386559      338945    5  Extended
Partition 2 does not start on physical sector boundary.
/dev/camion/ssh3p5         7708672     8386559      338944   82  Linux swap
\end{verbatim}

Der Offset für die Systempartition \verb?ssh3p1? ist $512 * 2048$, also
1048576. Damit kann ich diese Partition im Hostsystem wie folgt einhängen:

\begin{verbatim}
# mount /dev/camion/ssh3 /tmp/mnt -o loop,offset=1048576
\end{verbatim}

Wenn ich fertig bin, hänge ich die Partition normal mit umount wieder aus.

Wichtig ist, dass ich die Partition im Hostsystem nur einhänge, wenn die VM
nicht läuft. Das ist beim Untersuchen von Bootproblemen meist gegeben. Bei
laufenden VMs habe ich mit LVM die Möglichkeit, einen Snapshot anzufertigen
und diesen Snapshot nur-lesend einzuhängen. Dabei muss ich aber bedenken, dass
Dateien, die in der VM geöffnet waren, eventuell in einem inkonsistenten
Zustand sind. Für Backups kann ich jedoch die VM kurz runterfahren, den
Snapshot anlegen und die VM gleich wieder starten.

%\begin{abstractsec}
%  Die Aufteilung der Umsetzung wird hier gegliedert in verschiedene Aspekte
%\end{abstractsec}
%\begin{normaltext}
%  Blablabla
%\end{normaltext}

%\subsection{Einschränkung der Umsetzung}
%\label{sec:einschr-der-umsetz}

%\section{Schnittstellen nach außen}
%\label{sec:schn-nach-au3en}

%\subsection{Schnittstelle zu A}
%\label{sec:schnittstelle-zu}

%\begin{notes}
%\item Syntax
%\item Semantik
%\end{notes}

%\subsection{Schnittstelle zu B}
%\label{sec:schnittstelle-zu-b}

%\begin{notes}
%\item Syntax
%\item Semantik
%\end{notes}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "arbeit-hauptdatei"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:

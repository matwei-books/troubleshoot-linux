%% tl-lokal-werkzeuge.tex
\chapter{Werkzeuge zur lokalen Fehlersuche}
\label{cha:lokal-werkzeuge}

\begin{abstractsec}
  Verschiedene Werkzeuge helfen mir lokale Probleme einzugrenzen. Hier stelle
  ich die Werkzeuge kurz vor, die ich in den nächsten drei Kapiteln zur
  Fehlersuche einsetze.
\end{abstractsec}

\begin{normaltext}
  Linux stellt mir eine Unmenge von Werkzeugen für die Fehlersuche zur
  Verfügung. Etliche davon kommen mir sowohl bei Total- oder Partialausfällen
  zu gute. Andere bei Performanceproblemen. Einige sind so nützlich, dass sie
  immer wieder bei den unterschiedlichsten Problemen zum Einsatz kommen. Da
  es mir schwerfällt, die einzelnen Werkzeuge bestimmten Kategorien
  zuzuordnen, stelle ich diese nachfolgend in alphabetischer Reihenfolge vor.
  Das erleichtert zumindest das Wiederfinden, wenn man mal eben etwas schnell
  nachschlagen möchte.
\end{normaltext}

\begin{notes}
\item hdparm
\item gdb
\item ifconfig
\item iproute
\item ltrace
\item perl
\item shell
\end{notes}

\section{fuser}
\label{sec:lokal-werkzeuge-fuser}
\begin{abstractsec}
  Das Programm fuser setze ich ein, wenn ich schnell Informationen darüber
  haben will, welche Prozesse bestimmte Dateien oder Netzwerksockets geöffnet
  haben.
\end{abstractsec}
\begin{normaltext}
  Das Programm fuser setzte ich ein, wenn ich schnell Informationen darüber
  haben will, welche Prozesse bestimmte Dateien oder Netzwerksockets geöffnet
  haben, um sie dann mit anderen Programmen näher zu untersuchen.
  Zwar kann ich die ermittelten Prozesse dann gleich von fuser beenden lassen,
  aber in diesem Buch geht es vor allem um die Fehleranalyse und dafür wäre
  das dann meist doch etwas zu grobschlächtig.

  Was mich vor allem interessiert, sind die Prozesse und die Art und Weise,
  wie diese die betreffenden Dateien verwenden.
  Diese bekomme ich von fuser in einer Tabelle angezeigt. In der ersten Spalte
  steht die Datei, dahinter die PID. Mit der Option -v kann ich diese Ausgabe
  erweitern, so dass fuser für jeden Prozess den Benutzer (USER), die PID, den
  Zugriff (ACCESS) und den Namen des Prozesses (COMMAND) anzeigt.

  Von diesen ist ACCESS für viele Analysen interessant. Diese Spalte kann die
  folgenden Merkmale haben:
  \begin{description}
    \item[c] CWD, das Arbeitsverzeichnis des Prozesses,
    \item[e] Executable, die Datei wird als Programm ausgeführt
    \item[f] File, die Datei ist als normale Datei geöffnet
    \item[F] File, die Datei ist zum Schreiben geöffnet
    \item[r] Root, die Datei ist Wurzelverzeichnis
    \item[m] MMAP, die Datei ist in den Speicherbereich des Prozesses
      eingeblendet (zum Beispiel als Bibliothek)
  \end{description}
  Mit diesen Merkmalen bekomme ich heraus, wie ein Prozess eine Datei
  verwendet. Allerdings kann ich das nur für Dateien sehen, die noch im
  Dateisystem verlinkt sind. Dateien, die zwar geöffnet, aber nicht mehr im
  Dateisystem verlinkt sind, kann ich damit nicht finden. Dazu benötige ich
  andere Programme, wie zum Beispiel lsof. Mit der Option \verb?--mount?
  (\verb?-m?) bekomme ich aber zumindest die PID dieser Prozesse, und kann
  diese dann mit lsof näher untersuchen.

  Dazu muss ich folgende Besonderheit der Ausgabe von fuser beachten. Das
  Programm schreibt nur die PIDs an die Standardausgabe, alles andere kommt
  über die Fehlerausgabe. Damit kann ich die Ausgabe von fuser sehr bequem in
  Scripts weiterverarbeiten:
  \begin{verbatim}
for p in $(fuser -m /); do
    lsof -p $p
done
  \end{verbatim}
  Will ich die Ausgabe allerdings in einem Pager betrachten, oder
  dokumentieren, so schreibe ich:
  \begin{verbatim}
fuser -m / 2>&1 | less
  \end{verbatim}

  Neben den Prozessen, die auf bestimmte Dateien zugreifen, bin ich manchmal
  an allen Prozessen interessiert, die irgendeine Datei in einem Dateisystem
  geöffnet haben. Dafür verwende ich die Option \verb?--mount? (\verb?-m?).
  Das ist auch der einzige Weg, wie ich mit fuser Prozesse finden kann, die
  bereits im Dateisystem gelöschte Dateien noch offen halten. Welche Prozesse
  das konkret sind, kann ich zwar damit noch nicht sagen, aber das kann ich
  zum Beispiel ermitteln, wenn ich die mit fuser ermittelten Prozesse mit lsof
  näher betrachte.

  Außer bei Dateien in Dateisystemen kann ich mit fuser auch die Prozesse
  ermitteln, die bestimmte Sockets geöffnet haben. Dazu wähle ich den
  entsprechenden Namensraum mit der Option \verb?--namespace SPACE?
  (\verb?-n SPACE?) aus. Fuser kennt die folgenden Namensräume:
  \begin{description}
    \item[file] ist der Standardnamensraum, der nicht extra angegeben werden
      muss.
    \item[tcp] steht für TCP-Sockets
    \item[udp] steht für UDP-Sockets
  \end{description}
  Sockets werden nach dem folgenden Schema angegeben:
  \begin{verbatim}
[local port][,[remote host][,[remote port]]][/namespace]
  \end{verbatim}
  Den Namensraum kann ich angeben, wenn die Angabe eindeutig ist und ich
  diesen nicht explizit mit \verb?--namespace? angeben will.
  Die Komma sind wichtig. So zeigt \verb?fuser ssh/tcp? alle Prozesse, die mit
  dem lokalen Port 22 arbein, währen \verb?fuser ,,ssh/tcp? alle Prozesse mit
  abgehender SSH-Verbindung an.

  Mit der Option \verb?-4? beziehungsweise \verb?-6? kann ich die Ausgabe auf
  die entsprechende Version des Internetprotokolls eingrenzen.

  Eine Option, die ich eher selten anwende ist \verb?--kill? (\verb?-k?), mit
  der fuser ein Signal (ohne weitere Angaben: \verb?SIGKILL?) an die
  ermittelten Prozesse sendet. Das Signal kann ich mit einem vorangestellten
  Bindestrich (\verb?-?) angeben, eine Liste der Signale bekomme ich mit
  \verb?--list-signals? (\verb?-l?). Zum Beispiel könnte ich mit
  \begin{verbatim}
fuser -k -HUP 22/tcp
  \end{verbatim}
  alle SSH-Anmeldungen an diesem Rechner beenden. War ich selbst via SSH
  angemeldet, dann habe ich mich damit selbst hinausgeworfen. Oder, falls ich
  ein Dateisystem aushängen will, beende ich mit
  \begin{verbatim}
fuser -k -m /media/cdrom
  \end{verbatim}
  alle Prozesse, die auf die eingehängte CD-ROM zugreifen. Falls aber unter
  /media/cdrom kein Dateisystem eingehängt war, werden alle Prozesse, die das
  nächsthöhere Dateisystem (meist /) verwenden, beendet. Das kommt einem
  Ausschalten des Rechners schon sehr nahe. Darum gibt es, quasi als
  Sicherheitsgurt für solche Fälle, die Option \verb?--ismountpoint?
  (\verb?-M?), mit der alle Aktionen nur dann ausgeführt werden, wenn der
  angegebene Dateiname ein Mountpoint ist. Außerdem kann ich mit der Option
  \verb?-w? das Senden des Signals auf Prozesse einschränken, die eine Datei
  zum Schreiben geöffnet haben. Das ist dann interessant, wenn ich das Datei
  von read-write auf read-only umhängen will.

\end{normaltext}

\section{lsof}
\label{sec:lokal-werkzeuge-lsof}
\begin{abstractsec}
  Ein Werkzeug, dass in keinem Werkzeugkasten für die lokale Fehlersuche fehlen
  sollte, ist lsof. Dieses Programm zeigt Informationen zu Dateien, die von
  Prozessen geöffnet sind, an.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, dass in meinem Werkzeugkasten für die lokale Fehlersuche nicht
  fehlen darf, ist lsof. Dieses Programm zeigt Informationen zu Dateien, die
  von laufenden Prozessen geöffnet sind, an.

  Ich habe dieses Programm erfolgreich beim Untersuchen von Mount-Problemen
  eingesetzt.
  Auch beim Aufspüren und Untersuchen von Sicherheitsproblemen leistet es
  wertvolle Dienste.

  Außer für Linux gibt es dieses Programm auch für andere UNIX-Derivate, bei
  denen einige Optionen eine andere Bedeutung haben. Aus diesem Grund und weil
  ich hier nicht alle Optionen erläutern werde, ist ein Blick in die
  entsprechende Handbuchseite unumgänglich.

  Offene Dateien, die lsof auflistet können
  \begin{itemize}
    \item reguläre Dateien,
    \item Verzeichnisse,
    \item block- oder zeichenorientierte Spezialdateien,
    \item Verweise auf ausführbaren Code,
    \item Bibliotheken,
    \item UNIX- oder Netzwerksockets sein.
  \end{itemize}

  In einigen Aspekten überschneidet sich die Funktionialität von lsof mit der
  von netstat, welches ich weiter hinten in 
  Sektion \ref{sec:lokal-werkzeuge-netstat}
  beschreibe. Meist entscheide ich je nach vorliegendem Problem, zu welchem
  der Programme ich greife.

  Es ist möglich, von lsof statt einer einmaligen Ausgabe, automatisch in
  bestimmten Abständen neue Schnappschüsse der angeforderten Informationen zu
  erhalten und die Ausgabe dazu so umzuformen, dass sie gut von einem Skript
  oder sonstigem Programm überwacht werden kann.

  Rufe ich lsof ohne Optionen und Argumente auf, bekomme ich eine Liste aller
  Dateien, die alle laufenden Prozesse im Moment geöffnet haben. Bin ich nur
  an wenigen Dateien interessiert, gebe ich diese als Argumente auf der
  Kommandozeile an. Bin ich nur an bestimmten Aspekten oder an Dateien, die
  ich zwar selbst nicht genau kenne, aber deren Eigenschaften, so
  spezifiziere ich das mit Optionen. Einige dieser Optionen will ich hier
  vorstellen.
  
  Selektiere ich mit einer Option eine definierte Menge von
  Dateien, dann werden nur die Dateien, die dieser Selektion genögen,
  angezeigt. Gebe ich mehrere Selektoren an, dann werden alle Dateien
  angezeigt, die irgendeinem dieser Selektoren entsprechen. Das heißt, die
  Menge der angezeigten Dateien entspricht der ODER-Verknüpfung der einzelnen
  Selektoren. Dazu gibt es folgende Ausnahme: wenn ich mit einer Option
  bestimmte Dateien deselektiere (zum Beispiel durch vorangestelltes \verb?^?
  bei Auswahllisten), dann werden diese Dateien auch nicht angezeigt, wenn sie
  nach einem anderen Selektor drann wären. Außerdem kann ich die Verknüpfung
  der Selektionskriterien mit der Option \verb?-a? von ODER auf UND umstellen.
  Gebe ich mehrmals die gleiche Option mit verschiedenen Selektoren an, so
  werden diese vor der ODER- beziehungsweise UND-Verknüpfung zu einem Selektor
  zusammengefasst.
  Wenn ich zum Beispiel nur an allen Internetsockets interessiert bin, die von
  Prozessen mit UID xyz geöffnet sind, dann schreibe ich:
  \begin{verbatim}
    lsof -a -i -u xyz
  \end{verbatim}
  
  Nun zu den Optionen.

  Mit Option \verb?-c name? selektiere ich Prozesse, deren Name mit \verb?name?
  beginnt. Fängt \verb?name? selbst mit \verb?^? an, dann werden genau diese
  Prozesse ignoriert. Beginnt und endet \verb?name? mit einem Schrägstrich
  (\verb?/?), dann wird er als regulärer Ausdruck interpretiert.

  Mit der Option \verb?+d s? bekomme ich alle geöffneten Dateien direkt im
  Verzeichnis \verb?s?. Demgegenüber liefert \verb?+D s? auch die Dateien und
  Verzeichnisse in den Unterverzeichnissen von \verb?s?, die von Prozessen
  geöffnet sind. Beide Optionen kann ich mit \verb?-x? kombinieren, damit lsof
  symbolischen Links folgen und Mountpoints überqueren soll, was es ansonsten
  nicht machen würde.

  Die Option \verb?-d s? erwartet eine Liste von Dateideskriptoren (diese
  stehen in der Ausgabe in Spalte FD), die ich einschließen, oder mit \verb?^?
  ausschließen kann. Möchte ich zwar das Arbeitsverzeichnis, aber nicht die
  Standardeingabe, -ausgabe und -fehlerausgabe von Prozessen wissen, dann
  drücke ich das so aus:
  \begin{verbatim}
    lsof -d cwd,^0,^1,^2
  \end{verbatim}

  Mit der Option \verb?-i [m]? bekomme ich Internetsockets und zwar speziell
  für TCP oder UDP angezeigt. Optional kann ich diese mit dem Muster \verb?m?
  genauer spezifizieren. Dazu gebe ich \verb?m? in der folgenden Form
  \verb?[46][protocol][@hostname|hostaddr][:service|port]? an. Hierbei steht
  \begin{description}
    \item[4] für die Beschränkung auf IPv4
    \item[6] für die Beschränkung auf IPv6
    \item[protocol] für den Protokollnamen TCP oder UDP
    \item[hostname] für einen Internet-Hostnamen oder alternativ
    \item[hostaddr] für eine numerische Adresse
    \item[service] für einen Servicenamen aus /etc/services oder alternativ
    \item[port] für die Portnummer
  \end{description}
  Demgegenüber kann ich mit \verb?-U? UNIX-Domain-Sockets auswählen.

  Die Option \verb?-n? unterdrückt die Umwandlung von Netzadressen in Namen,
  \verb?-P? die Umwandlung von Portnummern in Servicenamen und schließlich
  \verb?-l? die Umwandlung von UID in Benutzernamen. Diese Optionen verwende
  ich, wenn ich mehr Klarheit haben will, oder wenn diese Umwandlung
  ihrerseits die Ausführung von lsof verzögert, weil DNS- oder NIS-Anfragen
  für die Auflösung notwendig sind.

  Mit der Option \verb?-u s? lassen sich die Prozesse nach UID oder
  Benutzernamen auswählen, während ich mit \verb?-p s? die Prozesse direkt
  nach PID auswählen kann.

  Starte ich lsof mit Otion \verb?-r [t]?, so liefert es die Informationen
  wiederholt in dem mit \verb?t? spezifizierten Zeitabstand (ohne Angabe 15
  Sekunden). Diese Option kann ich mit \verb?-F f? kombinieren um die Ausgabe
  für die einfachere Verarbeitung in einem Skript zu modifizieren.
\end{normaltext}

\section{netstat}
\label{sec:lokal-werkzeuge-netstat}
\begin{abstractsec}
  In den meisten Fällen setze ich netstat bei Netzwerkproblemen ein.
  Wenn ich jedoch Probleme mit UNIX-Sockets vermute oder den Prozess, der
  einen bestimmten Socket verwendet ermitteln will, hilft es mir auch bei der
  lokalen Fehlersuche.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, das sowohl bei der lokalen, als auch bei der Fehlersuche im
  Netzwerk behilflich sein kann, ist netstat. Auf den Aspekt
  Netzwerkfehlersuche gehe ich im Abschnitt \ref{sec:netz-werkzeuge-netstat}
  näher ein. Hier konzentriere ich mich auf die Fehlersuche bei lokalen
  Problemen.

  Dafür verwende ich vor allem die Optionen \verb?--protocol=unix?
  (alternativ: \verb?-A unix?) oder \verb?--unix? (\verb?-x?) um mir die
  UNIX-Sockets ausgeben zu lassen.
  Bin ich an den Prozessen interessiert, die die Netzwerksockets verwenden,
  kann ich diese stattdessen mit \verb?--inet?, \verb?--ipx?, \verb?--tcp?,
  \ldots selektieren. Das ist ausführlicher in Abschnitt
  \ref{sec:netz-werkzeuge-netstat} beschrieben.

  Mit \verb?--program? (\verb?-p?) erhalte ich die PID und den Namen des
  Prozesses, der den Socket benutzt. Dafür benötige ich Superuser-Privilegien.
  Mit dieser PID kann ich dann zum Beispiel den Prozess mit strace näher
  betrachten.

  Normalerweise zeigt netstat nur aktive, das heißt verbundene Sockets an. Mit
  der Option \verb?--listening? (\verb?-l?) kann ich dagegen nur die Sockets
  ausgeben lassen, die auf eine Verbindung warten oder mit \verb?--all?
  (\verb?-a?) alle.

  Mehr Informationen kann ich bekommen, wenn ich zusätzlich die Optionen
  \verb?--verbose? (\verb?-v?) oder \verb?--extend? (\verb?-e?) angebe.

  Die Ausgabe von netstat kommt als Tabelle, deren Spalten die folgende
  Bedeutung haben:
  \begin{description}
    \item[RefCnt] Zeigt die Anzahl der Prozesse, die sich mit dem Socket
      verbunden haben.
    \item[Flags] geben zusätzliche Informationen zum Zustand des Sockets aus:
      \begin{description}
        \item[ACC] - der Socket wartet auf eine Verbindung
        \item[W] - der Socket wartet auf Daten
        \item[N] - der Socket hat im Moment nicht genug Platz zum Schreiben
      \end{description}
    \item[Typ] kann stehen für
      \begin{description}
        \item[DGRAM] für verbindungslose Sockets
        \item[STREAM] für verbundene Sockets
        \item[RAW] für rohe ungefilterte Sockets %XXX FIXME
        \item[RDM] für zuverlässig ausgelieferte Nachrichten (Reliable
          Delivered Messages)
        \item[SEQPACKETS] für nacheinander folgende Pakete %XXX FIXME
        \item[PACKET] für rohe Interface-Sockets %XXX FIXME
      \end{description}
    \item[State] kann für einen der folgenden Zustände des Sockets stehen:
      \begin{description}
        \item[Free] - nicht allozierte Sockets %XXX FIXME
        \item[Listening] - nicht verbundene Sockets
        \item[Connecting, Connected, Disconnected] - die Phasen einer
          Socketverbindung
        \item[(empty)] für unverbundene Sockets %XXX FIXME
      \end{description}
    \item[PID] enthält die Prozess-ID und den Namen des Prozesses
    \item[Path] zeigt den Pfad zum Socket vom Prozess aus an, relativ zum
      Arbeitsverzeichnis des Prozesses
  \end{description}
\end{normaltext}

\section{strace}
\label{sec:lokal-werkzeuge-strace}

\begin{abstractsec}
  Mit strace kann ich die Interaktion eines Programmes mit dem Linux-Kernel
  beobachten. Dieses verwende ich zum Beispiel um unvorhergesehene
  Programmabrüche oder unerklärliches Verhalten eines Binärprogrammes zu
  analysieren.
\end{abstractsec}
\begin{normaltext}
  Strace ist ein Werkzeug, dass ich einsetze, wenn mir das Verhalten eines
  Programmes unklar ist. Wenn ich Probleme mit Zugriffsrechten vermute, aber
  keinen Anhaltspunkt in den Fehlermeldungen oder Systemprotokollen finde.
  Wenn ich mit einem Programm noch wenig Erfahrung habe, kaum Hilfe zu meinem
  Problem im Internet finde, aber das Problem trotzdem so schnell wie möglich
  beheben will.
  In \cite{guug:uptimes:2012.1/07} führt Harald König sehr gut in die Arbeit
  mit strace ein.
  
  Strace hilft mir, wenn ich beobachten will, wie ein Programm
  mit seiner Umgebung interagiert. Es setzt dazu an der Kernelschnittstelle
  an und protokolliert alle Systemaufrufe mit den Parametern und Ergebnissen.
  Diese werden im Protokoll ähnlich den Systemaufrufen in der
  Programmiersprache C dargestellt: das Ergebnis steht hinter einem
  Gleichheitszeichen am Ende der Zeile, die Systemzeit steht vor dem
  Systemaufruf. Wenn ich mehrere Prozesse beobachte und in dieselbe Datei
  protokolliere, steht auch noch die Prozess-ID am Anfang der Zeile.

  Um die Ausgabe von strace interpretieren zu können, ist es hilfreich die
  Sektion der Handbuchseiten zu installiert zu haben. Diese befinden sich bei
  Debian-basierten Systemen im Paket manpages-dev.

  Da strace Systemaufrufe der beobachteten Prozesse protokolliert, verlangsamt
  sich deren Ablauf, was zu zusätzlichen Problemen bei der Fehlersuche führen
  kann. Dessen muss ich mir beim Einsatz von strace immer bewusst sein.

  Ich persönlich setze strace bei der Fehlersuche meist auf eine der folgenden
  Weisen ein.

  Bei Problemen mit mit Programmen, die von Hand aufgerufen werden, starte ich
  das betreffende Programm wie gewohnt, allerdings setze ich am Anfang der
  Kommandozeile strace mit einigen Optionen ein. Aus

  \begin{verbatim}
  $ make xyz
  \end{verbatim}

  wird dann

  \begin{verbatim}
  $ strace -f -o make.strace make xyz
  \end{verbatim}

  Dabei bedeuten die Optionen

  \begin{description}
    \item[-f] Strace soll auch von make gestartete Programme verfolgen.
    \item[-o make.strace] Die Ausgabe soll in die Datei make.strace
      geschrieben werden.
  \end{description}

  Bei Problemen mit bereits gestarteten Prozessen verwende ich die Option
  {\bf -p PID} um mich mit dem betreffenden Prozess zu verbinden. Alle
  weiteren Optionen verwende ich wie gehabt, auf die Angabe des Programmnamens
  und der Programmparameter kann ich verzichten.

  Schwieriger ist es, wenn ein Programm ein zweites aufruft, dieses ein
  drittes und so weiter. Wenn ich nur an einem der Programme interessiert bin
  und nicht genau weiss, von welchem Prozess beziehungsweise Programm dieses
  gestartet wird, helfe ich mir mit einem Trick. Ich benenne das eigentliche
  Programm um und ersetze es durch ein Skript, welche alle mich
  interessierenden Werte wie zum Beispiel die Aufrufparameter, die Umgebung,
  die UID/GID, die Standardeingabe und/oder -ausgabe protokolliert und
  schließlich das Originalprogramm via strace aufruft.
  Damit bekomme ich meist genügend Informationen, um das Problem zu lösen.
  Natürlich darf ich am Ende nicht vergessen, das Skript wieder durch das
  Originalprogramm zu ersetzen.
\end{normaltext}

\begin{notes}
\item Was für eine Kernelschnittstelle nutzt strace?
\item Strace-Skript: Datum, Kommandozeile, Umgebung, Benutzer,
  Standardeingabe, Strace-Ausgabe
\end{notes}

%\subsection{Seiteneffekte}
%\label{sec:seiteneffekte}

%\subsection{Einschränkung der Umsetzung}
%\label{sec:einschr-der-umsetz}

%\section{Schnittstellen nach außen}
%\label{sec:schn-nach-au3en}

%\subsection{Schnittstelle zu A}
%\label{sec:schnittstelle-zu}

%\subsection{Schnittstelle zu B}
%\label{sec:schnittstelle-zu-b}

%\begin{notes}
%\item Syntax
%\item Semantik
%\end{notes}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "arbeit-hauptdatei"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:

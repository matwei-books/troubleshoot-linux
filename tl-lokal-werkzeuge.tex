%% tl-lokal-werkzeuge.tex
\chapter{Werkzeuge zur lokalen Fehlersuche}
\label{cha:lokal-werkzeuge}

\begin{abstractsec}
  Verschiedene Werkzeuge helfen mir lokale Probleme einzugrenzen. Hier stelle
  ich die Werkzeuge kurz vor, die ich in den nächsten drei Kapiteln zur
  Fehlersuche einsetze.
\end{abstractsec}

\begin{normaltext}
  Linux stellt mir eine Unmenge von Werkzeugen für die Fehlersuche zur
  Verfügung. Etliche davon kommen mir sowohl bei Total- oder Partialausfällen
  zu gute. Andere bei Performanceproblemen. Einige sind so nützlich, dass sie
  immer wieder bei den unterschiedlichsten Problemen zum Einsatz kommen. Da
  es mir schwerfällt, die einzelnen Werkzeuge bestimmten Kategorien
  zuzuordnen, stelle ich diese nachfolgend in alphabetischer Reihenfolge vor.
  Das erleichtert zumindest das Wiederfinden, wenn man mal eben etwas schnell
  nachschlagen möchte.
\end{normaltext}

\begin{notes}
\item hdparm
\item fuser
\item gdb
\item ifconfig
\item iproute
\item lsof
\item ltrace
\item perl
\item shell
\end{notes}

\section{netstat}
\label{sec:lokal-werkzeuge-netstat}
\begin{abstractsec}
  In den meisten Fällen setze ich netstat bei Netzwerkproblemen ein.
  Wenn ich jedoch Probleme mit UNIX-Sockets vermute oder den Prozess, der
  einen bestimmten Socket verwendet ermitteln will, hilft es mir auch bei der
  lokalen Fehlersuche.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, das sowohl bei der lokalen, als auch bei der Fehlersuche im
  Netzwerk behilflich sein kann, ist netstat. Auf den Aspekt
  Netzwerkfehlersuche gehe ich im Abschnitt \ref{sec:netz-werkzeuge-netstat}
  näher ein. Hier konzentriere ich mich auf die Fehlersuche bei lokalen
  Problemen.

  Dafür verwende ich vor allem die Optionen \verb?--protocol=unix?
  (alternativ: \verb?-A unix?) oder \verb?--unix? (\verb?-x?) um mir die
  UNIX-Sockets ausgeben zu lassen.
  Bin ich an den Prozessen interessiert, die die Netzwerksockets verwenden,
  kann ich diese stattdessen mit \verb?--inet?, \verb?--ipx?, \verb?--tcp?,
  \ldots selektieren. Das ist ausführlicher in Abschnitt
  \ref{sec:netz-werkzeuge-netstat} beschrieben.

  Mit \verb?--program? (\verb?-p?) erhalte ich die PID und den Namen des
  Prozesses, der den Socket benutzt. Dafür benötige ich Superuser-Privilegien.
  Mit dieser PID kann ich dann zum Beispiel den Prozess mit strace näher
  betrachten.

  Normalerweise zeigt netstat nur aktive, das heißt verbundene Sockets an. Mit
  der Option \verb?--listening? (\verb?-l?) kann ich dagegen nur die Sockets
  ausgeben lassen, die auf eine Verbindung warten oder mit \verb?--all?
  (\verb?-a?) alle.

  Mehr Informationen kann ich bekommen, wenn ich zusätzlich die Optionen
  \verb?--verbose? (\verb?-v?) oder \verb?--extend? (\verb?-e?) angebe.

  Die Ausgabe von netstat kommt als Tabelle, deren Spalten die folgende
  Bedeutung haben:
  \begin{description}
    \item[RefCnt] Zeigt die Anzahl der Prozesse, die sich mit dem Socket
      verbunden haben.
    \item[Flags] geben zusätzliche Informationen zum Zustand des Sockets aus:
      \begin{description}
        \item[ACC] - der Socket wartet auf eine Verbindung
        \item[W] - der Socket wartet auf Daten
        \item[N] - der Socket hat im Moment nicht genug Platz zum Schreiben
      \end{description}
    \item[Typ] kann stehen für
      \begin{description}
        \item[DGRAM] für verbindungslose Sockets
        \item[STREAM] für verbundene Sockets
        \item[RAW] für rohe ungefilterte Sockets %XXX FIXME
        \item[RDM] für zuverlässig ausgelieferte Nachrichten (Reliable
          Delivered Messages)
        \item[SEQPACKETS] für nacheinander folgende Pakete %XXX FIXME
        \item[PACKET] für rohe Interface-Sockets %XXX FIXME
      \end{description}
    \item[State] kann für einen der folgenden Zustände des Sockets stehen:
      \begin{description}
        \item[Free] - nicht allozierte Sockets %XXX FIXME
        \item[Listening] - nicht verbundene Sockets
        \item[Connecting, Connected, Disconnected] - die Phasen einer
          Socketverbindung
        \item[(empty)] für unverbundene Sockets %XXX FIXME
      \end{description}
    \item[PID] enthält die Prozess-ID und den Namen des Prozesses
    \item[Path] zeigt den Pfad zum Socket vom Prozess aus an, relativ zum
      Arbeitsverzeichnis des Prozesses
  \end{description}
\end{normaltext}

\section{strace}
\label{sec:lokal-werkzeuge-strace}

\begin{abstractsec}
  Mit strace kann ich die Interaktion eines Programmes mit dem Linux-Kernel
  beobachten. Dieses verwende ich zum Beispiel um unvorhergesehene
  Programmabrüche oder unerklärliches Verhalten eines Binärprogrammes zu
  analysieren.
\end{abstractsec}
\begin{normaltext}
  Strace ist ein Werkzeug, dass ich einsetze, wenn mir das Verhalten eines
  Programmes unklar ist. Wenn ich Probleme mit Zugriffsrechten vermute, aber
  keinen Anhaltspunkt in den Fehlermeldungen oder Systemprotokollen finde.
  Wenn ich mit einem Programm noch wenig Erfahrung habe, kaum Hilfe zu meinem
  Problem im Internet finde, aber das Problem trotzdem so schnell wie möglich
  beheben will.
  In \cite{guug:uptimes:2012.1/07} führt Harald König sehr gut in die Arbeit
  mit strace ein.
  
  Strace hilft mir, wenn ich beobachten will, wie ein Programm
  mit seiner Umgebung interagiert. Es setzt dazu an der Kernelschnittstelle
  an und protokolliert alle Systemaufrufe mit den Parametern und Ergebnissen.
  Diese werden im Protokoll ähnlich den Systemaufrufen in der
  Programmiersprache C dargestellt: das Ergebnis steht hinter einem
  Gleichheitszeichen am Ende der Zeile, die Systemzeit steht vor dem
  Systemaufruf. Wenn ich mehrere Prozesse beobachte und in dieselbe Datei
  protokolliere, steht auch noch die Prozess-ID am Anfang der Zeile.

  Um die Ausgabe von strace interpretieren zu können, ist es hilfreich die
  Sektion der Handbuchseiten zu installiert zu haben. Diese befinden sich bei
  Debian-basierten Systemen im Paket manpages-dev.

  Da strace Systemaufrufe der beobachteten Prozesse protokolliert, verlangsamt
  sich deren Ablauf, was zu zusätzlichen Problemen bei der Fehlersuche führen
  kann. Dessen muss ich mir beim Einsatz von strace immer bewusst sein.

  Ich persönlich setze strace bei der Fehlersuche meist auf eine der folgenden
  Weisen ein.

  Bei Problemen mit mit Programmen, die von Hand aufgerufen werden, starte ich
  das betreffende Programm wie gewohnt, allerdings setze ich am Anfang der
  Kommandozeile strace mit einigen Optionen ein. Aus

  \begin{verbatim}
  $ make xyz
  \end{verbatim}

  wird dann

  \begin{verbatim}
  $ strace -f -o make.strace make xyz
  \end{verbatim}

  Dabei bedeuten die Optionen

  \begin{description}
    \item[-f] Strace soll auch von make gestartete Programme verfolgen.
    \item[-o make.strace] Die Ausgabe soll in die Datei make.strace
      geschrieben werden.
  \end{description}

  Bei Problemen mit bereits gestarteten Prozessen verwende ich die Option
  {\bf -p PID} um mich mit dem betreffenden Prozess zu verbinden. Alle
  weiteren Optionen verwende ich wie gehabt, auf die Angabe des Programmnamens
  und der Programmparameter kann ich verzichten.

  Schwieriger ist es, wenn ein Programm ein zweites aufruft, dieses ein
  drittes und so weiter. Wenn ich nur an einem der Programme interessiert bin
  und nicht genau weiss, von welchem Prozess beziehungsweise Programm dieses
  gestartet wird, helfe ich mir mit einem Trick. Ich benenne das eigentliche
  Programm um und ersetze es durch ein Skript, welche alle mich
  interessierenden Werte wie zum Beispiel die Aufrufparameter, die Umgebung,
  die UID/GID, die Standardeingabe und/oder -ausgabe protokolliert und
  schließlich das Originalprogramm via strace aufruft.
  Damit bekomme ich meist genügend Informationen, um das Problem zu lösen.
  Natürlich darf ich am Ende nicht vergessen, das Skript wieder durch das
  Originalprogramm zu ersetzen.
\end{normaltext}

\begin{notes}
\item Was für eine Kernelschnittstelle nutzt strace?
\item Strace-Skript: Datum, Kommandozeile, Umgebung, Benutzer,
  Standardeingabe, Strace-Ausgabe
\end{notes}

%\subsection{Seiteneffekte}
%\label{sec:seiteneffekte}

%\subsection{Einschränkung der Umsetzung}
%\label{sec:einschr-der-umsetz}

%\section{Schnittstellen nach außen}
%\label{sec:schn-nach-au3en}

%\subsection{Schnittstelle zu A}
%\label{sec:schnittstelle-zu}

%\subsection{Schnittstelle zu B}
%\label{sec:schnittstelle-zu-b}

%\begin{notes}
%\item Syntax
%\item Semantik
%\end{notes}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "arbeit-hauptdatei"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:

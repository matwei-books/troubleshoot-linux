%% tl-lokal-werkzeuge.tex
\chapter{Werkzeuge zur lokalen Fehlersuche}
\label{cha:lokal-werkzeuge}

\begin{abstractsec}
  Verschiedene Werkzeuge helfen mir lokale Probleme einzugrenzen. Hier stelle
  ich die Werkzeuge kurz vor, die ich in den nächsten drei Kapiteln zur
  Fehlersuche einsetze.
\end{abstractsec}

\begin{normaltext}
  Linux stellt mir eine Unmenge von Werkzeugen für die Fehlersuche zur
  Verfügung. Etliche davon kommen mir sowohl bei Total- oder Partialausfällen
  zu gute. Andere bei Performanceproblemen. Einige sind so nützlich, dass sie
  immer wieder bei den unterschiedlichsten Problemen zum Einsatz kommen. Da
  es mir schwerfällt, die einzelnen Werkzeuge bestimmten Kategorien
  zuzuordnen, stelle ich diese nachfolgend in alphabetischer Reihenfolge vor.
  Das erleichtert zumindest das Wiederfinden, wenn man mal eben etwas schnell
  nachschlagen möchte.
\end{normaltext}

\begin{notes}
\item hdparm
\item fuser
\item gdb
\item ifconfig
\item iproute
\item lsof
\item ltrace
\item perl
\item shell
\end{notes}

\section{lsof}
\label{sec:lokal-werkzeuge-lsof}
\begin{abstractsec}
  Ein Werkzeug, dass in keinem Werkzeugkasten für die lokale Fehlersuche fehlen
  sollte, ist lsof. Dieses Programm zeigt Informationen zu Dateien, die von
  Prozessen geöffnet sind, an.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, dass in meinem Werkzeugkasten für die lokale Fehlersuche nicht
  fehlen darf, ist lsof. Dieses Programm zeigt Informationen zu Dateien, die
  von laufenden Prozessen geöffnet sind, an.

  Ich habe dieses Programm erfolgreich beim Untersuchen von Mount-Problemen
  eingesetzt.
  Auch beim Aufspüren und Untersuchen von Sicherheitsproblemen leistet es
  wertvolle Dienste.

  Außer für Linux gibt es dieses Programm auch für andere UNIX-Derivate, bei
  denen einige Optionen eine andere Bedeutung haben. Aus diesem Grund und weil
  ich hier nicht alle Optionen erläutern werde, ist ein Blick in die
  entsprechende Handbuchseite unumgänglich.

  Offene Dateien, die lsof auflistet können
  \begin{itemize}
    \item reguläre Dateien,
    \item Verzeichnisse,
    \item block- oder zeichenorientierte Spezialdateien,
    \item Verweise auf ausführbaren Code,
    \item Bibliotheken,
    \item UNIX- oder Netzwerksockets sein.
  \end{itemize}

  In einigen Aspekten überschneidet sich die Funktionialität von lsof mit der
  von netstat, welches ich weiter hinten in 
  Sektion \ref{sec:lokal-werkzeuge-netstat}
  beschreibe. Meist entscheide ich je nach vorliegendem Problem, zu welchem
  der Programme ich greife.

  Es ist möglich, von lsof statt einer einmaligen Ausgabe, automatisch in
  bestimmten Abständen neue Schnappschüsse der angeforderten Informationen zu
  erhalten und die Ausgabe dazu so umzuformen, dass sie gut von einem Skript
  oder sonstigem Programm überwacht werden kann.

  Rufe ich lsof ohne Optionen und Argumente auf, bekomme ich eine Liste aller
  Dateien, die alle laufenden Prozesse im Moment geöffnet haben. Bin ich nur
  an wenigen Dateien interessiert, gebe ich diese als Argumente auf der
  Kommandozeile an. Bin ich nur an bestimmten Aspekten oder an Dateien, die
  ich zwar selbst nicht genau kenne, aber deren Eigenschaften, so
  spezifiziere ich das mit Optionen. Einige dieser Optionen will ich hier
  vorstellen.
  
  Selektiere ich mit einer Option eine definierte Menge von
  Dateien, dann werden nur die Dateien, die dieser Selektion genögen,
  angezeigt. Gebe ich mehrere Selektoren an, dann werden alle Dateien
  angezeigt, die irgendeinem dieser Selektoren entsprechen. Das heißt, die
  Menge der angezeigten Dateien entspricht der ODER-Verknüpfung der einzelnen
  Selektoren. Dazu gibt es folgende Ausnahme: wenn ich mit einer Option
  bestimmte Dateien deselektiere (zum Beispiel durch vorangestelltes \verb?^?
  bei Auswahllisten), dann werden diese Dateien auch nicht angezeigt, wenn sie
  nach einem anderen Selektor drann wären. Außerdem kann ich die Verknüpfung
  der Selektionskriterien mit der Option \verb?-a? von ODER auf UND umstellen.
  Gebe ich mehrmals die gleiche Option mit verschiedenen Selektoren an, so
  werden diese vor der ODER- beziehungsweise UND-Verknüpfung zu einem Selektor
  zusammengefasst.
  Wenn ich zum Beispiel nur an allen Internetsockets interessiert bin, die von
  Prozessen mit UID xyz geöffnet sind, dann schreibe ich:
  \begin{verbatim}
    lsof -a -i -u xyz
  \end{verbatim}
  
  Nun zu den Optionen.

  Mit Option \verb?-c name? selektiere ich Prozesse, deren Name mit \verb?name?
  beginnt. Fängt \verb?name? selbst mit \verb?^? an, dann werden genau diese
  Prozesse ignoriert. Beginnt und endet \verb?name? mit einem Schrägstrich
  (\verb?/?), dann wird er als regulärer Ausdruck interpretiert.

  Mit der Option \verb?+d s? bekomme ich alle geöffneten Dateien direkt im
  Verzeichnis \verb?s?. Demgegenüber liefert \verb?+D s? auch die Dateien und
  Verzeichnisse in den Unterverzeichnissen von \verb?s?, die von Prozessen
  geöffnet sind. Beide Optionen kann ich mit \verb?-x? kombinieren, damit lsof
  symbolischen Links folgen und Mountpoints überqueren soll, was es ansonsten
  nicht machen würde.

  Die Option \verb?-d s? erwartet eine Liste von Dateideskriptoren (diese
  stehen in der Ausgabe in Spalte FD), die ich einschließen, oder mit \verb?^?
  ausschließen kann. Möchte ich zwar das Arbeitsverzeichnis, aber nicht die
  Standardeingabe, -ausgabe und -fehlerausgabe von Prozessen wissen, dann
  drücke ich das so aus:
  \begin{verbatim}
    lsof -d cwd,^0,^1,^2
  \end{verbatim}

  Mit der Option \verb?-i [m]? bekomme ich Internetsockets und zwar speziell
  für TCP oder UDP angezeigt. Optional kann ich diese mit dem Muster \verb?m?
  genauer spezifizieren. Dazu gebe ich \verb?m? in der folgenden Form
  \verb?[46][protocol][@hostname|hostaddr][:service|port]? an. Hierbei steht
  \begin{description}
    \item[4] für die Beschränkung auf IPv4
    \item[6] für die Beschränkung auf IPv6
    \item[protocol] für den Protokollnamen TCP oder UDP
    \item[hostname] für einen Internet-Hostnamen oder alternativ
    \item[hostaddr] für eine numerische Adresse
    \item[service] für einen Servicenamen aus /etc/services oder alternativ
    \item[port] für die Portnummer
  \end{description}
  Demgegenüber kann ich mit \verb?-U? UNIX-Domain-Sockets auswählen.

  Die Option \verb?-n? unterdrückt die Umwandlung von Netzadressen in Namen,
  \verb?-P? die Umwandlung von Portnummern in Servicenamen und schließlich
  \verb?-l? die Umwandlung von UID in Benutzernamen. Diese Optionen verwende
  ich, wenn ich mehr Klarheit haben will, oder wenn diese Umwandlung
  ihrerseits die Ausführung von lsof verzögert, weil DNS- oder NIS-Anfragen
  für die Auflösung notwendig sind.

  Mit der Option \verb?-u s? lassen sich die Prozesse nach UID oder
  Benutzernamen auswählen, während ich mit \verb?-p s? die Prozesse direkt
  nach PID auswählen kann.

  Starte ich lsof mit Otion \verb?-r [t]?, so liefert es die Informationen
  wiederholt in dem mit \verb?t? spezifizierten Zeitabstand (ohne Angabe 15
  Sekunden). Diese Option kann ich mit \verb?-F f? kombinieren um die Ausgabe
  für die einfachere Verarbeitung in einem Skript zu modifizieren.
\end{normaltext}

\section{netstat}
\label{sec:lokal-werkzeuge-netstat}
\begin{abstractsec}
  In den meisten Fällen setze ich netstat bei Netzwerkproblemen ein.
  Wenn ich jedoch Probleme mit UNIX-Sockets vermute oder den Prozess, der
  einen bestimmten Socket verwendet ermitteln will, hilft es mir auch bei der
  lokalen Fehlersuche.
\end{abstractsec}
\begin{normaltext}
  Ein Werkzeug, das sowohl bei der lokalen, als auch bei der Fehlersuche im
  Netzwerk behilflich sein kann, ist netstat. Auf den Aspekt
  Netzwerkfehlersuche gehe ich im Abschnitt \ref{sec:netz-werkzeuge-netstat}
  näher ein. Hier konzentriere ich mich auf die Fehlersuche bei lokalen
  Problemen.

  Dafür verwende ich vor allem die Optionen \verb?--protocol=unix?
  (alternativ: \verb?-A unix?) oder \verb?--unix? (\verb?-x?) um mir die
  UNIX-Sockets ausgeben zu lassen.
  Bin ich an den Prozessen interessiert, die die Netzwerksockets verwenden,
  kann ich diese stattdessen mit \verb?--inet?, \verb?--ipx?, \verb?--tcp?,
  \ldots selektieren. Das ist ausführlicher in Abschnitt
  \ref{sec:netz-werkzeuge-netstat} beschrieben.

  Mit \verb?--program? (\verb?-p?) erhalte ich die PID und den Namen des
  Prozesses, der den Socket benutzt. Dafür benötige ich Superuser-Privilegien.
  Mit dieser PID kann ich dann zum Beispiel den Prozess mit strace näher
  betrachten.

  Normalerweise zeigt netstat nur aktive, das heißt verbundene Sockets an. Mit
  der Option \verb?--listening? (\verb?-l?) kann ich dagegen nur die Sockets
  ausgeben lassen, die auf eine Verbindung warten oder mit \verb?--all?
  (\verb?-a?) alle.

  Mehr Informationen kann ich bekommen, wenn ich zusätzlich die Optionen
  \verb?--verbose? (\verb?-v?) oder \verb?--extend? (\verb?-e?) angebe.

  Die Ausgabe von netstat kommt als Tabelle, deren Spalten die folgende
  Bedeutung haben:
  \begin{description}
    \item[RefCnt] Zeigt die Anzahl der Prozesse, die sich mit dem Socket
      verbunden haben.
    \item[Flags] geben zusätzliche Informationen zum Zustand des Sockets aus:
      \begin{description}
        \item[ACC] - der Socket wartet auf eine Verbindung
        \item[W] - der Socket wartet auf Daten
        \item[N] - der Socket hat im Moment nicht genug Platz zum Schreiben
      \end{description}
    \item[Typ] kann stehen für
      \begin{description}
        \item[DGRAM] für verbindungslose Sockets
        \item[STREAM] für verbundene Sockets
        \item[RAW] für rohe ungefilterte Sockets %XXX FIXME
        \item[RDM] für zuverlässig ausgelieferte Nachrichten (Reliable
          Delivered Messages)
        \item[SEQPACKETS] für nacheinander folgende Pakete %XXX FIXME
        \item[PACKET] für rohe Interface-Sockets %XXX FIXME
      \end{description}
    \item[State] kann für einen der folgenden Zustände des Sockets stehen:
      \begin{description}
        \item[Free] - nicht allozierte Sockets %XXX FIXME
        \item[Listening] - nicht verbundene Sockets
        \item[Connecting, Connected, Disconnected] - die Phasen einer
          Socketverbindung
        \item[(empty)] für unverbundene Sockets %XXX FIXME
      \end{description}
    \item[PID] enthält die Prozess-ID und den Namen des Prozesses
    \item[Path] zeigt den Pfad zum Socket vom Prozess aus an, relativ zum
      Arbeitsverzeichnis des Prozesses
  \end{description}
\end{normaltext}

\section{strace}
\label{sec:lokal-werkzeuge-strace}

\begin{abstractsec}
  Mit strace kann ich die Interaktion eines Programmes mit dem Linux-Kernel
  beobachten. Dieses verwende ich zum Beispiel um unvorhergesehene
  Programmabrüche oder unerklärliches Verhalten eines Binärprogrammes zu
  analysieren.
\end{abstractsec}
\begin{normaltext}
  Strace ist ein Werkzeug, dass ich einsetze, wenn mir das Verhalten eines
  Programmes unklar ist. Wenn ich Probleme mit Zugriffsrechten vermute, aber
  keinen Anhaltspunkt in den Fehlermeldungen oder Systemprotokollen finde.
  Wenn ich mit einem Programm noch wenig Erfahrung habe, kaum Hilfe zu meinem
  Problem im Internet finde, aber das Problem trotzdem so schnell wie möglich
  beheben will.
  In \cite{guug:uptimes:2012.1/07} führt Harald König sehr gut in die Arbeit
  mit strace ein.
  
  Strace hilft mir, wenn ich beobachten will, wie ein Programm
  mit seiner Umgebung interagiert. Es setzt dazu an der Kernelschnittstelle
  an und protokolliert alle Systemaufrufe mit den Parametern und Ergebnissen.
  Diese werden im Protokoll ähnlich den Systemaufrufen in der
  Programmiersprache C dargestellt: das Ergebnis steht hinter einem
  Gleichheitszeichen am Ende der Zeile, die Systemzeit steht vor dem
  Systemaufruf. Wenn ich mehrere Prozesse beobachte und in dieselbe Datei
  protokolliere, steht auch noch die Prozess-ID am Anfang der Zeile.

  Um die Ausgabe von strace interpretieren zu können, ist es hilfreich die
  Sektion der Handbuchseiten zu installiert zu haben. Diese befinden sich bei
  Debian-basierten Systemen im Paket manpages-dev.

  Da strace Systemaufrufe der beobachteten Prozesse protokolliert, verlangsamt
  sich deren Ablauf, was zu zusätzlichen Problemen bei der Fehlersuche führen
  kann. Dessen muss ich mir beim Einsatz von strace immer bewusst sein.

  Ich persönlich setze strace bei der Fehlersuche meist auf eine der folgenden
  Weisen ein.

  Bei Problemen mit mit Programmen, die von Hand aufgerufen werden, starte ich
  das betreffende Programm wie gewohnt, allerdings setze ich am Anfang der
  Kommandozeile strace mit einigen Optionen ein. Aus

  \begin{verbatim}
  $ make xyz
  \end{verbatim}

  wird dann

  \begin{verbatim}
  $ strace -f -o make.strace make xyz
  \end{verbatim}

  Dabei bedeuten die Optionen

  \begin{description}
    \item[-f] Strace soll auch von make gestartete Programme verfolgen.
    \item[-o make.strace] Die Ausgabe soll in die Datei make.strace
      geschrieben werden.
  \end{description}

  Bei Problemen mit bereits gestarteten Prozessen verwende ich die Option
  {\bf -p PID} um mich mit dem betreffenden Prozess zu verbinden. Alle
  weiteren Optionen verwende ich wie gehabt, auf die Angabe des Programmnamens
  und der Programmparameter kann ich verzichten.

  Schwieriger ist es, wenn ein Programm ein zweites aufruft, dieses ein
  drittes und so weiter. Wenn ich nur an einem der Programme interessiert bin
  und nicht genau weiss, von welchem Prozess beziehungsweise Programm dieses
  gestartet wird, helfe ich mir mit einem Trick. Ich benenne das eigentliche
  Programm um und ersetze es durch ein Skript, welche alle mich
  interessierenden Werte wie zum Beispiel die Aufrufparameter, die Umgebung,
  die UID/GID, die Standardeingabe und/oder -ausgabe protokolliert und
  schließlich das Originalprogramm via strace aufruft.
  Damit bekomme ich meist genügend Informationen, um das Problem zu lösen.
  Natürlich darf ich am Ende nicht vergessen, das Skript wieder durch das
  Originalprogramm zu ersetzen.
\end{normaltext}

\begin{notes}
\item Was für eine Kernelschnittstelle nutzt strace?
\item Strace-Skript: Datum, Kommandozeile, Umgebung, Benutzer,
  Standardeingabe, Strace-Ausgabe
\end{notes}

%\subsection{Seiteneffekte}
%\label{sec:seiteneffekte}

%\subsection{Einschränkung der Umsetzung}
%\label{sec:einschr-der-umsetz}

%\section{Schnittstellen nach außen}
%\label{sec:schn-nach-au3en}

%\subsection{Schnittstelle zu A}
%\label{sec:schnittstelle-zu}

%\subsection{Schnittstelle zu B}
%\label{sec:schnittstelle-zu-b}

%\begin{notes}
%\item Syntax
%\item Semantik
%\end{notes}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "arbeit-hauptdatei"
%%% End: 
%%% vim: set sw=2 ts=2 tw=78 et si:
